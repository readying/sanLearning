/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/_css-loader@0.28.11@css-loader/index.js!./src/style.css":
/*!*********************************************************************!*\
  !*** ./node_modules/_css-loader@0.28.11@css-loader!./src/style.css ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/_css-loader@0.28.11@css-loader/lib/css-base.js */ \"./node_modules/_css-loader@0.28.11@css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".text {\\r\\n    border-bottom: 1px solid #000000;\\r\\n    padding: 5px 10px;\\r\\n    display: inline-block;\\r\\n    min-width: 100px;\\r\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUuY3NzPzkwOWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxnQ0FBaUMseUNBQXlDLDBCQUEwQiw4QkFBOEIseUJBQXlCLEtBQUs7O0FBRWhLIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9zdHlsZS5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRleHQge1xcclxcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzAwMDAwMDtcXHJcXG4gICAgcGFkZGluZzogNXB4IDEwcHg7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gICAgbWluLXdpZHRoOiAxMDBweDtcXHJcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/_css-loader@0.28.11@css-loader/index.js!./src/style.css\n");

/***/ }),

/***/ "./node_modules/_css-loader@0.28.11@css-loader/lib/css-base.js":
/*!*********************************************************************!*\
  !*** ./node_modules/_css-loader@0.28.11@css-loader/lib/css-base.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz85NWJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7O0FBRWxFO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_css-loader@0.28.11@css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/_html-loader@0.5.5@html-loader/index.js?minimize=false!./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=template&index=0!./src/App.san":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/_html-loader@0.5.5@html-loader?minimize=false!./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=template&index=0!./src/App.san ***!
  \********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"\\n<div>\\n    <div class=\\\"form-inline\\\"> \\n        <input class=\\\"form-control\\\"  type=\\\"text\\\" value=\\\"{= person.name =}\\\" placeholder=\\\"姓名(string)\\\">\\n        <input class=\\\"form-control\\\" type=\\\"number\\\" value=\\\"{= person.age  =}\\\" placeholder=\\\"年龄(number)\\\" on-input=\\\"setAge\\\">\\n        <input class=\\\"form-control\\\" value=\\\"{= person.info =}\\\" placeholder=\\\"简介(string)\\\">\\n    </div>\\n   \\n    <div>\\n        信息: <button class=\\\"btn btn-default\\\" on-click=\\\"clearPerson()\\\">移除信息</button>\\n        <p>姓名:<span class=\\\"text\\\">{{person.name| upper}}</span></p>\\n        <p>年龄: <span class=\\\"text\\\">{{person.age | upper}}</span></p>\\n        <p>简介: <span class=\\\"text\\\">{{person.info| upper}}</span> </p>\\n    </div>\\n\\n    <button class=\\\"btn btn-primary\\\" on-click=\\\"addPerson()\\\"> Add </button>\\n\\n    <table class=\\\"table\\\">\\n        <tr >\\n            <th>Name</th>\\n            <th>State</th>\\n            <th>Operation</th>\\n        </tr>\\n        <tr s-for = \\\"p, index in persons\\\">\\n            <td>{{p.name}}</td>\\n            <td>\\n                <span s-if=\\\"p.state === 0\\\">to be check</span>\\n                <span s-if=\\\"p.state === 1\\\">ok</span>\\n                <span s-if=\\\"p.state === 2\\\">not ok</span>\\n            </td>\\n            <td>\\n                <button class=\\\"btn\\\" s-if=\\\"p.state\\\" on-click=\\\"deletePerson(index)\\\">delete</button>\\n                <button class=\\\"btn\\\" s-if=\\\"!p.state\\\" on-click=\\\"checkPerson(index)\\\">check</button>\\n            </td>\\n        </tr>\\n        \\n    </table>\\n</div>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnNhbj83YmIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJIQUEySCxnQkFBZ0IsK0ZBQStGLGdCQUFnQixtR0FBbUcsZ0JBQWdCLHlMQUF5TCxvQkFBb0IsbURBQW1ELG9CQUFvQixtREFBbUQsb0JBQW9CLCtUQUErVCxRQUFRIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL19odG1sLWxvYWRlckAwLjUuNUBodG1sLWxvYWRlci9pbmRleC5qcz9taW5pbWl6ZT1mYWxzZSEuL25vZGVfbW9kdWxlcy9fc2FuLWxvYWRlckAwLjAuN0BzYW4tbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvQXBwLnNhbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWlubGluZVxcXCI+IFxcbiAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiICB0eXBlPVxcXCJ0ZXh0XFxcIiB2YWx1ZT1cXFwiez0gcGVyc29uLm5hbWUgPX1cXFwiIHBsYWNlaG9sZGVyPVxcXCLlp5PlkI0oc3RyaW5nKVxcXCI+XFxuICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiB2YWx1ZT1cXFwiez0gcGVyc29uLmFnZSAgPX1cXFwiIHBsYWNlaG9sZGVyPVxcXCLlubTpvoQobnVtYmVyKVxcXCIgb24taW5wdXQ9XFxcInNldEFnZVxcXCI+XFxuICAgICAgICA8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdmFsdWU9XFxcIns9IHBlcnNvbi5pbmZvID19XFxcIiBwbGFjZWhvbGRlcj1cXFwi566A5LuLKHN0cmluZylcXFwiPlxcbiAgICA8L2Rpdj5cXG4gICBcXG4gICAgPGRpdj5cXG4gICAgICAgIOS/oeaBrzogPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBvbi1jbGljaz1cXFwiY2xlYXJQZXJzb24oKVxcXCI+56e76Zmk5L+h5oGvPC9idXR0b24+XFxuICAgICAgICA8cD7lp5PlkI06PHNwYW4gY2xhc3M9XFxcInRleHRcXFwiPnt7cGVyc29uLm5hbWV8IHVwcGVyfX08L3NwYW4+PC9wPlxcbiAgICAgICAgPHA+5bm06b6EOiA8c3BhbiBjbGFzcz1cXFwidGV4dFxcXCI+e3twZXJzb24uYWdlIHwgdXBwZXJ9fTwvc3Bhbj48L3A+XFxuICAgICAgICA8cD7nroDku4s6IDxzcGFuIGNsYXNzPVxcXCJ0ZXh0XFxcIj57e3BlcnNvbi5pbmZvfCB1cHBlcn19PC9zcGFuPiA8L3A+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIG9uLWNsaWNrPVxcXCJhZGRQZXJzb24oKVxcXCI+IEFkZCA8L2J1dHRvbj5cXG5cXG4gICAgPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZVxcXCI+XFxuICAgICAgICA8dHIgPlxcbiAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+U3RhdGU8L3RoPlxcbiAgICAgICAgICAgIDx0aD5PcGVyYXRpb248L3RoPlxcbiAgICAgICAgPC90cj5cXG4gICAgICAgIDx0ciBzLWZvciA9IFxcXCJwLCBpbmRleCBpbiBwZXJzb25zXFxcIj5cXG4gICAgICAgICAgICA8dGQ+e3twLm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBzLWlmPVxcXCJwLnN0YXRlID09PSAwXFxcIj50byBiZSBjaGVjazwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gcy1pZj1cXFwicC5zdGF0ZSA9PT0gMVxcXCI+b2s8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIHMtaWY9XFxcInAuc3RhdGUgPT09IDJcXFwiPm5vdCBvazwvc3Bhbj5cXG4gICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuXFxcIiBzLWlmPVxcXCJwLnN0YXRlXFxcIiBvbi1jbGljaz1cXFwiZGVsZXRlUGVyc29uKGluZGV4KVxcXCI+ZGVsZXRlPC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0blxcXCIgcy1pZj1cXFwiIXAuc3RhdGVcXFwiIG9uLWNsaWNrPVxcXCJjaGVja1BlcnNvbihpbmRleClcXFwiPmNoZWNrPC9idXR0b24+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgICBcXG4gICAgPC90YWJsZT5cXG48L2Rpdj5cXG5cIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/_html-loader@0.5.5@html-loader/index.js?minimize=false!./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=template&index=0!./src/App.san\n");

/***/ }),

/***/ "./node_modules/_process@0.11.10@process/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/_process@0.11.10@process/browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb2Nlc3NAMC4xMS4xMEBwcm9jZXNzL2Jyb3dzZXIuanM/NGMzOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL19wcm9jZXNzQDAuMTEuMTBAcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_process@0.11.10@process/browser.js\n");

/***/ }),

/***/ "./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=script&index=0!./src/App.san":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=script&index=0!./src/App.san ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var san__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! san */ \"./node_modules/_san@3.6.1@san/dist/san.js\");\n/* harmony import */ var san__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(san__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_1__);\n// <template>\n//     <div>\n//         <div class=\"form-inline\"> \n//             <input class=\"form-control\"  type=\"text\" value=\"{= person.name =}\" placeholder=\"姓名(string)\">\n//             <input class=\"form-control\" type=\"number\" value=\"{= person.age  =}\" placeholder=\"年龄(number)\" on-input=\"setAge\">\n//             <input class=\"form-control\" value=\"{= person.info =}\" placeholder=\"简介(string)\">\n//         </div>\n//\n//         <div>\n//             信息: <button class=\"btn btn-default\" on-click=\"clearPerson()\">移除信息</button>\n//             <p>姓名:<span class=\"text\">{{person.name| upper}}</span></p>\n//             <p>年龄: <span class=\"text\">{{person.age | upper}}</span></p>\n//             <p>简介: <span class=\"text\">{{person.info| upper}}</span> </p>\n//         </div>\n//\n//         <button class=\"btn btn-primary\" on-click=\"addPerson()\"> Add </button>\n//\n//         <table class=\"table\">\n//             <tr >\n//                 <th>Name</th>\n//                 <th>State</th>\n//                 <th>Operation</th>\n//             </tr>\n//             <tr s-for = \"p, index in persons\">\n//                 <td>{{p.name}}</td>\n//                 <td>\n//                     <span s-if=\"p.state === 0\">to be check</span>\n//                     <span s-if=\"p.state === 1\">ok</span>\n//                     <span s-if=\"p.state === 2\">not ok</span>\n//                 </td>\n//                 <td>\n//                     <button class=\"btn\" s-if=\"p.state\" on-click=\"deletePerson(index)\">delete</button>\n//                     <button class=\"btn\" s-if=\"!p.state\" on-click=\"checkPerson(index)\">check</button>\n//                 </td>\n//             </tr>\n//\n//         </table>\n//     </div>\n// </template>\n// <script>\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    initData(){\n        return{\n            person:{\n                name: undefined,\n                age: undefined,\n                info: undefined\n            },\n            persons:[\n                {\n                    name: 'cx',\n                    state: 0\n                },\n                {\n                    name: 'zhangsan',\n                    state: 1\n                },\n                {\n                    name: 'xiaobai',\n                    state: 2\n                }\n            ]\n        };\n    },\n    dataTypes:{\n        person: san__WEBPACK_IMPORTED_MODULE_0__[\"DataTypes\"].shape({\n            name: san__WEBPACK_IMPORTED_MODULE_0__[\"DataTypes\"].string,\n            age: san__WEBPACK_IMPORTED_MODULE_0__[\"DataTypes\"].number,\n            info: san__WEBPACK_IMPORTED_MODULE_0__[\"DataTypes\"].string\n        })\n    },\n    clearPerson(){\n        this.data.set('person', undefined);\n    },\n    setAge: function(){\n        this.data.set(\"person.age\", isNaN(parseInt(this.data.get('person.age')))? undefined : parseInt(this.data.get('person.age')));\n    },\n    addPerson: function(){\n        this.data.push('persons',\n            {\n                name: 'xx',\n                state: 0\n            }\n        )\n    },\n    checkPerson:function(index){\n        this.data.set('persons['+ index +']',{\n            name: this.data.raw.persons[index].name,\n            state:1\n        });\n        // console.log('persons[index]' + this.data.persons[index]);\n    },\n    deletePerson:function(index){\n        this.data.removeAt('persons', index);\n    }\n});\n// </script>\n/* generated by san-loader */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQXBwLnNhbj9lYzUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdDQTtBQUNBOzsrREFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL19zYW4tbG9hZGVyQDAuMC43QHNhbi1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9zcmMvQXBwLnNhbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0taW5saW5lXCI+IFxyXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiAgdHlwZT1cInRleHRcIiB2YWx1ZT1cIns9IHBlcnNvbi5uYW1lID19XCIgcGxhY2Vob2xkZXI9XCLlp5PlkI0oc3RyaW5nKVwiPlxyXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB0eXBlPVwibnVtYmVyXCIgdmFsdWU9XCJ7PSBwZXJzb24uYWdlICA9fVwiIHBsYWNlaG9sZGVyPVwi5bm06b6EKG51bWJlcilcIiBvbi1pbnB1dD1cInNldEFnZVwiPlxyXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB2YWx1ZT1cIns9IHBlcnNvbi5pbmZvID19XCIgcGxhY2Vob2xkZXI9XCLnroDku4soc3RyaW5nKVwiPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgXHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAg5L+h5oGvOiA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgb24tY2xpY2s9XCJjbGVhclBlcnNvbigpXCI+56e76Zmk5L+h5oGvPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxwPuWnk+WQjTo8c3BhbiBjbGFzcz1cInRleHRcIj57e3BlcnNvbi5uYW1lfCB1cHBlcn19PC9zcGFuPjwvcD5cclxuICAgICAgICAgICAgPHA+5bm06b6EOiA8c3BhbiBjbGFzcz1cInRleHRcIj57e3BlcnNvbi5hZ2UgfCB1cHBlcn19PC9zcGFuPjwvcD5cclxuICAgICAgICAgICAgPHA+566A5LuLOiA8c3BhbiBjbGFzcz1cInRleHRcIj57e3BlcnNvbi5pbmZvfCB1cHBlcn19PC9zcGFuPiA8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBvbi1jbGljaz1cImFkZFBlcnNvbigpXCI+IEFkZCA8L2J1dHRvbj5cclxuXHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGVcIj5cclxuICAgICAgICAgICAgPHRyID5cclxuICAgICAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cclxuICAgICAgICAgICAgICAgIDx0aD5TdGF0ZTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGg+T3BlcmF0aW9uPC90aD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgPHRyIHMtZm9yID0gXCJwLCBpbmRleCBpbiBwZXJzb25zXCI+XHJcbiAgICAgICAgICAgICAgICA8dGQ+e3twLm5hbWV9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8dGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gcy1pZj1cInAuc3RhdGUgPT09IDBcIj50byBiZSBjaGVjazwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBzLWlmPVwicC5zdGF0ZSA9PT0gMVwiPm9rPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIHMtaWY9XCJwLnN0YXRlID09PSAyXCI+bm90IG9rPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgIDx0ZD5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuXCIgcy1pZj1cInAuc3RhdGVcIiBvbi1jbGljaz1cImRlbGV0ZVBlcnNvbihpbmRleClcIj5kZWxldGU8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuXCIgcy1pZj1cIiFwLnN0YXRlXCIgb24tY2xpY2s9XCJjaGVja1BlcnNvbihpbmRleClcIj5jaGVjazwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG4gICAgaW1wb3J0IHNhbiwgeyBEYXRhVHlwZXMgfSBmcm9tICdzYW4nO1xyXG4gICAgaW1wb3J0ICcuL3N0eWxlLmNzcyc7XHJcblxyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIGluaXREYXRhKCl7XHJcbiAgICAgICAgICAgIHJldHVybntcclxuICAgICAgICAgICAgICAgIHBlcnNvbjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFnZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBlcnNvbnM6W1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2N4JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IDBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3poYW5nc2FuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IDFcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hpYW9iYWknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogMlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRhdGFUeXBlczp7XHJcbiAgICAgICAgICAgIHBlcnNvbjogRGF0YVR5cGVzLnNoYXBlKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IERhdGFUeXBlcy5zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhZ2U6IERhdGFUeXBlcy5udW1iZXIsXHJcbiAgICAgICAgICAgICAgICBpbmZvOiBEYXRhVHlwZXMuc3RyaW5nXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhclBlcnNvbigpe1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0KCdwZXJzb24nLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0QWdlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0KFwicGVyc29uLmFnZVwiLCBpc05hTihwYXJzZUludCh0aGlzLmRhdGEuZ2V0KCdwZXJzb24uYWdlJykpKT8gdW5kZWZpbmVkIDogcGFyc2VJbnQodGhpcy5kYXRhLmdldCgncGVyc29uLmFnZScpKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQZXJzb246IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKCdwZXJzb25zJyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiAwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoZWNrUGVyc29uOmZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNldCgncGVyc29uc1snKyBpbmRleCArJ10nLHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuZGF0YS5yYXcucGVyc29uc1tpbmRleF0ubmFtZSxcclxuICAgICAgICAgICAgICAgIHN0YXRlOjFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwZXJzb25zW2luZGV4XScgKyB0aGlzLmRhdGEucGVyc29uc1tpbmRleF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlUGVyc29uOmZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnJlbW92ZUF0KCdwZXJzb25zJywgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuPC9zY3JpcHQ+Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=script&index=0!./src/App.san\n");

/***/ }),

/***/ "./node_modules/_san-router@1.2.0@san-router/dist/san-router.source.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/_san-router@1.2.0@san-router/dist/san-router.source.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\nexports['default'] = resolveURL;\n\nvar _parseUrl = __webpack_require__(1);\n\nvar _parseUrl2 = _interopRequireDefault(_parseUrl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * 将 URL 中相对路径部分展开\n *\n * @param {string} source 要展开的url\n * @param {string} base 当前所属环境的url\n * @return {string}\n */\nfunction resolveURL(source, base) {\n    var sourceLoc = (0, _parseUrl2['default'])(source);\n    var baseLoc = (0, _parseUrl2['default'])(base);\n\n    var sourcePath = sourceLoc.path;\n    if (sourcePath.indexOf('/') === 0) {\n        return source;\n    }\n\n    var sourceSegs = sourcePath.split('/');\n    var baseSegs = baseLoc.path.split('/');\n    baseSegs.pop();\n\n    for (var i = 0; i < sourceSegs.length; i++) {\n        var seg = sourceSegs[i];\n        switch (seg) {\n            case '..':\n                baseSegs.pop();\n                break;\n            case '.':\n                break;\n            default:\n                baseSegs.push(seg);\n        }\n    }\n\n    if (baseSegs[0] !== '') {\n        baseSegs.unshift('');\n    }\n\n    return baseSegs.join('/') + (sourceLoc.queryString ? '?' + sourceLoc.queryString : '');\n} /**\n   * san-router\n   * Copyright 2017 Baidu Inc. All rights reserved.\n   *\n   * @file 将 URL 中相对路径部分展开\n   * @author errorrik\n   */\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\nexports['default'] = parseURL;\n/**\n * san-router\n * Copyright 2017 Baidu Inc. All rights reserved.\n *\n * @file 解析URL\n * @author errorrik\n */\n\n/**\n * 解析URL，返回包含path、query、queryString的对象\n *\n * @param {string} url 要解析的url\n * @return {Object}\n */\nfunction parseURL(url) {\n    var result = {\n        hash: '',\n        queryString: '',\n        params: {},\n        query: {},\n        path: url\n    };\n\n    // parse hash\n    var hashStart = result.path.indexOf('#');\n    if (hashStart >= 0) {\n        result.hash = result.path.slice(hashStart + 1);\n        result.path = result.path.slice(0, hashStart);\n    }\n\n    // parse query\n    var query = result.query;\n    var queryStart = result.path.indexOf('?');\n    if (queryStart >= 0) {\n        result.queryString = result.path.slice(queryStart + 1);\n        result.path = result.path.slice(0, queryStart);\n\n        result.queryString.split('&').forEach(function (querySeg) {\n            // 考虑到有可能因为未处理转义问题，\n            // 导致value中存在**=**字符，因此不使用`split`函数\n            var equalIndex = querySeg.indexOf('=');\n            var value = '';\n            if (equalIndex > 0) {\n                value = querySeg.slice(equalIndex + 1);\n                querySeg = querySeg.slice(0, equalIndex);\n            }\n\n            var key = decodeURIComponent(querySeg);\n            value = decodeURIComponent(value);\n\n            // 已经存在这个参数，且新的值不为空时，把原来的值变成数组\n            if (query.hasOwnProperty(key)) {\n                /* eslint-disable */\n                query[key] = [].concat(query[key], value);\n                /* eslint-disable */\n            } else {\n                query[key] = value;\n            }\n        });\n    }\n\n    return result;\n}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * san-router\n * Copyright 2017 Baidu Inc. All rights reserved.\n *\n * @file 提供事件相关操作的基类\n * @author otakustay, errorrik\n */\n\nvar EventTarget = function () {\n    function EventTarget() {\n        _classCallCheck(this, EventTarget);\n    }\n\n    /**\n     * 注册一个事件处理函数\n     *\n     * @param {string} type 事件的类型\n     * @param {Function | boolean} fn 事件的处理函数\n     */\n    EventTarget.prototype.on = function on(type, fn) {\n        if (typeof fn !== 'function') {\n            return;\n        }\n\n        if (!this._eventListeners) {\n            this._eventListeners = {};\n        }\n\n        if (!this._eventListeners[type]) {\n            this._eventListeners[type] = [];\n        }\n\n        this._eventListeners[type].push(fn);\n    };\n\n    /**\n     * 注销一个事件处理函数\n     *\n     * @param {string} type 事件的类型，如果值为`*`仅会注销通过`*`为类型注册的事件，并不会将所有事件注销\n     * @param {Function} [fn] 事件的处理函数，无此参数则注销`type`指定类型的所有事件处理函数\n     */\n\n\n    EventTarget.prototype.un = function un(type, fn) {\n        if (!this._eventListeners || !this._eventListeners[type]) {\n            return;\n        }\n\n        if (!fn) {\n            this._eventListeners[type] = [];\n        } else {\n            var listeners = this._eventListeners[type];\n            var len = listeners.length;\n\n            while (len--) {\n                if (listeners[len] === fn) {\n                    listeners.splice(len, 1);\n                }\n            }\n        }\n    };\n\n    /**\n     * 触发指定类型的事件\n     *\n     * @param {string} type 事件类型\n     * @param {*} [args] 事件对象\n     */\n\n\n    EventTarget.prototype.fire = function fire(type, args) {\n        if (!type) {\n            throw new Error('No event type specified');\n        }\n\n        var listeners = this._eventListeners && this._eventListeners[type];\n        if (listeners) {\n            for (var i = 0; i < listeners.length; i++) {\n                listeners[i](args);\n            }\n        }\n    };\n\n    return EventTarget;\n}();\n\nexports['default'] = EventTarget;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _main = __webpack_require__(6);\n\nvar _resolveUrl = __webpack_require__(0);\n\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * san-router\n * Copyright 2017 Baidu Inc. All rights reserved.\n *\n * @file 路由链接的 San 组件\n * @author errorrik\n */\n\nexports['default'] = {\n    template: '<a href=\"{{href}}\"\\n        onclick=\"return false;\"\\n        on-click=\"clicker($event)\"\\n        target=\"{{target}}\"\\n        class=\"{{class}}\"\\n        style=\"{{style}}\"\\n        >\\n        <slot></slot>\\n    </a>',\n\n    clicker: function clicker(e) {\n        var href = this.data.get('href');\n\n        if (typeof href === 'string') {\n            _main.router.locator.redirect(href.replace(/^#/, ''));\n        }\n\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n        }\n    },\n\n\n    computed: {\n        href: function href() {\n            var url = this.data.get('to');\n            if (typeof url !== 'string') {\n                return;\n            }\n\n            var href = (0, _resolveUrl2['default'])(url, _main.router.locator.current);\n            if (_main.router.mode === 'hash') {\n                href = '#' + href;\n            }\n\n            return href;\n        }\n    }\n};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _eventTarget = __webpack_require__(2);\n\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\n\nvar _resolveUrl = __webpack_require__(0);\n\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * san-router\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2017 Baidu Inc. All rights reserved.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file hash 模式地址监听器\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author errorrik\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n/**\n * 获取当前URL\n *\n * @return {string}\n */\nfunction getLocation() {\n    // Firefox下`location.hash`存在自动解码的情况，\n    // 比如hash的值是**abc%3def**，\n    // 在Firefox下获取会成为**abc=def**\n    // 为了避免这一情况，需要从`location.href`中分解\n    var index = location.href.indexOf('#');\n    var url = index < 0 ? '/' : location.href.slice(index + 1) || '/';\n\n    return url;\n}\n\n/**\n * hash 模式地址监听器\n *\n * @class\n */\n\nvar Locator = function (_EventTarget) {\n    _inherits(Locator, _EventTarget);\n\n    /**\n     * 构造函数\n     */\n    function Locator() {\n        _classCallCheck(this, Locator);\n\n        var _this = _possibleConstructorReturn(this, _EventTarget.call(this));\n\n        _this.current = getLocation();\n        _this.referrer = '';\n\n        _this.hashChangeHandler = function () {\n            _this.redirect(getLocation());\n        };\n        return _this;\n    }\n\n    /**\n     * 开始监听 url 变化\n     */\n\n\n    Locator.prototype.start = function start() {\n        if (window.addEventListener) {\n            window.addEventListener('hashchange', this.hashChangeHandler, false);\n        }\n\n        if (window.attachEvent) {\n            window.attachEvent('onhashchange', this.hashChangeHandler);\n        }\n    };\n\n    /**\n     * 停止监听\n     */\n\n\n    Locator.prototype.stop = function stop() {\n        if (window.removeEventListener) {\n            window.removeEventListener('hashchange', this.hashChangeHandler, false);\n        }\n\n        if (window.detachEvent) {\n            window.detachEvent('onhashchange', this.hashChangeHandler);\n        }\n    };\n\n    /**\n     * 重定向\n     *\n     * @param {string} url 重定向的地址\n     * @param {Object?} options 重定向的行为配置\n     * @param {boolean?} options.force 是否强制刷新\n     */\n\n\n    Locator.prototype.redirect = function redirect(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { force: false };\n\n        url = (0, _resolveUrl2['default'])(url, this.current);\n        var referrer = this.current;\n\n        var isChanged = url !== referrer;\n        if (isChanged) {\n            this.referrer = referrer;\n            this.current = url;\n            location.hash = url;\n        } else {\n            referrer = this.referrer;\n        }\n\n        if ((isChanged || options.force) && !options.silent) {\n            this.fire('redirect', { url: url, referrer: referrer });\n        }\n    };\n\n    /**\n     * 刷新当前 url\n     */\n\n\n    Locator.prototype.reload = function reload() {\n        this.redirect(this.current, { force: true });\n    };\n\n    return Locator;\n}(_eventTarget2['default']);\n\nexports['default'] = Locator;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _eventTarget = __webpack_require__(2);\n\nvar _eventTarget2 = _interopRequireDefault(_eventTarget);\n\nvar _resolveUrl = __webpack_require__(0);\n\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * san-router\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2017 Baidu Inc. All rights reserved.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file html5 模式地址监听器\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author errorrik\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n/**\n * 获取当前URL\n *\n * @return {string}\n */\nfunction getLocation() {\n    return location.pathname + location.search;\n}\n\n/**\n * html5 模式地址监听器\n *\n * @class\n */\n\nvar Locator = function (_EventTarget) {\n    _inherits(Locator, _EventTarget);\n\n    /**\n     * 构造函数\n     */\n    function Locator() {\n        _classCallCheck(this, Locator);\n\n        var _this = _possibleConstructorReturn(this, _EventTarget.call(this));\n\n        _this.current = getLocation();\n        _this.referrer = '';\n\n        _this.popstateHandler = function () {\n            _this.referrer = _this.current;\n            _this.current = getLocation();\n\n            _this.fire('redirect', {\n                url: _this.current,\n                referrer: _this.referrer\n            });\n        };\n        return _this;\n    }\n\n    /**\n     * 开始监听 url 变化\n     */\n\n\n    Locator.prototype.start = function start() {\n        window.addEventListener('popstate', this.popstateHandler);\n    };\n\n    /**\n     * 停止监听\n     */\n\n\n    Locator.prototype.stop = function stop() {\n        window.removeEventListener('popstate', this.popstateHandler);\n    };\n\n    /**\n     * 重定向\n     *\n     * @param {string} url 重定向的地址\n     * @param {Object?} options 重定向的行为配置\n     * @param {boolean?} options.force 是否强制刷新\n     */\n\n\n    Locator.prototype.redirect = function redirect(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { force: false };\n\n        url = (0, _resolveUrl2['default'])(url, this.current);\n        var referrer = this.current;\n\n        var isChanged = url !== referrer;\n\n        if (isChanged) {\n            this.referrer = referrer;\n            this.current = url;\n\n            history.pushState({}, '', url);\n        }\n\n        if ((isChanged || options.force) && !options.silent) {\n            this.fire('redirect', { url: url, referrer: referrer });\n        }\n    };\n\n    /**\n     * 刷新当前 url\n     */\n\n\n    Locator.prototype.reload = function reload() {\n        this.fire('redirect', {\n            url: this.current,\n            referrer: this.referrer\n        });\n    };\n\n    return Locator;\n}(_eventTarget2['default']);\n\nexports['default'] = Locator;\n\n\nLocator.isSupport = 'pushState' in window.history;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\nexports.Link = exports.router = exports.Router = exports.version = undefined;\n\nvar _hash = __webpack_require__(4);\n\nvar _hash2 = _interopRequireDefault(_hash);\n\nvar _html = __webpack_require__(5);\n\nvar _html2 = _interopRequireDefault(_html);\n\nvar _parseUrl = __webpack_require__(1);\n\nvar _parseUrl2 = _interopRequireDefault(_parseUrl);\n\nvar _link = __webpack_require__(3);\n\nvar _link2 = _interopRequireDefault(_link);\n\nvar _elementSelector = __webpack_require__(7);\n\nvar _elementSelector2 = _interopRequireDefault(_elementSelector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * san-router\n                                                                                                                                                           * Copyright 2017 Baidu Inc. All rights reserved.\n                                                                                                                                                           *\n                                                                                                                                                           * @file 主模块\n                                                                                                                                                           * @author errorrik\n                                                                                                                                                           */\n\nvar routeID = 0x5942b;\nvar guid = function guid() {\n    return (++routeID).toString();\n};\n\nfunction isComponent(C) {\n    return C.prototype && (C.prototype.nodeType === 5 || C.prototype._type === 'san-cmpt');\n}\n\n/**\n * 版本号\n *\n * @type {string}\n */\nvar version = exports.version = '1.2.0';\n\n/**\n * 路由器类\n *\n * @class\n */\n\nvar Router = exports.Router = function () {\n\n    /**\n     * 构造函数\n     *\n     * @param {Object?} options 初始化参数\n     * @param {string?} options.mode 路由模式，hash | html5\n     */\n    function Router() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$mode = _ref.mode,\n            mode = _ref$mode === undefined ? 'hash' : _ref$mode;\n\n        _classCallCheck(this, Router);\n\n        this.routes = [];\n        this.routeAlives = [];\n        this.listeners = [];\n\n        /**\n         * locator redirect 事件监听函数\n         *\n         * @param {Object} e locator事件对象\n         */\n        this.locatorRedirectHandler = function (e) {\n            var url = (0, _parseUrl2['default'])(e.url);\n            var routeItem = void 0;\n\n            for (var _i = 0; _i < _this.routes.length; _i++) {\n                var item = _this.routes[_i];\n                var match = item.rule.exec(url.path);\n\n                if (match) {\n                    routeItem = item;\n\n                    // fill params\n                    var keys = item.keys || [];\n                    for (var j = 1; j < match.length; j++) {\n                        var key = keys[j] || j;\n                        var value = match[j];\n                        url.query[key] = value;\n                        url.params[key] = value;\n                    }\n\n                    // fill referrer\n                    url.referrer = e.referrer;\n                    url.config = item.config;\n\n                    break;\n                }\n            }\n\n            var i = 0;\n            var state = 1;\n\n            /**\n             * listener 事件对象\n             *\n             * @type {Object}\n             */\n            var listenerEvent = {\n                hash: url.hash,\n                queryString: url.queryString,\n                query: url.query,\n                path: url.path,\n                referrer: url.referrer,\n                config: url.config,\n                resume: next,\n                suspend: function suspend() {\n                    state = 0;\n                },\n                stop: function stop() {\n                    state = -1;\n                }\n            };\n\n            /**\n             * 尝试运行下一个listener\n             *\n             * @inner\n             */\n            var doNext = function doNext() {\n                if (state > 0) {\n                    if (i < _this.listeners.length) {\n                        _this.listeners[i].call(_this, listenerEvent, url.config);\n                        if (state > 0) {\n                            next();\n                        }\n                    } else {\n                        routeAction();\n                    }\n                }\n            };\n\n            /**\n             * 运行下一个listener\n             *\n             * @inner\n             */\n            function next() {\n                state = 1;\n                i++;\n                doNext();\n            }\n\n            /**\n             * 运行路由行为\n             *\n             * @inner\n             */\n            var routeAction = function routeAction() {\n                if (routeItem) {\n                    _this.doRoute(routeItem, url);\n                } else {\n                    var len = _this.routeAlives.length;\n                    while (len--) {\n                        _this.routeAlives[len].component.dispose();\n                        _this.routeAlives.splice(len, 1);\n                    }\n                }\n            };\n\n            doNext();\n        };\n\n        this.setMode(mode);\n    }\n\n    /**\n     * 添加路由监听器\n     *\n     * @param {function(e, config)} listener 监听器\n     */\n\n\n    Router.prototype.listen = function listen(listener) {\n        this.listeners.push(listener);\n    };\n\n    /**\n     * 移除路由监听器\n     *\n     * @param {Function} listener 监听器\n     */\n\n\n    Router.prototype.unlisten = function unlisten(listener) {\n        var len = this.listeners.length;\n        while (len--) {\n            if (this.listeners[len] === listener) {\n                this.listeners.splice(len, 1);\n            }\n        }\n    };\n\n    /**\n     * 执行路由\n     *\n     * @private\n     * @param {Object} routeItem 路由项\n     * @param {Object} e 路由信息\n     */\n\n\n    Router.prototype.doRoute = function doRoute(routeItem, e) {\n        var _this2 = this;\n\n        var isUpdateAlive = false;\n        var len = this.routeAlives.length;\n\n        while (len--) {\n            var routeAlive = this.routeAlives[len];\n\n            if (routeAlive.id === routeItem.id) {\n                routeAlive.component.data.set('route', e);\n                routeAlive.component._callHook('route');\n                isUpdateAlive = true;\n            } else {\n                routeAlive.component.dispose();\n                this.routeAlives.splice(len, 1);\n            }\n        }\n\n        if (!isUpdateAlive) {\n            if (routeItem.Component) {\n                if (isComponent(routeItem.Component)) {\n                    this.attachCmpt(routeItem, e);\n                } else {\n                    routeItem.Component().then(function (Cmpt) {\n                        // eslint-disable-line\n                        if (isComponent(Cmpt)) {\n                            routeItem.Component = Cmpt;\n                        } else if (Cmpt.__esModule && isComponent(Cmpt['default'])) {\n                            routeItem.Component = Cmpt['default'];\n                        }\n                        _this2.attachCmpt(routeItem, e);\n                    });\n                }\n            } else {\n                routeItem.handler.call(this, e);\n            }\n        }\n    };\n\n    Router.prototype.attachCmpt = function attachCmpt(routeItem, e) {\n        var component = new routeItem.Component();\n        component.data.set('route', e);\n        component._callHook('route');\n\n        var target = routeItem.target;\n        var targetEl = (0, _elementSelector2['default'])(target);\n\n        if (!targetEl) {\n            throw new Error('[SAN-ROUTER ERROR] ' + 'Attach failed, target element \"' + routeItem.target + '\" is not found.');\n        }\n\n        component.attach(targetEl);\n\n        this.routeAlives.push({\n            component: component,\n            id: routeItem.id\n        });\n    };\n\n    /**\n     * 添加路由项\n     * 当规则匹配时，路由将优先将Component渲染到target中。如果没有包含Component，则执行handler函数\n     *\n     * @private\n     * @param {Object} config 路由项配置\n     * @param {string|RegExp} config.rule 路由规则\n     * @param {Function?} config.handler 路由函数\n     * @param {Function?} config.Component 路由组件\n     * @param {string} config.target 路由组件要渲染到的目标位置\n     * @return {Object} san-router 实例\n     */\n\n\n    Router.prototype.add = function add(config) {\n        var rule = config.rule,\n            handler = config.handler,\n            _config$target = config.target,\n            target = _config$target === undefined ? '#main' : _config$target,\n            Component = config.Component;\n\n        var keys = [''];\n\n        if (typeof rule === 'string') {\n            // 没用path-to-regexp，暂时不提供这么多功能支持\n            var regText = rule.replace(/\\/:([a-z0-9_-]+)(?=\\/|$)/ig, function (match, key) {\n                keys.push(key);\n                return '/([^/\\\\s]+)';\n            });\n\n            rule = new RegExp('^' + regText + '$', 'i');\n        }\n\n        if (!(rule instanceof RegExp)) {\n            throw new Error('[SAN-ROUTER ERROR] Rule must be string or RegExp!');\n        }\n\n        var id = guid();\n        this.routes.push({ id: id, rule: rule, handler: handler, keys: keys, target: target, Component: Component, config: config });\n\n        return this;\n    };\n\n    /**\n     * 启动路由功能\n     *\n     * @return {Object} san-router 实例\n     */\n\n\n    Router.prototype.start = function start() {\n        if (!this.isStarted) {\n            this.isStarted = true;\n            this.locator.on('redirect', this.locatorRedirectHandler);\n            this.locator.start();\n            this.locator.reload();\n        }\n\n        return this;\n    };\n\n    /**\n     * 停止路由功能\n     *\n     * @return {Object} san-router 实例\n     */\n\n\n    Router.prototype.stop = function stop() {\n        this.locator.un('redirect', this.locatorRedirectHandler);\n        this.locator.stop();\n        this.isStarted = false;\n\n        return this;\n    };\n\n    /**\n     * 设置路由模式\n     *\n     * @param {string} mode 路由模式，hash | html5\n     * @return {Object} san-router 实例\n     */\n\n\n    Router.prototype.setMode = function setMode(mode) {\n        mode = mode.toLowerCase();\n        if (this.mode === mode) {\n            return;\n        }\n\n        this.mode = mode;\n\n        var restart = false;\n        if (this.isStarted) {\n            this.stop();\n            restart = true;\n        }\n\n        switch (mode) {\n            case 'hash':\n                this.locator = new _hash2['default']();\n                break;\n            case 'html5':\n                this.locator = new _html2['default']();\n        }\n\n        if (restart) {\n            this.start();\n        }\n\n        return this;\n    };\n\n    return Router;\n}();\n\n/**\n * 默认的路由器实例\n *\n * @type {Router}\n */\n\n\nvar router = exports.router = new Router();\n\n/**\n * 路由链接的 San 组件\n *\n * @class\n */\nexports.Link = _link2['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports['default'] = elementSelector;\n/*\n*\n* @file 选择器\n* @author vincent lau/413893093@qq.com\n*/\n\n/**\n * 元素选择器\n *\n * @param {string|Element} selector 选择器\n * @returns {Element}\n */\nfunction elementSelector(selector) {\n    switch (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) {\n        case 'object':\n            return selector;\n\n        case 'string':\n            if (document.querySelector) {\n                return document.querySelector(selector);\n            }\n\n            return document.getElementById(selector.replace(/#/i, ''));\n    }\n}\n\n/***/ }\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Nhbi1yb3V0ZXJAMS4yLjBAc2FuLXJvdXRlci9kaXN0L3Nhbi1yb3V0ZXIuc291cmNlLmpzPzk3YjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELGNBQWM7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCwrREFBK0Q7O0FBRTdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9fc2FuLXJvdXRlckAxLjIuMEBzYW4tcm91dGVyL2Rpc3Qvc2FuLXJvdXRlci5zb3VyY2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInNhbi1yb3V0ZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wic2FuLXJvdXRlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJzYW4tcm91dGVyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG5cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcblxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3RcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc29sdmVVUkw7XG5cbnZhciBfcGFyc2VVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3BhcnNlVXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlVXJsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIOWwhiBVUkwg5Lit55u45a+56Lev5b6E6YOo5YiG5bGV5byAXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSDopoHlsZXlvIDnmoR1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIOW9k+WJjeaJgOWxnueOr+Wig+eahHVybFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXNvbHZlVVJMKHNvdXJjZSwgYmFzZSkge1xuICAgIHZhciBzb3VyY2VMb2MgPSAoMCwgX3BhcnNlVXJsMlsnZGVmYXVsdCddKShzb3VyY2UpO1xuICAgIHZhciBiYXNlTG9jID0gKDAsIF9wYXJzZVVybDJbJ2RlZmF1bHQnXSkoYmFzZSk7XG5cbiAgICB2YXIgc291cmNlUGF0aCA9IHNvdXJjZUxvYy5wYXRoO1xuICAgIGlmIChzb3VyY2VQYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VTZWdzID0gc291cmNlUGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciBiYXNlU2VncyA9IGJhc2VMb2MucGF0aC5zcGxpdCgnLycpO1xuICAgIGJhc2VTZWdzLnBvcCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VTZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSBzb3VyY2VTZWdzW2ldO1xuICAgICAgICBzd2l0Y2ggKHNlZykge1xuICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgIGJhc2VTZWdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJhc2VTZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYXNlU2Vnc1swXSAhPT0gJycpIHtcbiAgICAgICAgYmFzZVNlZ3MudW5zaGlmdCgnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VTZWdzLmpvaW4oJy8nKSArIChzb3VyY2VMb2MucXVlcnlTdHJpbmcgPyAnPycgKyBzb3VyY2VMb2MucXVlcnlTdHJpbmcgOiAnJyk7XG59IC8qKlxuICAgKiBzYW4tcm91dGVyXG4gICAqIENvcHlyaWdodCAyMDE3IEJhaWR1IEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICpcbiAgICogQGZpbGUg5bCGIFVSTCDkuK3nm7jlr7not6/lvoTpg6jliIblsZXlvIBcbiAgICogQGF1dGhvciBlcnJvcnJpa1xuICAgKi9cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcGFyc2VVUkw7XG4vKipcbiAqIHNhbi1yb3V0ZXJcbiAqIENvcHlyaWdodCAyMDE3IEJhaWR1IEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBAZmlsZSDop6PmnpBVUkxcbiAqIEBhdXRob3IgZXJyb3JyaWtcbiAqL1xuXG4vKipcbiAqIOino+aekFVSTO+8jOi/lOWbnuWMheWQq3BhdGjjgIFxdWVyeeOAgXF1ZXJ5U3RyaW5n55qE5a+56LGhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCDopoHop6PmnpDnmoR1cmxcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VVUkwodXJsKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgaGFzaDogJycsXG4gICAgICAgIHF1ZXJ5U3RyaW5nOiAnJyxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcXVlcnk6IHt9LFxuICAgICAgICBwYXRoOiB1cmxcbiAgICB9O1xuXG4gICAgLy8gcGFyc2UgaGFzaFxuICAgIHZhciBoYXNoU3RhcnQgPSByZXN1bHQucGF0aC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2hTdGFydCA+PSAwKSB7XG4gICAgICAgIHJlc3VsdC5oYXNoID0gcmVzdWx0LnBhdGguc2xpY2UoaGFzaFN0YXJ0ICsgMSk7XG4gICAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGguc2xpY2UoMCwgaGFzaFN0YXJ0KTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBxdWVyeVxuICAgIHZhciBxdWVyeSA9IHJlc3VsdC5xdWVyeTtcbiAgICB2YXIgcXVlcnlTdGFydCA9IHJlc3VsdC5wYXRoLmluZGV4T2YoJz8nKTtcbiAgICBpZiAocXVlcnlTdGFydCA+PSAwKSB7XG4gICAgICAgIHJlc3VsdC5xdWVyeVN0cmluZyA9IHJlc3VsdC5wYXRoLnNsaWNlKHF1ZXJ5U3RhcnQgKyAxKTtcbiAgICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aC5zbGljZSgwLCBxdWVyeVN0YXJ0KTtcblxuICAgICAgICByZXN1bHQucXVlcnlTdHJpbmcuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeVNlZykge1xuICAgICAgICAgICAgLy8g6ICD6JmR5Yiw5pyJ5Y+v6IO95Zug5Li65pyq5aSE55CG6L2s5LmJ6Zeu6aKY77yMXG4gICAgICAgICAgICAvLyDlr7zoh7R2YWx1ZeS4reWtmOWcqCoqPSoq5a2X56ym77yM5Zug5q2k5LiN5L2/55SoYHNwbGl0YOWHveaVsFxuICAgICAgICAgICAgdmFyIGVxdWFsSW5kZXggPSBxdWVyeVNlZy5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmIChlcXVhbEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcXVlcnlTZWcuc2xpY2UoZXF1YWxJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5U2VnID0gcXVlcnlTZWcuc2xpY2UoMCwgZXF1YWxJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQocXVlcnlTZWcpO1xuICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXG4gICAgICAgICAgICAvLyDlt7Lnu4/lrZjlnKjov5nkuKrlj4LmlbDvvIzkuJTmlrDnmoTlgLzkuI3kuLrnqbrml7bvvIzmiorljp/mnaXnmoTlgLzlj5jmiJDmlbDnu4RcbiAgICAgICAgICAgIGlmIChxdWVyeS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgICAgICAgICBxdWVyeVtrZXldID0gW10uY29uY2F0KHF1ZXJ5W2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBzYW4tcm91dGVyXG4gKiBDb3B5cmlnaHQgMjAxNyBCYWlkdSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQGZpbGUg5o+Q5L6b5LqL5Lu255u45YWz5pON5L2c55qE5Z+657G7XG4gKiBAYXV0aG9yIG90YWt1c3RheSwgZXJyb3JyaWtcbiAqL1xuXG52YXIgRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5rOo5YaM5LiA5Liq5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnmoTnsbvlnotcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgYm9vbGVhbn0gZm4g5LqL5Lu255qE5aSE55CG5Ye95pWwXG4gICAgICovXG4gICAgRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24odHlwZSwgZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRMaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyc1t0eXBlXS5wdXNoKGZuKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5rOo6ZSA5LiA5Liq5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnmoTnsbvlnovvvIzlpoLmnpzlgLzkuLpgKmDku4XkvJrms6jplIDpgJrov4dgKmDkuLrnsbvlnovms6jlhoznmoTkuovku7bvvIzlubbkuI3kvJrlsIbmiYDmnInkuovku7bms6jplIBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIOS6i+S7tueahOWkhOeQhuWHveaVsO+8jOaXoOatpOWPguaVsOWImeazqOmUgGB0eXBlYOaMh+Wumuexu+Wei+eahOaJgOacieS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqL1xuXG5cbiAgICBFdmVudFRhcmdldC5wcm90b3R5cGUudW4gPSBmdW5jdGlvbiB1bih0eXBlLCBmbikge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50TGlzdGVuZXJzIHx8ICF0aGlzLl9ldmVudExpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2xlbl0gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UobGVuLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog6Kem5Y+R5oyH5a6a57G75Z6L55qE5LqL5Lu2XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgKiBAcGFyYW0geyp9IFthcmdzXSDkuovku7blr7nosaFcbiAgICAgKi9cblxuXG4gICAgRXZlbnRUYXJnZXQucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiBmaXJlKHR5cGUsIGFyZ3MpIHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV2ZW50IHR5cGUgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMgJiYgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBFdmVudFRhcmdldDtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRXZlbnRUYXJnZXQ7XG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9yZXNvbHZlVXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9yZXNvbHZlVXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc29sdmVVcmwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogc2FuLXJvdXRlclxuICogQ29weXJpZ2h0IDIwMTcgQmFpZHUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEBmaWxlIOi3r+eUsemTvuaOpeeahCBTYW4g57uE5Lu2XG4gKiBAYXV0aG9yIGVycm9ycmlrXG4gKi9cblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICAgIHRlbXBsYXRlOiAnPGEgaHJlZj1cInt7aHJlZn19XCJcXG4gICAgICAgIG9uY2xpY2s9XCJyZXR1cm4gZmFsc2U7XCJcXG4gICAgICAgIG9uLWNsaWNrPVwiY2xpY2tlcigkZXZlbnQpXCJcXG4gICAgICAgIHRhcmdldD1cInt7dGFyZ2V0fX1cIlxcbiAgICAgICAgY2xhc3M9XCJ7e2NsYXNzfX1cIlxcbiAgICAgICAgc3R5bGU9XCJ7e3N0eWxlfX1cIlxcbiAgICAgICAgPlxcbiAgICAgICAgPHNsb3Q+PC9zbG90PlxcbiAgICA8L2E+JyxcblxuICAgIGNsaWNrZXI6IGZ1bmN0aW9uIGNsaWNrZXIoZSkge1xuICAgICAgICB2YXIgaHJlZiA9IHRoaXMuZGF0YS5nZXQoJ2hyZWYnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBfbWFpbi5yb3V0ZXIubG9jYXRvci5yZWRpcmVjdChocmVmLnJlcGxhY2UoL14jLywgJycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICBjb21wdXRlZDoge1xuICAgICAgICBocmVmOiBmdW5jdGlvbiBocmVmKCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuZGF0YS5nZXQoJ3RvJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBocmVmID0gKDAsIF9yZXNvbHZlVXJsMlsnZGVmYXVsdCddKSh1cmwsIF9tYWluLnJvdXRlci5sb2NhdG9yLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKF9tYWluLnJvdXRlci5tb2RlID09PSAnaGFzaCcpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gJyMnICsgaHJlZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXZlbnRUYXJnZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX2V2ZW50VGFyZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50VGFyZ2V0KTtcblxudmFyIF9yZXNvbHZlVXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9yZXNvbHZlVXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc29sdmVVcmwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzYW4tcm91dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxNyBCYWlkdSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZpbGUgaGFzaCDmqKHlvI/lnLDlnYDnm5HlkKzlmahcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhdXRob3IgZXJyb3JyaWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4vKipcbiAqIOiOt+WPluW9k+WJjVVSTFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYXRpb24oKSB7XG4gICAgLy8gRmlyZWZveOS4i2Bsb2NhdGlvbi5oYXNoYOWtmOWcqOiHquWKqOino+eggeeahOaDheWGte+8jFxuICAgIC8vIOavlOWmgmhhc2jnmoTlgLzmmK8qKmFiYyUzZGVmKirvvIxcbiAgICAvLyDlnKhGaXJlZm945LiL6I635Y+W5Lya5oiQ5Li6KiphYmM9ZGVmKipcbiAgICAvLyDkuLrkuobpgb/lhY3ov5nkuIDmg4XlhrXvvIzpnIDopoHku45gbG9jYXRpb24uaHJlZmDkuK3liIbop6NcbiAgICB2YXIgaW5kZXggPSBsb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcbiAgICB2YXIgdXJsID0gaW5kZXggPCAwID8gJy8nIDogbG9jYXRpb24uaHJlZi5zbGljZShpbmRleCArIDEpIHx8ICcvJztcblxuICAgIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogaGFzaCDmqKHlvI/lnLDlnYDnm5HlkKzlmahcbiAqXG4gKiBAY2xhc3NcbiAqL1xuXG52YXIgTG9jYXRvciA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgICBfaW5oZXJpdHMoTG9jYXRvciwgX0V2ZW50VGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIOaehOmAoOWHveaVsFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2F0b3IoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2NhdG9yKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuY3VycmVudCA9IGdldExvY2F0aW9uKCk7XG4gICAgICAgIF90aGlzLnJlZmVycmVyID0gJyc7XG5cbiAgICAgICAgX3RoaXMuaGFzaENoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWRpcmVjdChnZXRMb2NhdGlvbigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOW8gOWni+ebkeWQrCB1cmwg5Y+Y5YyWXG4gICAgICovXG5cblxuICAgIExvY2F0b3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmhhc2hDaGFuZ2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uaGFzaGNoYW5nZScsIHRoaXMuaGFzaENoYW5nZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWBnOatouebkeWQrFxuICAgICAqL1xuXG5cbiAgICBMb2NhdG9yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuaGFzaENoYW5nZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cuZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudCgnb25oYXNoY2hhbmdlJywgdGhpcy5oYXNoQ2hhbmdlSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog6YeN5a6a5ZCRXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIOmHjeWumuWQkeeahOWcsOWdgFxuICAgICAqIEBwYXJhbSB7T2JqZWN0P30gb3B0aW9ucyDph43lrprlkJHnmoTooYzkuLrphY3nva5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW4/fSBvcHRpb25zLmZvcmNlIOaYr+WQpuW8uuWItuWIt+aWsFxuICAgICAqL1xuXG5cbiAgICBMb2NhdG9yLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KHVybCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyBmb3JjZTogZmFsc2UgfTtcblxuICAgICAgICB1cmwgPSAoMCwgX3Jlc29sdmVVcmwyWydkZWZhdWx0J10pKHVybCwgdGhpcy5jdXJyZW50KTtcbiAgICAgICAgdmFyIHJlZmVycmVyID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICAgIHZhciBpc0NoYW5nZWQgPSB1cmwgIT09IHJlZmVycmVyO1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmVycmVyID0gcmVmZXJyZXI7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB1cmw7XG4gICAgICAgICAgICBsb2NhdGlvbi5oYXNoID0gdXJsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmZXJyZXIgPSB0aGlzLnJlZmVycmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc0NoYW5nZWQgfHwgb3B0aW9ucy5mb3JjZSkgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3JlZGlyZWN0JywgeyB1cmw6IHVybCwgcmVmZXJyZXI6IHJlZmVycmVyIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWIt+aWsOW9k+WJjSB1cmxcbiAgICAgKi9cblxuXG4gICAgTG9jYXRvci5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gcmVsb2FkKCkge1xuICAgICAgICB0aGlzLnJlZGlyZWN0KHRoaXMuY3VycmVudCwgeyBmb3JjZTogdHJ1ZSB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExvY2F0b3I7XG59KF9ldmVudFRhcmdldDJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IExvY2F0b3I7XG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9ldmVudFRhcmdldCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfZXZlbnRUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRUYXJnZXQpO1xuXG52YXIgX3Jlc29sdmVVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3Jlc29sdmVVcmwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVzb2x2ZVVybCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHNhbi1yb3V0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvcHlyaWdodCAyMDE3IEJhaWR1IEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZmlsZSBodG1sNSDmqKHlvI/lnLDlnYDnm5HlkKzlmahcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhdXRob3IgZXJyb3JyaWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4vKipcbiAqIOiOt+WPluW9k+WJjVVSTFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoO1xufVxuXG4vKipcbiAqIGh0bWw1IOaooeW8j+WcsOWdgOebkeWQrOWZqFxuICpcbiAqIEBjbGFzc1xuICovXG5cbnZhciBMb2NhdG9yID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICAgIF9pbmhlcml0cyhMb2NhdG9yLCBfRXZlbnRUYXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICog5p6E6YCg5Ye95pWwXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYXRvcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvY2F0b3IpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5jdXJyZW50ID0gZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgX3RoaXMucmVmZXJyZXIgPSAnJztcblxuICAgICAgICBfdGhpcy5wb3BzdGF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWZlcnJlciA9IF90aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50ID0gZ2V0TG9jYXRpb24oKTtcblxuICAgICAgICAgICAgX3RoaXMuZmlyZSgncmVkaXJlY3QnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiBfdGhpcy5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlZmVycmVyOiBfdGhpcy5yZWZlcnJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlvIDlp4vnm5HlkKwgdXJsIOWPmOWMllxuICAgICAqL1xuXG5cbiAgICBMb2NhdG9yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLnBvcHN0YXRlSGFuZGxlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWBnOatouebkeWQrFxuICAgICAqL1xuXG5cbiAgICBMb2NhdG9yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5wb3BzdGF0ZUhhbmRsZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDph43lrprlkJFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6YeN5a6a5ZCR55qE5Zyw5Z2AXG4gICAgICogQHBhcmFtIHtPYmplY3Q/fSBvcHRpb25zIOmHjeWumuWQkeeahOihjOS4uumFjee9rlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj99IG9wdGlvbnMuZm9yY2Ug5piv5ZCm5by65Yi25Yi35pawXG4gICAgICovXG5cblxuICAgIExvY2F0b3IucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QodXJsKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7IGZvcmNlOiBmYWxzZSB9O1xuXG4gICAgICAgIHVybCA9ICgwLCBfcmVzb2x2ZVVybDJbJ2RlZmF1bHQnXSkodXJsLCB0aGlzLmN1cnJlbnQpO1xuICAgICAgICB2YXIgcmVmZXJyZXIgPSB0aGlzLmN1cnJlbnQ7XG5cbiAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IHVybCAhPT0gcmVmZXJyZXI7XG5cbiAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5yZWZlcnJlciA9IHJlZmVycmVyO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdXJsO1xuXG4gICAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzQ2hhbmdlZCB8fCBvcHRpb25zLmZvcmNlKSAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgncmVkaXJlY3QnLCB7IHVybDogdXJsLCByZWZlcnJlcjogcmVmZXJyZXIgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5Yi35paw5b2T5YmNIHVybFxuICAgICAqL1xuXG5cbiAgICBMb2NhdG9yLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiByZWxvYWQoKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVkaXJlY3QnLCB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuY3VycmVudCxcbiAgICAgICAgICAgIHJlZmVycmVyOiB0aGlzLnJlZmVycmVyXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gTG9jYXRvcjtcbn0oX2V2ZW50VGFyZ2V0MlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTG9jYXRvcjtcblxuXG5Mb2NhdG9yLmlzU3VwcG9ydCA9ICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkxpbmsgPSBleHBvcnRzLnJvdXRlciA9IGV4cG9ydHMuUm91dGVyID0gZXhwb3J0cy52ZXJzaW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX2hhc2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2hhc2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzaCk7XG5cbnZhciBfaHRtbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaHRtbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9odG1sKTtcblxudmFyIF9wYXJzZVVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfcGFyc2VVcmwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2VVcmwpO1xuXG52YXIgX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGluayk7XG5cbnZhciBfZWxlbWVudFNlbGVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF9lbGVtZW50U2VsZWN0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWxlbWVudFNlbGVjdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzYW4tcm91dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTcgQmFpZHUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZpbGUg5Li75qih5Z2XXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGF1dGhvciBlcnJvcnJpa1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgcm91dGVJRCA9IDB4NTk0MmI7XG52YXIgZ3VpZCA9IGZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgcmV0dXJuICgrK3JvdXRlSUQpLnRvU3RyaW5nKCk7XG59O1xuXG5mdW5jdGlvbiBpc0NvbXBvbmVudChDKSB7XG4gICAgcmV0dXJuIEMucHJvdG90eXBlICYmIChDLnByb3RvdHlwZS5ub2RlVHlwZSA9PT0gNSB8fCBDLnByb3RvdHlwZS5fdHlwZSA9PT0gJ3Nhbi1jbXB0Jyk7XG59XG5cbi8qKlxuICog54mI5pys5Y+3XG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHZlcnNpb24gPSBleHBvcnRzLnZlcnNpb24gPSAnMS4yLjAnO1xuXG4vKipcbiAqIOi3r+eUseWZqOexu1xuICpcbiAqIEBjbGFzc1xuICovXG5cbnZhciBSb3V0ZXIgPSBleHBvcnRzLlJvdXRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIOaehOmAoOWHveaVsFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3Q/fSBvcHRpb25zIOWIneWni+WMluWPguaVsFxuICAgICAqIEBwYXJhbSB7c3RyaW5nP30gb3B0aW9ucy5tb2RlIOi3r+eUseaooeW8j++8jGhhc2ggfCBodG1sNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJvdXRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgICBfcmVmJG1vZGUgPSBfcmVmLm1vZGUsXG4gICAgICAgICAgICBtb2RlID0gX3JlZiRtb2RlID09PSB1bmRlZmluZWQgPyAnaGFzaCcgOiBfcmVmJG1vZGU7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICAgICAgdGhpcy5yb3V0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb3V0ZUFsaXZlcyA9IFtdO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsb2NhdG9yIHJlZGlyZWN0IOS6i+S7tuebkeWQrOWHveaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBsb2NhdG9y5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvY2F0b3JSZWRpcmVjdEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHVybCA9ICgwLCBfcGFyc2VVcmwyWydkZWZhdWx0J10pKGUudXJsKTtcbiAgICAgICAgICAgIHZhciByb3V0ZUl0ZW0gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfdGhpcy5yb3V0ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfdGhpcy5yb3V0ZXNbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGl0ZW0ucnVsZS5leGVjKHVybC5wYXRoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUl0ZW0gPSBpdGVtO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGwgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gaXRlbS5rZXlzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IG1hdGNoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXSB8fCBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwucXVlcnlba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLnBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxsIHJlZmVycmVyXG4gICAgICAgICAgICAgICAgICAgIHVybC5yZWZlcnJlciA9IGUucmVmZXJyZXI7XG4gICAgICAgICAgICAgICAgICAgIHVybC5jb25maWcgPSBpdGVtLmNvbmZpZztcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IDE7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbGlzdGVuZXIg5LqL5Lu25a+56LGhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgaGFzaDogdXJsLmhhc2gsXG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmc6IHVybC5xdWVyeVN0cmluZyxcbiAgICAgICAgICAgICAgICBxdWVyeTogdXJsLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIHBhdGg6IHVybC5wYXRoLFxuICAgICAgICAgICAgICAgIHJlZmVycmVyOiB1cmwucmVmZXJyZXIsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB1cmwuY29uZmlnLFxuICAgICAgICAgICAgICAgIHJlc3VtZTogbmV4dCxcbiAgICAgICAgICAgICAgICBzdXNwZW5kOiBmdW5jdGlvbiBzdXNwZW5kKCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5bCd6K+V6L+Q6KGM5LiL5LiA5LiqbGlzdGVuZXJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGRvTmV4dCA9IGZ1bmN0aW9uIGRvTmV4dCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgX3RoaXMubGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdGVuZXJzW2ldLmNhbGwoX3RoaXMsIGxpc3RlbmVyRXZlbnQsIHVybC5jb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlQWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOi/kOihjOS4i+S4gOS4qmxpc3RlbmVyXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBkb05leHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDov5DooYzot6/nlLHooYzkuLpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHJvdXRlQWN0aW9uID0gZnVuY3Rpb24gcm91dGVBY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb1JvdXRlKHJvdXRlSXRlbSwgdXJsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gX3RoaXMucm91dGVBbGl2ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJvdXRlQWxpdmVzW2xlbl0uY29tcG9uZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJvdXRlQWxpdmVzLnNwbGljZShsZW4sIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZG9OZXh0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRNb2RlKG1vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOi3r+eUseebkeWQrOWZqFxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlLCBjb25maWcpfSBsaXN0ZW5lciDnm5HlkKzlmahcbiAgICAgKi9cblxuXG4gICAgUm91dGVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOenu+mZpOi3r+eUseebkeWQrOWZqFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5ZmoXG4gICAgICovXG5cblxuICAgIFJvdXRlci5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiB1bmxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1tsZW5dID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShsZW4sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOaJp+ihjOi3r+eUsVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm91dGVJdGVtIOi3r+eUsemhuVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIOi3r+eUseS/oeaBr1xuICAgICAqL1xuXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLmRvUm91dGUgPSBmdW5jdGlvbiBkb1JvdXRlKHJvdXRlSXRlbSwgZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgaXNVcGRhdGVBbGl2ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5yb3V0ZUFsaXZlcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVBbGl2ZSA9IHRoaXMucm91dGVBbGl2ZXNbbGVuXTtcblxuICAgICAgICAgICAgaWYgKHJvdXRlQWxpdmUuaWQgPT09IHJvdXRlSXRlbS5pZCkge1xuICAgICAgICAgICAgICAgIHJvdXRlQWxpdmUuY29tcG9uZW50LmRhdGEuc2V0KCdyb3V0ZScsIGUpO1xuICAgICAgICAgICAgICAgIHJvdXRlQWxpdmUuY29tcG9uZW50Ll9jYWxsSG9vaygncm91dGUnKTtcbiAgICAgICAgICAgICAgICBpc1VwZGF0ZUFsaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGVBbGl2ZS5jb21wb25lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVBbGl2ZXMuc3BsaWNlKGxlbiwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVXBkYXRlQWxpdmUpIHtcbiAgICAgICAgICAgIGlmIChyb3V0ZUl0ZW0uQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KHJvdXRlSXRlbS5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ21wdChyb3V0ZUl0ZW0sIGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSXRlbS5Db21wb25lbnQoKS50aGVuKGZ1bmN0aW9uIChDbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wb25lbnQoQ21wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUl0ZW0uQ29tcG9uZW50ID0gQ21wdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQ21wdC5fX2VzTW9kdWxlICYmIGlzQ29tcG9uZW50KENtcHRbJ2RlZmF1bHQnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUl0ZW0uQ29tcG9uZW50ID0gQ21wdFsnZGVmYXVsdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmF0dGFjaENtcHQocm91dGVJdGVtLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3V0ZUl0ZW0uaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJvdXRlci5wcm90b3R5cGUuYXR0YWNoQ21wdCA9IGZ1bmN0aW9uIGF0dGFjaENtcHQocm91dGVJdGVtLCBlKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBuZXcgcm91dGVJdGVtLkNvbXBvbmVudCgpO1xuICAgICAgICBjb21wb25lbnQuZGF0YS5zZXQoJ3JvdXRlJywgZSk7XG4gICAgICAgIGNvbXBvbmVudC5fY2FsbEhvb2soJ3JvdXRlJyk7XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IHJvdXRlSXRlbS50YXJnZXQ7XG4gICAgICAgIHZhciB0YXJnZXRFbCA9ICgwLCBfZWxlbWVudFNlbGVjdG9yMlsnZGVmYXVsdCddKSh0YXJnZXQpO1xuXG4gICAgICAgIGlmICghdGFyZ2V0RWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTi1ST1VURVIgRVJST1JdICcgKyAnQXR0YWNoIGZhaWxlZCwgdGFyZ2V0IGVsZW1lbnQgXCInICsgcm91dGVJdGVtLnRhcmdldCArICdcIiBpcyBub3QgZm91bmQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnQuYXR0YWNoKHRhcmdldEVsKTtcblxuICAgICAgICB0aGlzLnJvdXRlQWxpdmVzLnB1c2goe1xuICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICBpZDogcm91dGVJdGVtLmlkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDmt7vliqDot6/nlLHpoblcbiAgICAgKiDlvZPop4TliJnljLnphY3ml7bvvIzot6/nlLHlsIbkvJjlhYjlsIZDb21wb25lbnTmuLLmn5PliLB0YXJnZXTkuK3jgILlpoLmnpzmsqHmnInljIXlkKtDb21wb25lbnTvvIzliJnmiafooYxoYW5kbGVy5Ye95pWwXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6Lev55Sx6aG56YWN572uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBjb25maWcucnVsZSDot6/nlLHop4TliJlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uP30gY29uZmlnLmhhbmRsZXIg6Lev55Sx5Ye95pWwXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj99IGNvbmZpZy5Db21wb25lbnQg6Lev55Sx57uE5Lu2XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy50YXJnZXQg6Lev55Sx57uE5Lu26KaB5riy5p+T5Yiw55qE55uu5qCH5L2N572uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzYW4tcm91dGVyIOWunuS+i1xuICAgICAqL1xuXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChjb25maWcpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSBjb25maWcucnVsZSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBjb25maWcuaGFuZGxlcixcbiAgICAgICAgICAgIF9jb25maWckdGFyZ2V0ID0gY29uZmlnLnRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldCA9IF9jb25maWckdGFyZ2V0ID09PSB1bmRlZmluZWQgPyAnI21haW4nIDogX2NvbmZpZyR0YXJnZXQsXG4gICAgICAgICAgICBDb21wb25lbnQgPSBjb25maWcuQ29tcG9uZW50O1xuXG4gICAgICAgIHZhciBrZXlzID0gWycnXTtcblxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyDmsqHnlKhwYXRoLXRvLXJlZ2V4cO+8jOaaguaXtuS4jeaPkOS+m+i/meS5iOWkmuWKn+iDveaUr+aMgVxuICAgICAgICAgICAgdmFyIHJlZ1RleHQgPSBydWxlLnJlcGxhY2UoL1xcLzooW2EtejAtOV8tXSspKD89XFwvfCQpL2lnLCBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnLyhbXi9cXFxcc10rKSc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcnVsZSA9IG5ldyBSZWdFeHAoJ14nICsgcmVnVGV4dCArICckJywgJ2knKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHJ1bGUgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4tUk9VVEVSIEVSUk9SXSBSdWxlIG11c3QgYmUgc3RyaW5nIG9yIFJlZ0V4cCEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5yb3V0ZXMucHVzaCh7IGlkOiBpZCwgcnVsZTogcnVsZSwgaGFuZGxlcjogaGFuZGxlciwga2V5czoga2V5cywgdGFyZ2V0OiB0YXJnZXQsIENvbXBvbmVudDogQ29tcG9uZW50LCBjb25maWc6IGNvbmZpZyB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5ZCv5Yqo6Lev55Sx5Yqf6IO9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHNhbi1yb3V0ZXIg5a6e5L6LXG4gICAgICovXG5cblxuICAgIFJvdXRlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2NhdG9yLm9uKCdyZWRpcmVjdCcsIHRoaXMubG9jYXRvclJlZGlyZWN0SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmxvY2F0b3Iuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMubG9jYXRvci5yZWxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlgZzmraLot6/nlLHlip/og71cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc2FuLXJvdXRlciDlrp7kvotcbiAgICAgKi9cblxuXG4gICAgUm91dGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdGhpcy5sb2NhdG9yLnVuKCdyZWRpcmVjdCcsIHRoaXMubG9jYXRvclJlZGlyZWN0SGFuZGxlcik7XG4gICAgICAgIHRoaXMubG9jYXRvci5zdG9wKCk7XG4gICAgICAgIHRoaXMuaXNTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOiuvue9rui3r+eUseaooeW8j1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUg6Lev55Sx5qih5byP77yMaGFzaCB8IGh0bWw1XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzYW4tcm91dGVyIOWunuS+i1xuICAgICAqL1xuXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbiBzZXRNb2RlKG1vZGUpIHtcbiAgICAgICAgbW9kZSA9IG1vZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gbW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcblxuICAgICAgICB2YXIgcmVzdGFydCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmVzdGFydCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRvciA9IG5ldyBfaGFzaDJbJ2RlZmF1bHQnXSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaHRtbDUnOlxuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRvciA9IG5ldyBfaHRtbDJbJ2RlZmF1bHQnXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gUm91dGVyO1xufSgpO1xuXG4vKipcbiAqIOm7mOiupOeahOi3r+eUseWZqOWunuS+i1xuICpcbiAqIEB0eXBlIHtSb3V0ZXJ9XG4gKi9cblxuXG52YXIgcm91dGVyID0gZXhwb3J0cy5yb3V0ZXIgPSBuZXcgUm91dGVyKCk7XG5cbi8qKlxuICog6Lev55Sx6ZO+5o6l55qEIFNhbiDnu4Tku7ZcbiAqXG4gKiBAY2xhc3NcbiAqL1xuZXhwb3J0cy5MaW5rID0gX2xpbmsyWydkZWZhdWx0J107XG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBlbGVtZW50U2VsZWN0b3I7XG4vKlxuKlxuKiBAZmlsZSDpgInmi6nlmahcbiogQGF1dGhvciB2aW5jZW50IGxhdS80MTM4OTMwOTNAcXEuY29tXG4qL1xuXG4vKipcbiAqIOWFg+e0oOmAieaLqeWZqFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IHNlbGVjdG9yIOmAieaLqeWZqFxuICogQHJldHVybnMge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHN3aXRjaCAodHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzZWxlY3RvcikpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvci5yZXBsYWNlKC8jL2ksICcnKSk7XG4gICAgfVxufVxuXG4vKioqLyB9XG4vKioqKioqLyBdKTtcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_san-router@1.2.0@san-router/dist/san-router.source.js\n");

/***/ }),

/***/ "./node_modules/_san@3.6.1@san/dist/san.js":
/*!*************************************************!*\
  !*** ./node_modules/_san@3.6.1@san/dist/san.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {/**\n * San\n * Copyright 2016 Baidu Inc. All rights reserved.\n *\n * @file 主文件\n * @author errorrik(errorrik@gmail.com)\n *         otakustay(otakustay@gmail.com)\n *         junmer(junmer@foxmail.com)\n */\n\n(function (root) {\n    // 人工调整打包代码顺序，通过注释手工写一些依赖\n//     // require('./util/guid');\n//     // require('./util/empty');\n//     // require('./util/extend');\n//     // require('./util/inherits');\n//     // require('./util/each');\n//     // require('./util/contains');\n//     // require('./util/bind');\n//     // require('./browser/on');\n//     // require('./browser/un');\n//     // require('./browser/svg-tags');\n//     // require('./browser/create-el');\n//     // require('./browser/remove-el');\n//     // require('./util/next-tick');\n//     // require('./browser/ie');\n//     // require('./browser/ie-old-than-9');\n//     // require('./browser/input-event-compatible');\n//     // require('./browser/auto-close-tags');\n//     // require('./util/data-types.js');\n//     // require('./util/create-data-types-checker.js');\n//     // require('./parser/walker');\n//     // require('./parser/create-a-node');\n//     // require('./parser/parse-template');\n//     // require('./runtime/change-expr-compare');\n//     // require('./runtime/data-change-type');\n//     // require('./runtime/default-filters');\n//     // require('./view/life-cycle');\n//     // require('./view/node-type');\n//     // require('./view/get-prop-handler');\n//     // require('./view/is-data-change-by-element');\n//     // require('./view/event-declaration-listener');\n//     // require('./view/create-node');\n\n\n    /**\n * @file 生成唯一id\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/**\n * 唯一id的起始值\n *\n * @inner\n * @type {number}\n */\nvar guidIndex = 1;\n\n/**\n * 唯一id的前缀\n *\n * @inner\n * @type {string}\n */\nvar guidPrefix = (new Date()).getTime().toString(16).slice(8);\n\n/**\n * 获取唯一id\n *\n * @inner\n * @return {string} 唯一id\n */\nfunction guid() {\n    return '_' + guidPrefix + (guidIndex++);\n}\n\n// exports = module.exports = guid;\n\n\n/**\n * @file 空函数\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/**\n * 啥都不干\n */\nfunction empty() {}\n\n// exports = module.exports = empty;\n\n\n/**\n * @file 属性拷贝\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 对象属性拷贝\n *\n * @param {Object} target 目标对象\n * @param {Object} source 源对象\n * @return {Object} 返回目标对象\n */\nfunction extend(target, source) {\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            var value = source[key];\n            if (typeof value !== 'undefined') {\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n}\n\n// exports = module.exports = extend;\n\n\n/**\n * @file 构建类之间的继承关系\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var extend = require('./extend');\n\n/**\n * 构建类之间的继承关系\n *\n * @param {Function} subClass 子类函数\n * @param {Function} superClass 父类函数\n */\nfunction inherits(subClass, superClass) {\n    /* jshint -W054 */\n    var subClassProto = subClass.prototype;\n    var F = new Function();\n    F.prototype = superClass.prototype;\n    subClass.prototype = new F();\n    subClass.prototype.constructor = subClass;\n    extend(subClass.prototype, subClassProto);\n    /* jshint +W054 */\n}\n\n// exports = module.exports = inherits;\n\n\n/**\n * @file 遍历数组\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/**\n * 遍历数组集合\n *\n * @param {Array} array 数组源\n * @param {function(Any,number):boolean} iterator 遍历函数\n */\nfunction each(array, iterator) {\n    if (array && array.length > 0) {\n        for (var i = 0, l = array.length; i < l; i++) {\n            if (iterator(array[i], i) === false) {\n                break;\n            }\n        }\n    }\n}\n\n// exports = module.exports = each;\n\n\n/**\n * @file 判断数组中是否包含某项\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('./each');\n\n/**\n * 判断数组中是否包含某项\n *\n * @param {Array} array 数组\n * @param {*} value 包含的项\n * @return {boolean}\n */\nfunction contains(array, value) {\n    var result = false;\n    each(array, function (item) {\n        result = item === value;\n        return !result;\n    });\n\n    return result;\n}\n\n// exports = module.exports = contains;\n\n\n/**\n * @file bind函数\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * Function.prototype.bind 方法的兼容性封装\n *\n * @param {Function} func 要bind的函数\n * @param {Object} thisArg this指向对象\n * @param {...*} args 预设的初始参数\n * @return {Function}\n */\nfunction bind(func, thisArg) {\n    var nativeBind = Function.prototype.bind;\n    var slice = Array.prototype.slice;\n    // #[begin] allua\n    if (nativeBind && func.bind === nativeBind) {\n    // #[end]\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    // #[begin] allua\n    }\n\n    var args = slice.call(arguments, 2);\n    return function () {\n        return func.apply(thisArg, args.concat(slice.call(arguments)));\n    };\n    // #[end]\n}\n\n// exports = module.exports = bind;\n\n\n/**\n * @file DOM 事件挂载\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * DOM 事件挂载\n *\n * @inner\n * @param {HTMLElement} el DOM元素\n * @param {string} eventName 事件名\n * @param {Function} listener 监听函数\n * @param {boolean} capture 是否是捕获阶段\n */\nfunction on(el, eventName, listener, capture) {\n    // #[begin] allua\n    if (el.addEventListener) {\n    // #[end]\n        el.addEventListener(eventName, listener, capture);\n    // #[begin] allua\n    }\n    else {\n        el.attachEvent('on' + eventName, listener);\n    }\n    // #[end]\n}\n\n// exports = module.exports = on;\n\n\n/**\n * @file DOM 事件卸载\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * DOM 事件卸载\n *\n * @inner\n * @param {HTMLElement} el DOM元素\n * @param {string} eventName 事件名\n * @param {Function} listener 监听函数\n * @param {boolean} capture 是否是捕获阶段\n */\nfunction un(el, eventName, listener, capture) {\n    // #[begin] allua\n    if (el.addEventListener) {\n    // #[end]\n        el.removeEventListener(eventName, listener, capture);\n    // #[begin] allua\n    }\n    else {\n        el.detachEvent('on' + eventName, listener);\n    }\n    // #[end]\n}\n\n// exports = module.exports = un;\n\n\n/**\n * @file 将字符串逗号切分返回对象\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('../util/each');\n\n/**\n * 将字符串逗号切分返回对象\n *\n * @param {string} source 源字符串\n * @return {Object}\n */\nfunction splitStr2Obj(source) {\n    var result = {};\n    each(\n        source.split(','),\n        function (key) {\n            result[key] = 1;\n        }\n    );\n    return result;\n}\n\n// exports = module.exports = splitStr2Obj;\n\n\n/**\n * @file SVG标签表\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var splitStr2Obj = require('../util/split-str-2-obj');\n\n/**\n * svgTags\n *\n * @see https://www.w3.org/TR/SVG/svgdtd.html 只取常用\n * @type {Object}\n */\nvar svgTags = splitStr2Obj(''\n    // structure\n    + 'svg,g,defs,desc,metadata,symbol,use,'\n    // image & shape\n    + 'image,path,rect,circle,line,ellipse,polyline,polygon,'\n    // text\n    + 'text,tspan,tref,textpath,'\n    // other\n    + 'marker,pattern,clippath,mask,filter,cursor,view,animate,'\n    // font\n    + 'font,font-face,glyph,missing-glyph');\n\n// exports = module.exports = svgTags;\n\n\n/**\n * @file DOM创建\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var svgTags = require('./svg-tags');\n\n/**\n * 创建 DOM 元素\n *\n * @param  {string} tagName tagName\n * @return {HTMLElement}\n */\nfunction createEl(tagName) {\n    if (svgTags[tagName]) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n    }\n\n    return document.createElement(tagName);\n}\n\n// exports = module.exports = createEl;\n\n\n/**\n * @file 移除DOM\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 将 DOM 从页面中移除\n *\n * @param {HTMLElement} el DOM元素\n */\nfunction removeEl(el) {\n    if (el && el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n\n// exports = module.exports = removeEl;\n\n\n/**\n * @file 在下一个时间周期运行任务\n * @author errorrik(errorrik@gmail.com)\n */\n\n// 该方法参照了vue2.5.0的实现，感谢vue团队\n// SEE: https://github.com/vuejs/vue/blob/0948d999f2fddf9f90991956493f976273c5da1f/src/core/util/env.js#L68\n\n\n// var bind = require('./bind');\n\n/**\n * 下一个周期要执行的任务列表\n *\n * @inner\n * @type {Array}\n */\nvar nextTasks = [];\n\n/**\n * 执行下一个周期任务的函数\n *\n * @inner\n * @type {Function}\n */\nvar nextHandler;\n\n/**\n * 浏览器是否支持原生Promise\n * 对Promise做判断，是为了禁用一些不严谨的Promise的polyfill\n *\n * @inner\n * @type {boolean}\n */\nvar isNativePromise = typeof Promise === 'function' && /native code/.test(Promise);\n\n/**\n * 在下一个时间周期运行任务\n *\n * @inner\n * @param {Function} fn 要运行的任务函数\n * @param {Object=} thisArg this指向对象\n */\nfunction nextTick(fn, thisArg) {\n    if (thisArg) {\n        fn = bind(fn, thisArg);\n    }\n    nextTasks.push(fn);\n\n    if (nextHandler) {\n        return;\n    }\n\n    nextHandler = function () {\n        var tasks = nextTasks.slice(0);\n        nextTasks = [];\n        nextHandler = null;\n\n        for (var i = 0, l = tasks.length; i < l; i++) {\n            tasks[i]();\n        }\n    };\n\n    // 非标准方法，但是此方法非常吻合要求。\n    if (typeof setImmediate === 'function') {\n        setImmediate(nextHandler);\n    }\n    // 用MessageChannel去做setImmediate的polyfill\n    // 原理是将新的message事件加入到原有的dom events之后\n    else if (typeof MessageChannel === 'function') {\n        var channel = new MessageChannel();\n        var port = channel.port2;\n        channel.port1.onmessage = nextHandler;\n        port.postMessage(1);\n    }\n    // for native app\n    else if (isNativePromise) {\n        Promise.resolve().then(nextHandler);\n    }\n    else {\n        setTimeout(nextHandler, 0);\n    }\n}\n\n// exports = module.exports = nextTick;\n\n\n/**\n * @file ie版本号\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 从userAgent中ie版本号的匹配信息\n *\n * @type {Array}\n */\nvar ieVersionMatch = typeof navigator !== 'undefined'\n    && navigator.userAgent.match(/msie\\s*([0-9]+)/i);\n\n/**\n * ie版本号，非ie时为0\n *\n * @type {number}\n */\nvar ie = ieVersionMatch ? ieVersionMatch[1] - 0 : 0;\n\n// exports = module.exports = ie;\n\n\n/**\n * @file 是否 IE 并且小于 9\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ie = require('./ie');\n\n// HACK:\n// 1. IE8下，设置innerHTML时如果以html comment开头，comment会被自动滤掉\n//    为了保证stump存在，需要设置完html后，createComment并appendChild/insertBefore\n// 2. IE8下，innerHTML还不支持custom element，所以需要用div替代，不用createElement\n// 3. 虽然IE8已经优化了字符串+连接，碎片化连接性能不再退化\n//    但是由于上面多个兼容场景都用 < 9 判断，所以字符串连接也沿用\n//    所以结果是IE8下字符串连接用的是数组join的方式\n\n// #[begin] allua\n/**\n * 是否 IE 并且小于 9\n */\nvar ieOldThan9 = ie && ie < 9;\n// #[end]\n\n// exports = module.exports = ieOldThan9;\n\n\n/**\n * @file DOM 事件挂载\n * @author dafrok(o.o@mug.dog)\n */\n\n/**\n * DOM 事件挂载\n *\n * @inner\n * @param {HTMLElement} el DOM元素\n * @param {string} eventName 事件名\n */\nfunction trigger(el, eventName) {\n    var event = document.createEvent('HTMLEvents');\n    event.initEvent(eventName, true, true);\n    el.dispatchEvent(event);\n}\n\n// exports = module.exports = trigger;\n\n\n/**\n * @file 解决 IE9 在表单元素中删除字符时不触发事件的问题\n * @author dafrok(o.o@mug.dog)\n */\n\n// var ie = require('./ie');\n// var on = require('./on');\n// var trigger = require('./trigger');\n\n// #[begin] allua\nif (ie === 9) {\n    on(document, 'selectionchange', function () {\n        var el = document.activeElement;\n        if (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') {\n            trigger(el, 'input');\n        }\n    });\n}\n// #[end]\n\n\n/**\n * @file 自闭合标签表\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var splitStr2Obj = require('../util/split-str-2-obj');\n\n/**\n * 自闭合标签列表\n *\n * @type {Object}\n */\nvar autoCloseTags = splitStr2Obj('area,base,br,col,embed,hr,img,input,keygen,param,source,track,wbr');\n\n// exports = module.exports = autoCloseTags;\n\n\n/**\n * @file data types\n * @author leon <ludafa@outlook.com>\n */\n\n// var bind = require('./bind');\n// var empty = require('./empty');\n// var extend = require('./extend');\n\n// #[begin] error\n// var ANONYMOUS_CLASS_NAME = '<<anonymous>>';\n// \n// /**\n//  * 获取精确的类型\n//  *\n//  * @NOTE 如果 obj 是一个 DOMElement，我们会返回 `element`；\n//  *\n//  * @param  {*} obj 目标\n//  * @return {string}\n//  */\n// function getDataType(obj) {\n// \n//     if (obj && obj.nodeType === 1) {\n//         return 'element';\n//     }\n// \n//     return Object.prototype.toString\n//         .call(obj)\n//         .slice(8, -1)\n//         .toLowerCase();\n// }\n// #[end]\n\n/**\n * 创建链式的数据类型校验器\n *\n * @param  {Function} validate 真正的校验器\n * @return {Function}\n */\nfunction createChainableChecker(validate) {\n    var chainedChecker = function () {};\n    chainedChecker.isRequired = empty;\n\n    // 只在 error 功能启用时才有实际上的 dataTypes 检测\n    // #[begin] error\n//     var checkType = function (isRequired, data, dataName, componentName, fullDataName) {\n// \n//         var dataValue = data[dataName];\n//         var dataType = getDataType(dataValue);\n// \n//         componentName = componentName || ANONYMOUS_CLASS_NAME;\n// \n//         // 如果是 null 或 undefined，那么要提前返回啦\n//         if (dataValue == null) {\n//             // 是 required 就报错\n//             if (isRequired) {\n//                 throw new Error('[SAN ERROR] '\n//                     + 'The `' + dataName + '` '\n//                     + 'is marked as required in `' + componentName + '`, '\n//                     + 'but its value is ' + dataType\n//                 );\n//             }\n//             // 不是 required，那就是 ok 的\n//             return;\n//         }\n// \n//         validate(data, dataName, componentName, fullDataName);\n// \n//     };\n// \n//     chainedChecker = bind(checkType, null, false);\n//     chainedChecker.isRequired = bind(checkType, null, true);\n    // #[end]\n\n\n\n    return chainedChecker;\n\n}\n\n// #[begin] error\n// /**\n//  * 生成主要类型数据校验器\n//  *\n//  * @param  {string} type 主类型\n//  * @return {Function}\n//  */\n// function createPrimaryTypeChecker(type) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName) {\n// \n//         var dataValue = data[dataName];\n//         var dataType = getDataType(dataValue);\n// \n//         if (dataType !== type) {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\n//                 + '(' + dataType + ' supplied to ' + componentName + ', '\n//                 + 'expected ' + type + ')'\n//             );\n//         }\n// \n//     });\n// \n// }\n// \n// \n// \n// /**\n//  * 生成 arrayOf 校验器\n//  *\n//  * @param  {Function} arrayItemChecker 数组中每项数据的校验器\n//  * @return {Function}\n//  */\n// function createArrayOfChecker(arrayItemChecker) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName) {\n// \n//         if (typeof arrayItemChecker !== 'function') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\n//                 + 'DataType notation inside `arrayOf`, expected `function`'\n//             );\n//         }\n// \n//         var dataValue = data[dataName];\n//         var dataType = getDataType(dataValue);\n// \n//         if (dataType !== 'array') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\n//                 + '(' + dataType + ' supplied to ' + componentName + ', '\n//                 + 'expected array)'\n//             );\n//         }\n// \n//         for (var i = 0, len = dataValue.length; i < len; i++) {\n//             arrayItemChecker(dataValue, i, componentName, fullDataName + '[' + i + ']');\n//         }\n// \n//     });\n// \n// }\n// \n// /**\n//  * 生成 instanceOf 检测器\n//  *\n//  * @param  {Function|Class} expectedClass 期待的类\n//  * @return {Function}\n//  */\n// function createInstanceOfChecker(expectedClass) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName) {\n// \n//         var dataValue = data[dataName];\n// \n//         if (dataValue instanceof expectedClass) {\n//             return;\n//         }\n// \n//         var dataValueClassName = dataValue.constructor && dataValue.constructor.name\n//             ? dataValue.constructor.name\n//             : ANONYMOUS_CLASS_NAME;\n// \n//         var expectedClassName = expectedClass.name || ANONYMOUS_CLASS_NAME;\n// \n//         throw new Error('[SAN ERROR] '\n//             + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\n//             + '(' + dataValueClassName + ' supplied to ' + componentName + ', '\n//             + 'expected instance of ' + expectedClassName + ')'\n//         );\n// \n// \n//     });\n// \n// }\n// \n// /**\n//  * 生成 shape 校验器\n//  *\n//  * @param  {Object} shapeTypes shape 校验规则\n//  * @return {Function}\n//  */\n// function createShapeChecker(shapeTypes) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName) {\n// \n//         if (getDataType(shapeTypes) !== 'object') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Data `' + fullDataName + '` of `' + componentName + '` has invalid '\n//                 + 'DataType notation inside `shape`, expected `object`'\n//             );\n//         }\n// \n//         var dataValue = data[dataName];\n//         var dataType = getDataType(dataValue);\n// \n//         if (dataType !== 'object') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\n//                 + '(' + dataType + ' supplied to ' + componentName + ', '\n//                 + 'expected object)'\n//             );\n//         }\n// \n//         for (var shapeKeyName in shapeTypes) {\n//             if (shapeTypes.hasOwnProperty(shapeKeyName)) {\n//                 var checker = shapeTypes[shapeKeyName];\n//                 if (typeof checker === 'function') {\n//                     checker(dataValue, shapeKeyName, componentName, fullDataName + '.' + shapeKeyName);\n//                 }\n//             }\n//         }\n// \n//     });\n// \n// }\n// \n// /**\n//  * 生成 oneOf 校验器\n//  *\n//  * @param  {Array} expectedEnumValues 期待的枚举值\n//  * @return {Function}\n//  */\n// function createOneOfChecker(expectedEnumValues) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName) {\n// \n//         if (getDataType(expectedEnumValues) !== 'array') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Data `' + fullDataName + '` of `' + componentName + '` has invalid '\n//                 + 'DataType notation inside `oneOf`, array is expected.'\n//             );\n//         }\n// \n//         var dataValue = data[dataName];\n// \n//         for (var i = 0, len = expectedEnumValues.length; i < len; i++) {\n//             if (dataValue === expectedEnumValues[i]) {\n//                 return;\n//             }\n//         }\n// \n//         throw new Error('[SAN ERROR] '\n//             + 'Invalid ' + componentName + ' data `' + fullDataName + '` of value'\n//             + '(`' + dataValue + '` supplied to ' + componentName + ', '\n//             + 'expected one of ' + expectedEnumValues.join(',') + ')'\n//         );\n// \n//     });\n// \n// }\n// \n// /**\n//  * 生成 oneOfType 校验器\n//  *\n//  * @param  {Array<Function>} expectedEnumOfTypeValues 期待的枚举类型\n//  * @return {Function}\n//  */\n// function createOneOfTypeChecker(expectedEnumOfTypeValues) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName) {\n// \n//         if (getDataType(expectedEnumOfTypeValues) !== 'array') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\n//                 + 'DataType notation inside `oneOf`, array is expected.'\n//             );\n//         }\n// \n//         var dataValue = data[dataName];\n// \n//         for (var i = 0, len = expectedEnumOfTypeValues.length; i < len; i++) {\n// \n//             var checker = expectedEnumOfTypeValues[i];\n// \n//             if (typeof checker !== 'function') {\n//                 continue;\n//             }\n// \n//             try {\n//                 checker(data, dataName, componentName, fullDataName);\n//                 // 如果 checker 完成校验没报错，那就返回了\n//                 return;\n//             }\n//             catch (e) {\n//                 // 如果有错误，那么应该把错误吞掉\n//             }\n// \n//         }\n// \n//         // 所有的可接受 type 都失败了，才丢一个异常\n//         throw new Error('[SAN ERROR] '\n//             + 'Invalid ' + componentName + ' data `' + dataName + '` of value'\n//             + '(`' + dataValue + '` supplied to ' + componentName + ')'\n//         );\n// \n//     });\n// \n// }\n// \n// /**\n//  * 生成 objectOf 校验器\n//  *\n//  * @param  {Function} typeChecker 对象属性值校验器\n//  * @return {Function}\n//  */\n// function createObjectOfChecker(typeChecker) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName) {\n// \n//         if (typeof typeChecker !== 'function') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\n//                 + 'DataType notation inside `objectOf`, expected function'\n//             );\n//         }\n// \n//         var dataValue = data[dataName];\n//         var dataType = getDataType(dataValue);\n// \n//         if (dataType !== 'object') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Invalid ' + componentName + ' data `' + dataName + '` of type'\n//                 + '(' + dataType + ' supplied to ' + componentName + ', '\n//                 + 'expected object)'\n//             );\n//         }\n// \n//         for (var dataKeyName in dataValue) {\n//             if (dataValue.hasOwnProperty(dataKeyName)) {\n//                 typeChecker(\n//                     dataValue,\n//                     dataKeyName,\n//                     componentName,\n//                     fullDataName + '.' + dataKeyName\n//                 );\n//             }\n//         }\n// \n// \n//     });\n// \n// }\n// \n// /**\n//  * 生成 exact 校验器\n//  *\n//  * @param  {Object} shapeTypes object 形态定义\n//  * @return {Function}\n//  */\n// function createExactChecker(shapeTypes) {\n// \n//     return createChainableChecker(function (data, dataName, componentName, fullDataName, secret) {\n// \n//         if (getDataType(shapeTypes) !== 'object') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\n//                 + 'DataType notation inside `exact`'\n//             );\n//         }\n// \n//         var dataValue = data[dataName];\n//         var dataValueType = getDataType(dataValue);\n// \n//         if (dataValueType !== 'object') {\n//             throw new Error('[SAN ERROR] '\n//                 + 'Invalid data `' + fullDataName + '` of type `' + dataValueType + '`'\n//                 + '(supplied to ' + componentName + ', expected `object`)'\n//             );\n//         }\n// \n//         var allKeys = {};\n// \n//         // 先合入 shapeTypes\n//         extend(allKeys, shapeTypes);\n//         // 再合入 dataValue\n//         extend(allKeys, dataValue);\n//         // 保证 allKeys 的类型正确\n// \n//         for (var key in allKeys) {\n//             if (allKeys.hasOwnProperty(key)) {\n//                 var checker = shapeTypes[key];\n// \n//                 // dataValue 中有一个多余的数据项\n//                 if (!checker) {\n//                     throw new Error('[SAN ERROR] '\n//                         + 'Invalid data `' + fullDataName + '` key `' + key + '` '\n//                         + 'supplied to `' + componentName + '`. '\n//                         + '(`' + key + '` is not defined in `DataTypes.exact`)'\n//                     );\n//                 }\n// \n//                 if (!(key in dataValue)) {\n//                     throw new Error('[SAN ERROR] '\n//                         + 'Invalid data `' + fullDataName + '` key `' + key + '` '\n//                         + 'supplied to `' + componentName + '`. '\n//                         + '(`' + key + '` is marked `required` in `DataTypes.exact`)'\n//                     );\n//                 }\n// \n//                 checker(\n//                     dataValue,\n//                     key,\n//                     componentName,\n//                     fullDataName + '.' + key,\n//                     secret\n//                 );\n// \n//             }\n//         }\n// \n//     });\n// \n// }\n// #[end]\n\n\n\n/* eslint-disable fecs-valid-var-jsdoc */\nvar DataTypes = {\n    array: createChainableChecker(empty),\n    object: createChainableChecker(empty),\n    func: createChainableChecker(empty),\n    string: createChainableChecker(empty),\n    number: createChainableChecker(empty),\n    bool: createChainableChecker(empty),\n    symbol: createChainableChecker(empty),\n    any: createChainableChecker,\n    arrayOf: createChainableChecker,\n    instanceOf: createChainableChecker,\n    shape: createChainableChecker,\n    oneOf: createChainableChecker,\n    oneOfType: createChainableChecker,\n    objectOf: createChainableChecker,\n    exact: createChainableChecker\n};\n\n// #[begin] error\n// DataTypes = {\n// \n//     any: createChainableChecker(empty),\n// \n//     // 类型检测\n//     array: createPrimaryTypeChecker('array'),\n//     object: createPrimaryTypeChecker('object'),\n//     func: createPrimaryTypeChecker('function'),\n//     string: createPrimaryTypeChecker('string'),\n//     number: createPrimaryTypeChecker('number'),\n//     bool: createPrimaryTypeChecker('boolean'),\n//     symbol: createPrimaryTypeChecker('symbol'),\n// \n//     // 复合类型检测\n//     arrayOf: createArrayOfChecker,\n//     instanceOf: createInstanceOfChecker,\n//     shape: createShapeChecker,\n//     oneOf: createOneOfChecker,\n//     oneOfType: createOneOfTypeChecker,\n//     objectOf: createObjectOfChecker,\n//     exact: createExactChecker\n// \n// };\n// /* eslint-enable fecs-valid-var-jsdoc */\n// #[end]\n\n\n// module.exports = DataTypes;\n\n\n/**\n * @file 创建数据检测函数\n * @author leon<ludafa@outlook.com>\n */\n\n\n// #[begin] error\n// \n// /**\n//  * 创建数据检测函数\n//  *\n//  * @param  {Object} dataTypes     数据格式\n//  * @param  {string} componentName 组件名\n//  * @return {Function}\n//  */\n// function createDataTypesChecker(dataTypes, componentName) {\n// \n//     /**\n//      * 校验 data 是否满足 data types 的格式\n//      *\n//      * @param  {*} data 数据\n//      */\n//     return function (data) {\n// \n//         for (var dataTypeName in dataTypes) {\n// \n//             if (dataTypes.hasOwnProperty(dataTypeName)) {\n// \n//                 var dataTypeChecker = dataTypes[dataTypeName];\n// \n//                 if (typeof dataTypeChecker !== 'function') {\n//                     throw new Error('[SAN ERROR] '\n//                         + componentName + ':' + dataTypeName + ' is invalid; '\n//                         + 'it must be a function, usually from san.DataTypes'\n//                     );\n//                 }\n// \n//                 dataTypeChecker(\n//                     data,\n//                     dataTypeName,\n//                     componentName,\n//                     dataTypeName\n//                 );\n// \n// \n//             }\n//         }\n// \n//     };\n// \n// }\n// \n// #[end]\n\n// module.exports = createDataTypesChecker;\n\n\n/**\n * @file 字符串源码读取类\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/**\n * 字符串源码读取类，用于模板字符串解析过程\n *\n * @class\n * @param {string} source 要读取的字符串\n */\nfunction Walker(source) {\n    this.source = source;\n    this.len = this.source.length;\n    this.index = 0;\n}\n\n/**\n * 获取当前字符码\n *\n * @return {number}\n */\nWalker.prototype.currentCode = function () {\n    return this.charCode(this.index);\n};\n\n/**\n * 截取字符串片段\n *\n * @param {number} start 起始位置\n * @param {number} end 结束位置\n * @return {string}\n */\nWalker.prototype.cut = function (start, end) {\n    return this.source.slice(start, end);\n};\n\n/**\n * 向前读取字符\n *\n * @param {number} distance 读取字符数\n */\nWalker.prototype.go = function (distance) {\n    this.index += distance;\n};\n\n/**\n * 读取下一个字符，返回下一个字符的 code\n *\n * @return {number}\n */\nWalker.prototype.nextCode = function () {\n    this.go(1);\n    return this.currentCode();\n};\n\n/**\n * 获取相应位置字符的 code\n *\n * @param {number} index 字符位置\n * @return {number}\n */\nWalker.prototype.charCode = function (index) {\n    return this.source.charCodeAt(index);\n};\n\n/**\n * 向前读取字符，直到遇到指定字符再停止\n * 未指定字符时，当遇到第一个非空格、制表符的字符停止\n *\n * @param {number=} charCode 指定字符的code\n * @return {boolean} 当指定字符时，返回是否碰到指定的字符\n */\nWalker.prototype.goUntil = function (charCode) {\n    var code;\n    while (this.index < this.len && (code = this.currentCode())) {\n        switch (code) {\n            // 空格 space\n            case 32:\n            // 制表符 tab\n            case 9:\n            // \\r\n            case 13:\n            // \\n\n            case 10:\n                this.index++;\n                break;\n            default:\n                if (code === charCode) {\n                    this.index++;\n                    return 1;\n                }\n                return;\n        }\n    }\n};\n\n/**\n * 向前读取符合规则的字符片段，并返回规则匹配结果\n *\n * @param {RegExp} reg 字符片段的正则表达式\n * @param {boolean} isMatchStart 是否必须匹配当前位置\n * @return {Array?}\n */\nWalker.prototype.match = function (reg, isMatchStart) {\n    reg.lastIndex = this.index;\n\n    var match = reg.exec(this.source);\n    if (match && (!isMatchStart || this.index === match.index)) {\n        this.index = reg.lastIndex;\n        return match;\n    }\n};\n\n// exports = module.exports = Walker;\n\n\n/**\n * @file 模板解析生成的抽象节点\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 创建模板解析生成的抽象节点\n *\n * @param {Object=} options 节点参数\n * @param {string=} options.tagName 标签名\n * @param {ANode=} options.parent 父节点\n * @param {boolean=} options.textExpr 文本节点表达式对象\n * @return {Object}\n */\nfunction createANode(options) {\n    options = options || {};\n\n    if (!options.textExpr) {\n        options.directives = options.directives || {};\n        options.props = options.props || [];\n        options.events = options.events || [];\n        options.children = options.children || [];\n    }\n\n    return options;\n}\n\n// exports = module.exports = createANode;\n\n\n/**\n * @file 把 kebab case 字符串转换成 camel case\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 把 kebab case 字符串转换成 camel case\n *\n * @param {string} source 源字符串\n * @return {string}\n */\nfunction kebab2camel(source) {\n    return source.replace(/-([a-z])/g, function (match, alpha) {\n        return alpha.toUpperCase();\n    });\n}\n\n// exports = module.exports = kebab2camel;\n\n\n/**\n * @file 表达式类型\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 表达式类型\n *\n * @const\n * @type {Object}\n */\nvar ExprType = {\n    STRING: 1,\n    NUMBER: 2,\n    BOOL: 3,\n    ACCESSOR: 4,\n    INTERP: 5,\n    CALL: 6,\n    TEXT: 7,\n    BINARY: 8,\n    UNARY: 9,\n    TERTIARY: 10,\n    OBJECT: 11,\n    ARRAY: 12\n};\n\n// exports = module.exports = ExprType;\n\n\n/**\n * @file 创建访问表达式对象\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n\n/**\n * 创建访问表达式对象\n *\n * @param {Array} paths 访问路径\n * @return {Object}\n */\nfunction createAccessor(paths) {\n    return {\n        type: ExprType.ACCESSOR,\n        paths: paths\n    };\n}\n\n// exports = module.exports = createAccessor;\n\n\n/**\n * @file 读取字符串\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var ExprType = require('./expr-type');\n\n/**\n * 读取字符串\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readString(walker) {\n    var startCode = walker.currentCode();\n    var startIndex = walker.index;\n    var charCode;\n\n    walkLoop: while ((charCode = walker.nextCode())) {\n        switch (charCode) {\n            case 92: // \\\n                walker.go(1);\n                break;\n            case startCode:\n                walker.go(1);\n                break walkLoop;\n        }\n    }\n\n    var literal = walker.cut(startIndex, walker.index);\n    return {\n        type: ExprType.STRING,\n        // 处理字符转义\n        value: (new Function('return ' + literal))()\n    };\n}\n\n// exports = module.exports = readString;\n\n\n/**\n * @file 读取数字\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var ExprType = require('./expr-type');\n\n/**\n * 读取数字\n *\n * @inner\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readNumber(walker) {\n    var match = walker.match(/\\s*(-?[0-9]+(\\.[0-9]+)?)/g);\n\n    return {\n        type: ExprType.NUMBER,\n        value: +match[1]\n    };\n}\n\n// exports = module.exports = readNumber;\n\n\n/**\n * @file 读取ident\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 读取ident\n * 这里的 ident 指标识符(identifier)，也就是通常意义上的变量名\n * 这里默认的变量名规则为：由美元符号($)、数字、字母或者下划线(_)构成的字符串\n *\n * @inner\n * @param {Walker} walker 源码读取对象\n * @return {string}\n */\nfunction readIdent(walker) {\n    var match = walker.match(/\\s*([\\$0-9a-z_]+)/ig, 1);\n\n    // #[begin] error\n//     if (!match) {\n//         throw new Error('[SAN FATAL] expect an ident: ' + walker.cut(walker.index));\n//     }\n    // #[end]\n\n    return match[1];\n}\n\n// exports = module.exports = readIdent;\n\n\n/**\n * @file 读取三元表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readLogicalORExpr = require('./read-logical-or-expr');\n\n/**\n * 读取三元表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readTertiaryExpr(walker) {\n    var conditional = readLogicalORExpr(walker);\n    walker.goUntil();\n\n    if (walker.currentCode() === 63) { // ?\n        walker.go(1);\n        var yesExpr = readTertiaryExpr(walker);\n        walker.goUntil();\n\n        if (walker.currentCode() === 58) { // :\n            walker.go(1);\n            return {\n                type: ExprType.TERTIARY,\n                segs: [\n                    conditional,\n                    yesExpr,\n                    readTertiaryExpr(walker)\n                ]\n            };\n        }\n    }\n\n    return conditional;\n}\n\n// exports = module.exports = readTertiaryExpr;\n\n\n/**\n * @file 读取访问表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var createAccessor = require('./create-accessor');\n// var readIdent = require('./read-ident');\n// var readTertiaryExpr = require('./read-tertiary-expr');\n\n/**\n * 读取访问表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readAccessor(walker) {\n    var firstSeg = readIdent(walker);\n    switch (firstSeg) {\n        case 'true':\n        case 'false':\n            return {\n                type: ExprType.BOOL,\n                value: firstSeg === 'true'\n            };\n    }\n\n    var result = createAccessor([\n        {\n            type: ExprType.STRING,\n            value: firstSeg\n        }\n    ]);\n\n    /* eslint-disable no-constant-condition */\n    accessorLoop: while (1) {\n    /* eslint-enable no-constant-condition */\n\n        switch (walker.currentCode()) {\n            case 46: // .\n                walker.go(1);\n\n                // ident as string\n                result.paths.push({\n                    type: ExprType.STRING,\n                    value: readIdent(walker)\n                });\n                break;\n\n            case 91: // [\n                walker.go(1);\n                result.paths.push(readTertiaryExpr(walker));\n                walker.goUntil(93); // ]\n                break;\n\n            default:\n                break accessorLoop;\n        }\n    }\n\n    return result;\n}\n\n// exports = module.exports = readAccessor;\n\n\n/**\n * @file 读取括号表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var readTertiaryExpr = require('./read-tertiary-expr');\n\n/**\n * 读取括号表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readParenthesizedExpr(walker) {\n    walker.go(1);\n    var expr = readTertiaryExpr(walker);\n    walker.goUntil(41); // )\n\n    return expr;\n}\n\n// exports = module.exports = readParenthesizedExpr;\n\n\n/**\n * @file 读取一元表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readString = require('./read-string');\n// var readNumber = require('./read-number');\n// var readAccessor = require('./read-accessor');\n// var readParenthesizedExpr = require('./read-parenthesized-expr');\n\n\n/**\n * 读取一元表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readUnaryExpr(walker) {\n    walker.goUntil();\n\n    switch (walker.currentCode()) {\n        case 33: // !\n            walker.go(1);\n            return {\n                type: ExprType.UNARY,\n                expr: readUnaryExpr(walker)\n            };\n\n        case 34: // \"\n        case 39: // '\n            return readString(walker);\n\n        // number\n        case 45:\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n            return readNumber(walker);\n\n        case 40: // (\n            return readParenthesizedExpr(walker);\n\n        // array literal\n        case 91: // [\n            walker.go(1);\n            var arrItems = [];\n            while (!walker.goUntil(93)) { // ]\n                var item = {};\n                arrItems.push(item);\n\n                if (walker.currentCode() === 46 && walker.match(/\\.\\.\\.\\s*/g)) {\n                    item.spread = true;\n                }\n\n                item.expr = readTertiaryExpr(walker);\n                walker.goUntil(44); // ,\n            }\n\n            return {\n                type: ExprType.ARRAY,\n                items: arrItems\n            };\n\n        // object literal\n        case 123: // {\n            walker.go(1);\n            var objItems = [];\n\n            while (!walker.goUntil(125)) { // }\n                var item = {};\n                objItems.push(item);\n\n                if (walker.currentCode() === 46 && walker.match(/\\.\\.\\.\\s*/g)) {\n                    item.spread = true;\n                    item.expr = readTertiaryExpr(walker);\n                }\n                else {\n                    // #[begin] error\n//                     var walkerIndexBeforeName = walker.index;\n                    // #[end]\n\n                    item.name = readUnaryExpr(walker);\n\n                    // #[begin] error\n//                     if (item.name.type > 4) {\n//                         throw new Error('[SAN FATAL] unexpect object name: ' + walker.cut(walkerIndexBeforeName, walker.index));\n//                     }\n                    // #[end]\n\n                    if (walker.goUntil(58)) { // :\n                        item.expr = readTertiaryExpr(walker)\n                    }\n                    else {\n                        item.expr = item.name;\n                    }\n\n                    if (item.name.type === ExprType.ACCESSOR) {\n                        item.name = item.name.paths[0];\n                    }\n                }\n\n                walker.goUntil(44); // ,\n            }\n\n            return {\n                type: ExprType.OBJECT,\n                items: objItems\n            };\n    }\n\n    return readAccessor(walker);\n}\n\n// exports = module.exports = readUnaryExpr;\n\n\n/**\n * @file 读取乘法表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readUnaryExpr = require('./read-unary-expr');\n\n/**\n * 读取乘法表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readMultiplicativeExpr(walker) {\n    var expr = readUnaryExpr(walker);\n\n    while (1) {\n        walker.goUntil();\n\n        var code = walker.currentCode();\n        switch (code) {\n            case 37: // %\n            case 42: // *\n            case 47: // /\n                walker.go(1);\n                expr = {\n                    type: ExprType.BINARY,\n                    operator: code,\n                    segs: [expr, readUnaryExpr(walker)]\n                };\n                continue;\n        }\n\n        break;\n    }\n\n\n    return expr;\n}\n\n// exports = module.exports = readMultiplicativeExpr;\n\n\n/**\n * @file 读取加法表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readMultiplicativeExpr = require('./read-multiplicative-expr');\n\n\n/**\n * 读取加法表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readAdditiveExpr(walker) {\n    var expr = readMultiplicativeExpr(walker);\n\n    while (1) {\n        walker.goUntil();\n        var code = walker.currentCode();\n\n        switch (code) {\n            case 43: // +\n            case 45: // -\n                walker.go(1);\n                expr = {\n                    type: ExprType.BINARY,\n                    operator: code,\n                    segs: [expr, readMultiplicativeExpr(walker)]\n                };\n                continue;\n        }\n\n        break;\n    }\n\n    return expr;\n}\n\n// exports = module.exports = readAdditiveExpr;\n\n\n/**\n * @file 读取关系判断表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readAdditiveExpr = require('./read-additive-expr');\n\n/**\n * 读取关系判断表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readRelationalExpr(walker) {\n    var expr = readAdditiveExpr(walker);\n    walker.goUntil();\n\n    var code = walker.currentCode();\n    switch (code) {\n        case 60: // <\n        case 62: // >\n            if (walker.nextCode() === 61) {\n                code += 61;\n                walker.go(1);\n            }\n\n            return {\n                type: ExprType.BINARY,\n                operator: code,\n                segs: [expr, readAdditiveExpr(walker)]\n            };\n    }\n\n    return expr;\n}\n\n// exports = module.exports = readRelationalExpr;\n\n\n/**\n * @file 读取相等比对表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readRelationalExpr = require('./read-relational-expr');\n\n/**\n * 读取相等比对表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readEqualityExpr(walker) {\n    var expr = readRelationalExpr(walker);\n    walker.goUntil();\n\n    var code = walker.currentCode();\n    switch (code) {\n        case 61: // =\n        case 33: // !\n            if (walker.nextCode() === 61) {\n                code += 61;\n                if (walker.nextCode() === 61) {\n                    code += 61;\n                    walker.go(1);\n                }\n\n                return {\n                    type: ExprType.BINARY,\n                    operator: code,\n                    segs: [expr, readRelationalExpr(walker)]\n                };\n            }\n\n            walker.go(-1);\n    }\n\n    return expr;\n}\n\n// exports = module.exports = readEqualityExpr;\n\n\n/**\n * @file 读取逻辑与表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readEqualityExpr = require('./read-equality-expr');\n\n/**\n * 读取逻辑与表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readLogicalANDExpr(walker) {\n    var expr = readEqualityExpr(walker);\n    walker.goUntil();\n\n    if (walker.currentCode() === 38) { // &\n        if (walker.nextCode() === 38) {\n            walker.go(1);\n            return {\n                type: ExprType.BINARY,\n                operator: 76,\n                segs: [expr, readLogicalANDExpr(walker)]\n            };\n        }\n\n        walker.go(-1);\n    }\n\n    return expr;\n}\n\n// exports = module.exports = readLogicalANDExpr;\n\n\n/**\n * @file 读取逻辑或表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readLogicalANDExpr = require('./read-logical-and-expr');\n\n/**\n * 读取逻辑或表达式\n *\n * @param {Walker} walker 源码读取对象\n * @return {Object}\n */\nfunction readLogicalORExpr(walker) {\n    var expr = readLogicalANDExpr(walker);\n    walker.goUntil();\n\n    if (walker.currentCode() === 124) { // |\n        if (walker.nextCode() === 124) {\n            walker.go(1);\n            return {\n                type: ExprType.BINARY,\n                operator: 248,\n                segs: [expr, readLogicalORExpr(walker)]\n            };\n        }\n\n        walker.go(-1);\n    }\n\n    return expr;\n}\n\n// exports = module.exports = readLogicalORExpr;\n\n\n/**\n * @file 解析表达式\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var Walker = require('./walker');\n// var readTertiaryExpr = require('./read-tertiary-expr');\n\n/**\n * 解析表达式\n *\n * @param {string} source 源码\n * @return {Object}\n */\nfunction parseExpr(source) {\n    if (typeof source === 'object' && source.type) {\n        return source;\n    }\n\n    var expr = readTertiaryExpr(new Walker(source));\n    expr.raw = source;\n    return expr;\n}\n\n// exports = module.exports = parseExpr;\n\n\n/**\n * @file 读取调用\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('./expr-type');\n// var readAccessor = require('./read-accessor');\n// var readTertiaryExpr = require('./read-tertiary-expr');\n\n/**\n * 读取调用\n *\n * @param {Walker} walker 源码读取对象\n * @param {Array=} defaultArgs 默认参数\n * @return {Object}\n */\nfunction readCall(walker, defaultArgs) {\n    walker.goUntil();\n    var ident = readAccessor(walker);\n    var args = [];\n\n    if (walker.goUntil(40)) { // (\n        while (!walker.goUntil(41)) { // )\n            args.push(readTertiaryExpr(walker));\n            walker.goUntil(44); // ,\n        }\n    }\n    else if (defaultArgs) {\n        args = defaultArgs;\n    }\n\n    return {\n        type: ExprType.CALL,\n        name: ident,\n        args: args\n    };\n}\n\n// exports = module.exports = readCall;\n\n\n/**\n * @file 解析调用\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var Walker = require('./walker');\n// var readCall = require('./read-call');\n\n/**\n * 解析调用\n *\n * @param {string} source 源码\n * @param {Array=} defaultArgs 默认参数\n * @return {Object}\n */\nfunction parseCall(source, defaultArgs) {\n    var expr = readCall(new Walker(source), defaultArgs);\n    expr.raw = source;\n    return expr;\n}\n\n// exports = module.exports = parseCall;\n\n\n/**\n * @file 解析插值替换\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var Walker = require('./walker');\n// var readTertiaryExpr = require('./read-tertiary-expr');\n// var ExprType = require('./expr-type');\n// var readCall = require('./read-call');\n\n/**\n * 解析插值替换\n *\n * @param {string} source 源码\n * @return {Object}\n */\nfunction parseInterp(source) {\n    var walker = new Walker(source);\n\n    var interp = {\n        type: ExprType.INTERP,\n        expr: readTertiaryExpr(walker),\n        filters: [],\n        raw: source\n    };\n\n    while (walker.goUntil(124)) { // |\n        var callExpr = readCall(walker);\n        switch (callExpr.name.paths[0].value) {\n            case 'html':\n                break;\n            case 'raw':\n                interp.original = 1;\n                break;\n            default:\n                interp.filters.push(callExpr);\n        }\n    }\n\n    return interp;\n}\n\n// exports = module.exports = parseInterp;\n\n\n/**\n * @file 解码 HTML 字符实体\n * @author errorrik(errorrik@gmail.com)\n */\n\nvar ENTITY_DECODE_MAP = {\n    lt: '<',\n    gt: '>',\n    nbsp: ' ',\n    quot: '\\\"',\n    emsp: '\\u2003',\n    ensp: '\\u2002',\n    thinsp: '\\u2009',\n    copy: '\\xa9',\n    reg: '\\xae',\n    zwnj: '\\u200c',\n    zwj: '\\u200d',\n    amp: '&'\n};\n\n/**\n * 解码 HTML 字符实体\n *\n * @param {string} source 要解码的字符串\n * @return {string}\n */\nfunction decodeHTMLEntity(source) {\n    return source\n        .replace(/&#([0-9]+);/g, function (match, code) {\n            return String.fromCharCode(+code);\n        })\n        .replace(/&#x([0-9a-f]+);/ig, function (match, code) {\n            return String.fromCharCode(parseInt(code, 16));\n        })\n        .replace(/&([a-z]+);/ig, function (match, code) {\n            return ENTITY_DECODE_MAP[code] || match;\n        });\n}\n\n// exports = module.exports = decodeHTMLEntity;\n\n\n/**\n * @file 解析文本\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var Walker = require('./walker');\n// var ExprType = require('./expr-type');\n// var parseInterp = require('./parse-interp');\n// var decodeHTMLEntity = require('../util/decode-html-entity');\n\n/**\n * 对字符串进行可用于new RegExp的字面化\n *\n * @inner\n * @param {string} source 需要字面化的字符串\n * @return {string} 字符串字面化结果\n */\nfunction regexpLiteral(source) {\n    return source.replace(/[\\^\\[\\]\\$\\(\\)\\{\\}\\?\\*\\.\\+\\\\]/g, function (c) {\n        return '\\\\' + c;\n    });\n}\n\n/**\n * 解析文本\n *\n * @param {string} source 源码\n * @param {Array?} delimiters 分隔符。默认为 ['{{', '}}']\n * @return {Object}\n */\nfunction parseText(source, delimiters) {\n    delimiters = delimiters || ['{{', '}}'];\n    var exprStartReg = new RegExp(\n        regexpLiteral(delimiters[0]) + '\\\\s*([\\\\s\\\\S]+?)\\\\s*' + regexpLiteral(delimiters[1]),\n        'ig'\n    );\n\n    var exprMatch;\n\n    var walker = new Walker(source);\n    var beforeIndex = 0;\n\n    var expr = {\n        type: ExprType.TEXT,\n        segs: []\n    };\n\n    function pushStringToSeg(text) {\n        text && expr.segs.push({\n            type: ExprType.STRING,\n            literal: text,\n            value: decodeHTMLEntity(text)\n        });\n    }\n\n    var delimEndLen = delimiters[1].length;\n    while ((exprMatch = walker.match(exprStartReg)) != null) {\n        var interpSource = exprMatch[1];\n        var interpLen = exprMatch[0].length;\n        if (walker.cut(walker.index + 1 - delimEndLen, walker.index + 1) === delimiters[1]) {\n            interpSource += walker.cut(walker.index, walker.index + 1);\n            walker.go(1);\n            interpLen++;\n        }\n\n        pushStringToSeg(walker.cut(\n            beforeIndex,\n            walker.index - interpLen\n        ));\n\n        var interp = parseInterp(interpSource);\n        expr.original = expr.original || interp.original;\n        expr.segs.push(interp);\n\n        beforeIndex = walker.index;\n    }\n\n    pushStringToSeg(walker.cut(beforeIndex));\n\n\n\n    if (expr.segs.length === 1 && expr.segs[0].type === ExprType.STRING) {\n        expr.value = expr.segs[0].value;\n    }\n\n    return expr;\n}\n\n// exports = module.exports = parseText;\n\n\n/**\n * @file 解析指令\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var Walker = require('./walker');\n// var parseExpr = require('./parse-expr');\n// var parseCall = require('./parse-call');\n// var parseText = require('./parse-text');\n// var readAccessor = require('./read-accessor');\n// var readUnaryExpr = require('./read-unary-expr');\n\n/**\n * 指令解析器\n *\n * @inner\n * @type {Object}\n */\nvar directiveParsers = {\n    'for': function (value) {\n        var walker = new Walker(value);\n        var match = walker.match(/^\\s*([\\$0-9a-z_]+)(\\s*,\\s*([\\$0-9a-z_]+))?\\s+in\\s+/ig, 1);\n\n        if (match) {\n            var directive = {\n                item: parseExpr(match[1]),\n                index: parseExpr(match[3] || '$index'),\n                value: readUnaryExpr(walker)\n            };\n\n            if (walker.match(/\\s+trackby\\s+/ig, 1)) {\n                var start = walker.index;\n                directive.trackBy = readAccessor(walker);\n                directive.trackBy.raw = walker.cut(start, walker.index);\n            }\n            return directive;\n        }\n\n        // #[begin] error\n//         throw new Error('[SAN FATAL] for syntax error: ' + value);\n        // #[end]\n    },\n\n    'ref': function (value, options) {\n        return {\n            value: parseText(value, options.delimiters)\n        };\n    },\n\n    'if': function (value) {\n        return {\n            value: parseExpr(value.replace(/(^\\{\\{|\\}\\}$)/g, ''))\n        };\n    },\n\n    'elif': function (value) {\n        return {\n            value: parseExpr(value.replace(/(^\\{\\{|\\}\\}$)/g, ''))\n        };\n    },\n\n    'else': function (value) {\n        return {\n            value: {}\n        };\n    },\n\n    'bind': function (value) {\n        return {\n            value: parseExpr(value.replace(/(^\\{\\{|\\}\\}$)/g, ''))\n        };\n    },\n\n    'html': function (value) {\n        return {\n            value: parseExpr(value.replace(/(^\\{\\{|\\}\\}$)/g, ''))\n        };\n    },\n\n    'transition': function (value) {\n        return {\n            value: parseCall(value)\n        };\n    }\n};\n\n/**\n * 解析指令\n *\n * @param {ANode} aNode 抽象节点\n * @param {string} name 指令名称\n * @param {string} value 指令值\n * @param {Object} options 解析参数\n * @param {Array?} options.delimiters 插值分隔符列表\n */\nfunction parseDirective(aNode, name, value, options) {\n    if (name === 'else-if') {\n        name = 'elif';\n    }\n\n    var parser = directiveParsers[name];\n    if (parser) {\n        (aNode.directives[name] = parser(value, options)).raw = value;\n    }\n}\n\n// exports = module.exports = parseDirective;\n\n\n/**\n * @file 对属性信息进行处理\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('../parser/expr-type');\n\n/**\n * 对属性信息进行处理\n * 对组件的 binds 或者特殊的属性（比如 input 的 checked）需要处理\n *\n * 扁平化：\n * 当 text 解析只有一项时，要么就是 string，要么就是 interp\n * interp 有可能是绑定到组件属性的表达式，不希望被 eval text 成 string\n * 所以这里做个处理，只有一项时直接抽出来\n *\n * bool属性：\n * 当绑定项没有值时，默认为true\n *\n * @param {Object} prop 属性对象\n */\nfunction postProp(prop) {\n    var expr = prop.expr;\n\n    if (expr.type === ExprType.TEXT) {\n        switch (expr.segs.length) {\n            case 0:\n                prop.expr = {\n                    type: ExprType.BOOL,\n                    value: true\n                };\n                break;\n\n            case 1:\n                expr = prop.expr = expr.segs[0];\n                if (expr.type === ExprType.INTERP && expr.filters.length === 0) {\n                    prop.expr = expr.expr;\n                }\n        }\n    }\n}\n\n// exports = module.exports = postProp;\n\n\n/**\n * @file 解析抽象节点属性\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('../util/each');\n// var kebab2camel = require('../util/kebab2camel');\n// var ExprType = require('./expr-type');\n// var createAccessor = require('./create-accessor');\n// var parseExpr = require('./parse-expr');\n// var parseCall = require('./parse-call');\n// var parseText = require('./parse-text');\n// var parseDirective = require('./parse-directive');\n// var postProp = require('./post-prop');\n\n\n/**\n * 解析抽象节点属性\n *\n * @param {ANode} aNode 抽象节点\n * @param {string} name 属性名称\n * @param {string} value 属性值\n * @param {Object} options 解析参数\n * @param {Array?} options.delimiters 插值分隔符列表\n */\nfunction integrateAttr(aNode, name, value, options) {\n    var prefixIndex = name.indexOf('-');\n    var realName;\n    var prefix;\n\n    if (prefixIndex > 0) {\n        prefix = name.slice(0, prefixIndex);\n        realName = name.slice(prefixIndex + 1);\n    }\n\n    switch (prefix) {\n        case 'on':\n            var event = {\n                name: realName,\n                modifier: {}\n            };\n            aNode.events.push(event);\n\n            var colonIndex;\n            while ((colonIndex = value.indexOf(':')) > 0) {\n                var modifier = value.slice(0, colonIndex);\n\n                // eventHandler(\"dd:aa\") 这种情况不能算modifier，需要辨识\n                if (!/^[a-z]+$/i.test(modifier)) {\n                    break;\n                }\n\n                event.modifier[modifier] = true;\n                value = value.slice(colonIndex + 1);\n            }\n\n            event.expr = parseCall(value, [\n                createAccessor([\n                    { type: ExprType.STRING, value: '$event' }\n                ])\n            ]);\n            break;\n\n        case 'san':\n        case 's':\n            parseDirective(aNode, realName, value, options);\n            break;\n\n        case 'prop':\n            integrateProp(aNode, realName, value, options);\n            break;\n\n        case 'var':\n            if (!aNode.vars) {\n                aNode.vars = [];\n            }\n\n            realName = kebab2camel(realName);\n            aNode.vars.push({\n                name: realName,\n                expr: parseExpr(value.replace(/(^\\{\\{|\\}\\}$)/g, ''))\n            });\n            break;\n\n        default:\n            integrateProp(aNode, name, value, options);\n    }\n}\n\n/**\n * 解析抽象节点绑定属性\n *\n * @inner\n * @param {ANode} aNode 抽象节点\n * @param {string} name 属性名称\n * @param {string} value 属性值\n * @param {Object} options 解析参数\n * @param {Array?} options.delimiters 插值分隔符列表\n */\nfunction integrateProp(aNode, name, value, options) {\n    // parse two way binding, e.g. value=\"{=ident=}\"\n    var xMatch = value.match(/^\\{=\\s*(.*?)\\s*=\\}$/);\n\n    if (xMatch) {\n        aNode.props.push({\n            name: name,\n            expr: parseExpr(xMatch[1]),\n            x: 1,\n            raw: value\n        });\n\n        return;\n    }\n\n    // parse normal prop\n    var prop = {\n        name: name,\n        expr: parseText(value, options.delimiters),\n        raw: value\n    };\n\n    // 这里不能把只有一个插值的属性抽取\n    // 因为插值里的值可能是html片段，容易被注入\n    // 组件的数据绑定在组件init时做抽取\n    switch (name) {\n        case 'class':\n        case 'style':\n            each(prop.expr.segs, function (seg) {\n                if (seg.type === ExprType.INTERP) {\n                    seg.filters.push({\n                        type: ExprType.CALL,\n                        name: createAccessor([\n                            {\n                                type: ExprType.STRING,\n                                value: '_' + prop.name\n                            }\n                        ]),\n                        args: []\n                    });\n                }\n            });\n            break;\n\n        case 'checked':\n            if (aNode.tagName === 'input') {\n                postProp(prop);\n            }\n            break;\n    }\n\n    aNode.props.push(prop);\n}\n\n\n// exports = module.exports = integrateAttr;\n\n\n/**\n * @file 解析模板\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var createANode = require('./create-a-node');\n// var Walker = require('./walker');\n// var integrateAttr = require('./integrate-attr');\n// var parseText = require('./parse-text');\n// var autoCloseTags = require('../browser/auto-close-tags');\n\n// #[begin] error\n// function getXPath(stack, currentTagName) {\n//     var path = ['ROOT'];\n//     for (var i = 1, len = stack.length; i < len; i++) {\n//         path.push(stack[i].tagName);\n//     }\n//     if (currentTagName) {\n//         path.push(currentTagName);\n//     }\n//     return path.join('>');\n// }\n// #[end]\n\n/* eslint-disable fecs-max-statements */\n\n/**\n * 解析 template\n *\n * @param {string} source template源码\n * @param {Object?} options 解析参数\n * @param {string?} options.trimWhitespace 空白文本的处理策略。none|blank|all\n * @param {Array?} options.delimiters 插值分隔符列表\n * @return {ANode}\n */\nfunction parseTemplate(source, options) {\n    options = options || {};\n    options.trimWhitespace = options.trimWhitespace || 'none';\n\n    var rootNode = createANode();\n\n    if (typeof source !== 'string') {\n        return rootNode;\n    }\n\n    source = source.replace(/<!--([\\s\\S]*?)-->/mg, '').replace(/(^\\s+|\\s+$)/g, '');\n    var walker = new Walker(source);\n\n    var tagReg = /<(\\/)?([a-z0-9-]+)\\s*/ig;\n    var attrReg = /([-:0-9a-z\\(\\)\\[\\]]+)(\\s*=\\s*(['\"])([^\\3]*?)\\3)?\\s*/ig;\n\n    var tagMatch;\n    var currentNode = rootNode;\n    var stack = [rootNode];\n    var stackIndex = 0;\n    var beforeLastIndex = 0;\n\n    while ((tagMatch = walker.match(tagReg)) != null) {\n        var tagEnd = tagMatch[1];\n        var tagName = tagMatch[2].toLowerCase();\n\n        pushTextNode(source.slice(\n            beforeLastIndex,\n            walker.index - tagMatch[0].length\n        ));\n\n        // 62: >\n        // 47: /\n        // 处理 </xxxx >\n        if (tagEnd && walker.currentCode() === 62) {\n            // 满足关闭标签的条件时，关闭标签\n            // 向上查找到对应标签，找不到时忽略关闭\n            var closeIndex = stackIndex;\n\n            // #[begin] error\n//             // 如果正在闭合一个自闭合的标签，例如 </input>，报错\n//             if (autoCloseTags[tagName]) {\n//                 throw new Error(''\n//                     + '[SAN ERROR] ' + getXPath(stack, tagName) + ' is a `auto closed` tag, '\n//                     + 'so it cannot be closed with </' + tagName + '>'\n//                 );\n//             }\n// \n//             // 如果关闭的 tag 和当前打开的不一致，报错\n//             if (\n//                 stack[closeIndex].tagName !== tagName\n//                 // 这里要把 table 自动添加 tbody 的情况给去掉\n//                 && !(tagName === 'table' && stack[closeIndex].tagName === 'tbody')\n//             ) {\n//                 throw new Error('[SAN ERROR] ' + getXPath(stack) + ' is closed with ' + tagName);\n//             }\n            // #[end]\n\n            while (closeIndex > 0 && stack[closeIndex].tagName !== tagName) {\n                closeIndex--;\n            }\n\n            if (closeIndex > 0) {\n                stackIndex = closeIndex - 1;\n                currentNode = stack[stackIndex];\n            }\n            walker.go(1);\n        }\n\n        // #[begin] error\n//         // 处理 </xxx 非正常闭合标签\n//         else if (tagEnd) {\n// \n//             // 如果闭合标签时，匹配后的下一个字符是 <，即下一个标签的开始，那么当前闭合标签未闭合\n//             if (walker.currentCode() === 60) {\n//                 throw new Error(''\n//                     + '[SAN ERROR] ' + getXPath(stack)\n//                     + '\\'s close tag not closed'\n//                 );\n//             }\n// \n//             // 闭合标签有属性\n//             throw new Error(''\n//                 + '[SAN ERROR] ' + getXPath(stack)\n//                 + '\\'s close tag has attributes'\n//             );\n// \n//         }\n        // #[end]\n\n        else if (!tagEnd) {\n            var aElement = createANode({\n                tagName: tagName\n            });\n            var tagClose = autoCloseTags[tagName];\n\n            // 解析 attributes\n\n            /* eslint-disable no-constant-condition */\n            while (1) {\n            /* eslint-enable no-constant-condition */\n\n                var nextCharCode = walker.currentCode();\n\n                // 标签结束时跳出 attributes 读取\n                // 标签可能直接结束或闭合结束\n                if (nextCharCode === 62) {\n                    walker.go(1);\n                    break;\n                }\n                // 遇到 /> 按闭合处理\n                else if (nextCharCode === 47\n                    && walker.charCode(walker.index + 1) === 62\n                ) {\n                    walker.go(2);\n                    tagClose = 1;\n                    break;\n                }\n\n                // #[begin] error\n//                 // 在处理一个 open 标签时，如果遇到了 <， 即下一个标签的开始，则当前标签未能正常闭合，报错\n//                 if (nextCharCode === 60) {\n//                     throw new Error('[SAN ERROR] ' + getXPath(stack, tagName) + ' is not closed');\n//                 }\n                // #[end]\n\n                // 读取 attribute\n                var attrMatch = walker.match(attrReg);\n                if (attrMatch) {\n\n                    // #[begin] error\n//                     // 如果属性有 =，但没取到 value，报错\n//                     if (\n//                         walker.charCode(attrMatch.index + attrMatch[1].length) === 61\n//                         && !attrMatch[2]\n//                     ) {\n//                         throw new Error(''\n//                             + '[SAN ERROR] ' + getXPath(stack, tagName) + ' attribute `'\n//                             + attrMatch[1] + '` is not wrapped with \"\"'\n//                         );\n//                     }\n                    // #[end]\n\n                    integrateAttr(\n                        aElement,\n                        attrMatch[1],\n                        attrMatch[2] ? attrMatch[4] : '',\n                        options\n                    );\n                }\n\n            }\n\n            // match if directive for else/elif directive\n            var elseDirective = aElement.directives['else'] || aElement.directives.elif; // eslint-disable-line dot-notation\n            if (elseDirective) {\n                var parentChildrenLen = currentNode.children.length;\n\n                while (parentChildrenLen--) {\n                    var parentChild = currentNode.children[parentChildrenLen];\n                    if (parentChild.textExpr) {\n                        currentNode.children.splice(parentChildrenLen, 1);\n                        continue;\n                    }\n\n                    // #[begin] error\n//                     if (!parentChild.directives['if']) { // eslint-disable-line dot-notation\n//                         throw new Error('[SAN FATEL] else not match if.');\n//                     }\n                    // #[end]\n\n                    parentChild.elses = parentChild.elses || [];\n                    parentChild.elses.push(aElement);\n\n                    break;\n                }\n            }\n            else {\n                if (aElement.tagName === 'tr' && currentNode.tagName === 'table') {\n                    var tbodyNode = createANode({\n                        tagName: 'tbody'\n                    });\n                    currentNode.children.push(tbodyNode);\n                    currentNode = tbodyNode;\n                    stack[++stackIndex] = tbodyNode;\n                }\n\n                currentNode.children.push(aElement);\n            }\n\n            if (!tagClose) {\n                currentNode = aElement;\n                stack[++stackIndex] = aElement;\n            }\n        }\n\n        beforeLastIndex = walker.index;\n    }\n\n    pushTextNode(walker.cut(beforeLastIndex));\n\n    return rootNode;\n\n    /**\n     * 在读取栈中添加文本节点\n     *\n     * @inner\n     * @param {string} text 文本内容\n     */\n    function pushTextNode(text) {\n        switch (options.trimWhitespace) {\n            case 'blank':\n                if (/^\\s+$/.test(text)) {\n                    text = null;\n                }\n                break;\n\n            case 'all':\n                text = text.replace(/(^\\s+|\\s+$)/g, '');\n                break;\n        }\n\n        if (text) {\n            currentNode.children.push(createANode({\n                textExpr: parseText(text, options.delimiters)\n            }));\n        }\n    }\n}\n\n/* eslint-enable fecs-max-statements */\n\n// exports = module.exports = parseTemplate;\n\n\n/**\n * @file 默认filter\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/* eslint-disable fecs-camelcase */\n/* eslint-disable guard-for-in */\n\n/**\n * 默认filter\n *\n * @const\n * @type {Object}\n */\nvar DEFAULT_FILTERS = {\n\n    /**\n     * URL编码filter\n     *\n     * @param {string} source 源串\n     * @return {string} 替换结果串\n     */\n    url: encodeURIComponent,\n\n    _class: function (source) {\n        if (source instanceof Array) {\n            return source.join(' ');\n        }\n\n        return source;\n    },\n\n    _style: function (source) {\n        if (typeof source === 'object') {\n            var result = '';\n            for (var key in source) {\n                result += key + ':' + source[key] + ';';\n            }\n\n            return result;\n        }\n\n        return source;\n    },\n\n    _sep: function (source, sep) {\n        return source ? sep + source : source;\n    }\n};\n/* eslint-enable fecs-camelcase */\n\n// exports = module.exports = DEFAULT_FILTERS;\n\n\n/**\n * @file 表达式计算\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('../parser/expr-type');\n// var extend = require('../util/extend');\n// var DEFAULT_FILTERS = require('./default-filters');\n// var evalArgs = require('./eval-args');\n// var dataCache = require('./data-cache');\n\n/**\n * 计算表达式的值\n *\n * @param {Object} expr 表达式对象\n * @param {Data} data 数据容器对象\n * @param {Component=} owner 所属组件环境\n * @return {*}\n */\nfunction evalExpr(expr, data, owner) {\n    if (expr.value != null) {\n        return expr.value;\n    }\n\n    var value = dataCache.get(data, expr);\n\n    if (value == null) {\n        switch (expr.type) {\n            case ExprType.UNARY:\n                value = !evalExpr(expr.expr, data, owner);\n                break;\n\n            case ExprType.BINARY:\n                var leftValue = evalExpr(expr.segs[0], data, owner);\n                var rightValue = evalExpr(expr.segs[1], data, owner);\n\n                /* eslint-disable eqeqeq */\n                switch (expr.operator) {\n                    case 37:\n                        value = leftValue % rightValue;\n                        break;\n                    case 43:\n                        value = leftValue + rightValue;\n                        break;\n                    case 45:\n                        value = leftValue - rightValue;\n                        break;\n                    case 42:\n                        value = leftValue * rightValue;\n                        break;\n                    case 47:\n                        value = leftValue / rightValue;\n                        break;\n                    case 60:\n                        value = leftValue < rightValue;\n                        break;\n                    case 62:\n                        value = leftValue > rightValue;\n                        break;\n                    case 76:\n                        value = leftValue && rightValue;\n                        break;\n                    case 94:\n                        value = leftValue != rightValue;\n                        break;\n                    case 121:\n                        value = leftValue <= rightValue;\n                        break;\n                    case 122:\n                        value = leftValue == rightValue;\n                        break;\n                    case 123:\n                        value = leftValue >= rightValue;\n                        break;\n                    case 155:\n                        value = leftValue !== rightValue;\n                        break;\n                    case 183:\n                        value = leftValue === rightValue;\n                        break;\n                    case 248:\n                        value = leftValue || rightValue;\n                        break;\n                }\n                /* eslint-enable eqeqeq */\n                break;\n\n            case ExprType.TERTIARY:\n                value = evalExpr(\n                    expr.segs[evalExpr(expr.segs[0], data, owner) ? 1 : 2],\n                    data,\n                    owner\n                );\n                break;\n\n            case ExprType.ARRAY:\n                value = [];\n                for (var i = 0, l = expr.items.length; i < l; i++) {\n                    var item = expr.items[i];\n                    var itemValue = evalExpr(item.expr, data, owner);\n\n                    if (item.spread) {\n                        itemValue && (value = value.concat(itemValue));\n                    }\n                    else {\n                        value.push(itemValue);\n                    }\n                }\n                break;\n\n            case ExprType.OBJECT:\n                value = {};\n                for (var i = 0, l = expr.items.length; i < l; i++) {\n                    var item = expr.items[i];\n                    var itemValue = evalExpr(item.expr, data, owner);\n\n                    if (item.spread) {\n                        itemValue && extend(value, itemValue);\n                    }\n                    else {\n                        value[evalExpr(item.name, data, owner)] = itemValue;\n                    }\n                }\n                break;\n\n            case ExprType.ACCESSOR:\n                value = data.get(expr);\n                break;\n\n            case ExprType.INTERP:\n                value = evalExpr(expr.expr, data, owner);\n\n                if (owner) {\n                    for (var i = 0, l = expr.filters.length; i < l; i++) {\n                        var filter = expr.filters[i];\n                        var filterName = filter.name.paths[0].value;\n\n                        if (owner.filters[filterName]) {\n                            value = owner.filters[filterName].apply(\n                                owner,\n                                [value].concat(evalArgs(filter.args, data, owner))\n                            );\n                        }\n                        else if (DEFAULT_FILTERS[filterName]) {\n                            value = DEFAULT_FILTERS[filterName](\n                                value,\n                                filter.args[0] ? filter.args[0].value : ''\n                            );\n                        }\n                    }\n                }\n\n                if (value == null) {\n                    value = '';\n                }\n\n                break;\n\n            /* eslint-disable no-redeclare */\n            case ExprType.TEXT:\n                var buf = '';\n                for (var i = 0, l = expr.segs.length; i < l; i++) {\n                    var seg = expr.segs[i];\n                    buf += seg.value || evalExpr(seg, data, owner);\n                }\n                return buf;\n        }\n\n        dataCache.set(data, expr, value);\n    }\n\n    return value;\n}\n\n// exports = module.exports = evalExpr;\n\n\n/**\n * @file 为函数调用计算参数数组的值\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var evalExpr = require('./eval-expr');\n\n/**\n * 为函数调用计算参数数组的值\n *\n * @param {Array} args 参数表达式列表\n * @param {Data} data 数据环境\n * @param {Component} owner 组件环境\n * @return {Array}\n */\nfunction evalArgs(args, data, owner) {\n    var result = [];\n    for (var i = 0; i < args.length; i++) {\n        result.push(evalExpr(args[i], data, owner));\n    }\n\n    return result;\n}\n\n// exports = module.exports = evalArgs;\n\n\n/**\n * @file 数据缓存管理器\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n\nvar dataCacheSource = {};\nvar dataCacheClearly = 1;\n\n/**\n * 数据缓存管理器\n *\n * @const\n * @type {Object}\n */\nvar dataCache = {\n    clear: function () {\n        if (!dataCacheClearly) {\n            dataCacheClearly = 1;\n            dataCacheSource = {};\n        }\n    },\n\n    set: function (data, expr, value) {\n        if (expr.raw) {\n            dataCacheClearly = 0;\n            (dataCacheSource[data.id] = dataCacheSource[data.id] || {})[expr.raw] = value;\n        }\n    },\n\n    get: function (data, expr) {\n        if (expr.raw && dataCacheSource[data.id]) {\n            return dataCacheSource[data.id][expr.raw];\n        }\n    }\n};\n\n\n// exports = module.exports = dataCache;\n\n\n/**\n * @file 比较变更表达式与目标表达式之间的关系\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('../parser/expr-type');\n// var evalExpr = require('./eval-expr');\n// var each = require('../util/each');\n\n/**\n * 判断变更表达式与多个表达式之间的关系，0为完全没关系，1为有关系\n *\n * @inner\n * @param {Object} changeExpr 目标表达式\n * @param {Array} exprs 多个源表达式\n * @param {Data} data 表达式所属数据环境\n * @return {number}\n */\nfunction changeExprCompareExprs(changeExpr, exprs, data) {\n    for (var i = 0, l = exprs.length; i < l; i++) {\n        if (changeExprCompare(changeExpr, exprs[i], data)) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * 比较变更表达式与目标表达式之间的关系，用于视图更新判断\n * 视图更新需要根据其关系，做出相应的更新行为\n *\n * 0: 完全没关系\n * 1: 变更表达式是目标表达式的母项(如a与a.b) 或 表示需要完全变化\n * 2: 变更表达式是目标表达式相等\n * >2: 变更表达式是目标表达式的子项，如a.b.c与a.b\n *\n * @param {Object} changeExpr 变更表达式\n * @param {Object} expr 要比较的目标表达式\n * @param {Data} data 表达式所属数据环境\n * @return {number}\n */\nfunction changeExprCompare(changeExpr, expr, data) {\n    switch (expr.type) {\n        case ExprType.ACCESSOR:\n            var paths = expr.paths;\n            var len = paths.length;\n            var changePaths = changeExpr.paths;\n            var changeLen = changePaths.length;\n\n            var result = 1;\n            for (var i = 0; i < len; i++) {\n                var pathExpr = paths[i];\n\n                if (pathExpr.type === ExprType.ACCESSOR\n                    && changeExprCompare(changeExpr, pathExpr, data)\n                ) {\n                    return 1;\n                }\n\n                if (result && i < changeLen\n                    /* eslint-disable eqeqeq */\n                    && (pathExpr.value || evalExpr(pathExpr, data))\n                        != (changePaths[i].value || evalExpr(changePaths[i], data))\n                    /* eslint-enable eqeqeq */\n                ) {\n                    result = 0;\n                }\n            }\n\n            if (result) {\n                result = Math.max(1, changeLen - len + 2);\n            }\n            return result;\n\n        case ExprType.UNARY:\n            return changeExprCompare(changeExpr, expr.expr, data) ? 1 : 0;\n\n\n        case ExprType.TEXT:\n        case ExprType.BINARY:\n        case ExprType.TERTIARY:\n            return changeExprCompareExprs(changeExpr, expr.segs, data);\n\n        case ExprType.ARRAY:\n        case ExprType.OBJECT:\n            for (var i = 0, l = expr.items.length; i < l; i++) {\n                if (changeExprCompare(changeExpr, expr.items[i].expr, data)) {\n                    return 1;\n                }\n            }\n\n            return 0;\n\n        case ExprType.INTERP:\n            if (!changeExprCompare(changeExpr, expr.expr, data)) {\n                var filterResult;\n                each(expr.filters, function (filter) {\n                    filterResult = changeExprCompareExprs(changeExpr, filter.args, data);\n                    return !filterResult;\n                });\n\n                return filterResult ? 1 : 0;\n            }\n\n            return 1;\n    }\n\n    return 0;\n}\n\n// exports = module.exports = changeExprCompare;\n\n\n/**\n * @file 数据变更类型枚举\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 数据变更类型枚举\n *\n * @const\n * @type {Object}\n */\nvar DataChangeType = {\n    SET: 1,\n    SPLICE: 2\n};\n\n// exports = module.exports = DataChangeType;\n\n\n/**\n * @file 生命周期类\n * @author errorrik(errorrik@gmail.com)\n */\n\nfunction lifeCycleOwnIs(name) {\n    return this[name];\n}\n\n/* eslint-disable fecs-valid-var-jsdoc */\n/**\n * 节点生命周期信息\n *\n * @inner\n * @type {Object}\n */\nvar LifeCycle = {\n    start: {},\n\n    compiled: {\n        is: lifeCycleOwnIs,\n        compiled: true\n    },\n\n    inited: {\n        is: lifeCycleOwnIs,\n        compiled: true,\n        inited: true\n    },\n\n    created: {\n        is: lifeCycleOwnIs,\n        compiled: true,\n        inited: true,\n        created: true\n    },\n\n    attached: {\n        is: lifeCycleOwnIs,\n        compiled: true,\n        inited: true,\n        created: true,\n        attached: true\n    },\n\n    leaving: {\n        is: lifeCycleOwnIs,\n        compiled: true,\n        inited: true,\n        created: true,\n        attached: true,\n        leaving: true\n    },\n\n    detached: {\n        is: lifeCycleOwnIs,\n        compiled: true,\n        inited: true,\n        created: true,\n        detached: true\n    },\n\n    disposed: {\n        is: lifeCycleOwnIs,\n        disposed: true\n    }\n};\n/* eslint-enable fecs-valid-var-jsdoc */\n\n\n// exports = module.exports = LifeCycle;\n\n\n/**\n * @file 节点类型\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 节点类型\n *\n * @const\n * @type {Object}\n */\nvar NodeType = {\n    TEXT: 1,\n    IF: 2,\n    FOR: 3,\n    ELEM: 4,\n    CMPT: 5,\n    SLOT: 6,\n    TPL: 7\n};\n\n// exports = module.exports = NodeType;\n\n\n/**\n * @file 获取 ANode props 数组中相应 name 的项\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 获取 ANode props 数组中相应 name 的项\n *\n * @param {Object} aNode ANode对象\n * @param {string} name name属性匹配串\n * @return {Object}\n */\nfunction getANodeProp(aNode, name) {\n    var index = aNode.hotspot.props[name];\n    if (index != null) {\n        return aNode.props[index];\n    }\n}\n\n// exports = module.exports = getANodeProp;\n\n\n/**\n * @file 获取属性处理对象\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var contains = require('../util/contains');\n// var empty = require('../util/empty');\n// var svgTags = require('../browser/svg-tags');\n// var evalExpr = require('../runtime/eval-expr');\n// var getANodeProp = require('./get-a-node-prop');\n// var NodeType = require('./node-type');\n\n\n/**\n * HTML 属性和 DOM 操作属性的对照表\n *\n * @inner\n * @const\n * @type {Object}\n */\nvar HTML_ATTR_PROP_MAP = {\n    'readonly': 'readOnly',\n    'cellpadding': 'cellPadding',\n    'cellspacing': 'cellSpacing',\n    'colspan': 'colSpan',\n    'rowspan': 'rowSpan',\n    'valign': 'vAlign',\n    'usemap': 'useMap',\n    'frameborder': 'frameBorder',\n    'for': 'htmlFor'\n};\n\n/**\n * 默认的元素的属性设置的变换方法\n *\n * @inner\n * @type {Object}\n */\nvar defaultElementPropHandler = {\n    prop: function (el, value, name, element) {\n        var propName = HTML_ATTR_PROP_MAP[name] || name;\n        value = value == null ? '' : value\n\n        // input 的 type 是个特殊属性，其实也应该用 setAttribute\n        // 但是 type 不应该运行时动态改变，否则会有兼容性问题\n        // 所以这里直接就不管了\n        if (propName in el) {\n            el[propName] = value;\n        }\n        else {\n            el.setAttribute(name, value);\n        }\n\n        // attribute 绑定的是 text，所以不会出现 null 的情况，这里无需处理\n        // 换句话来说，san 是做不到 attribute 时有时无的\n        // if (value == null) {\n        //     el.removeAttribute(name);\n        // }\n    },\n\n    output: function (element, bindInfo, data) {\n        data.set(bindInfo.expr, element.el[bindInfo.name], {\n            target: {\n                id: element.id,\n                prop: bindInfo.name\n            }\n        });\n    }\n};\n\nvar svgPropHandler = {\n    prop: function (el, value, name) {\n        el.setAttribute(name, value);\n    }\n};\n\nvar boolPropHandler = {\n    prop: function (el, value, name, element, prop) {\n        var propName = HTML_ATTR_PROP_MAP[name] || name;\n        el[propName] = !!(prop && prop.raw === ''\n            || value && value !== 'false' && value !== '0');\n    }\n};\n\n/* eslint-disable fecs-properties-quote */\n/**\n * 默认的属性设置变换方法\n *\n * @inner\n * @type {Object}\n */\nvar defaultElementPropHandlers = {\n    style: {\n        prop: function (el, value) {\n            el.style.cssText = value;\n        }\n    },\n\n    'class': { // eslint-disable-line\n        prop: function (el, value) {\n            el.className = value;\n        }\n    },\n\n    slot: {\n        prop: empty\n    },\n\n    readonly: boolPropHandler,\n    disabled: boolPropHandler,\n    autofocus: boolPropHandler,\n    required: boolPropHandler,\n    draggable: boolPropHandler\n};\n/* eslint-enable fecs-properties-quote */\n\nvar analInputChecker = {\n    checkbox: contains,\n    radio: function (a, b) {\n        return a === b;\n    }\n};\n\nfunction analInputCheckedState(element, value, oper) {\n    var bindValue = getANodeProp(element.aNode, 'value');\n    var bindType = getANodeProp(element.aNode, 'type');\n\n    if (bindValue && bindType) {\n        var type = evalExpr(bindType.expr, element.scope, element.owner);\n\n        if (analInputChecker[type]) {\n            var bindChecked = getANodeProp(element.aNode, 'checked');\n            if (!bindChecked.hintExpr) {\n                bindChecked.hintExpr = bindValue.expr;\n            }\n\n            return !!analInputChecker[type](\n                value,\n                evalExpr(bindValue.expr, element.scope, element.owner)\n            );\n        }\n    }\n}\n\nvar elementPropHandlers = {\n    input: {\n        multiple: boolPropHandler,\n        checked: {\n            prop: function (el, value, name, element) {\n                var state = analInputCheckedState(element, value);\n\n                boolPropHandler.prop(\n                    el,\n                    state != null ? state : value,\n                    'checked',\n                    element\n                );\n            },\n\n            output: function (element, bindInfo, data) {\n                var el = element.el;\n                var bindValue = getANodeProp(element.aNode, 'value');\n                var bindType = getANodeProp(element.aNode, 'type') || {};\n\n                if (bindValue && bindType) {\n                    switch (bindType.raw) {\n                        case 'checkbox':\n                            data[el.checked ? 'push' : 'remove'](bindInfo.expr, el.value);\n                            return;\n\n                        case 'radio':\n                            el.checked && data.set(bindInfo.expr, el.value, {\n                                target: {\n                                    id: element.id,\n                                    prop: bindInfo.name\n                                }\n                            });\n                            return;\n                    }\n                }\n\n                defaultElementPropHandler.output(element, bindInfo, data);\n            }\n        }\n    },\n\n    option: {\n        value: {\n            prop: function (el, value, name, element) {\n                defaultElementPropHandler.prop(el, value, name, element);\n\n                if (isOptionSelected(element, value)) {\n                    el.selected = true;\n                }\n            }\n        }\n    },\n\n    select: {\n        value: {\n            prop: function (el, value) {\n                el.value = value || '';\n            },\n\n            output: defaultElementPropHandler.output\n        }\n    }\n};\n\nfunction isOptionSelected(element, value) {\n    var parentSelect = element.parent;\n    while (parentSelect) {\n        if (parentSelect.tagName === 'select') {\n            break;\n        }\n\n        parentSelect = parentSelect.parent;\n    }\n\n\n    if (parentSelect) {\n        var selectValue = null;\n        var prop;\n        var expr;\n\n        if ((prop = getANodeProp(parentSelect.aNode, 'value'))\n            && (expr = prop.expr)\n        ) {\n            selectValue = parentSelect.nodeType === NodeType.CMPT\n                ? evalExpr(expr, parentSelect.data, parentSelect)\n                : evalExpr(expr, parentSelect.scope, parentSelect.owner)\n                || '';\n        }\n\n        if (selectValue === value) {\n            return 1;\n        }\n    }\n}\n\n\n/**\n * 获取属性处理对象\n *\n * @param {string} tagName 元素tag\n * @param {string} attrName 属性名\n * @return {Object}\n */\nfunction getPropHandler(tagName, attrName) {\n    if (svgTags[tagName]) {\n        return svgPropHandler;\n    }\n\n    var tagPropHandlers = elementPropHandlers[tagName];\n    if (!tagPropHandlers) {\n        tagPropHandlers = elementPropHandlers[tagName] = {};\n    }\n\n    var propHandler = tagPropHandlers[attrName];\n    if (!propHandler) {\n        propHandler = defaultElementPropHandlers[attrName] || defaultElementPropHandler;\n        tagPropHandlers[attrName] = propHandler;\n    }\n\n    return propHandler;\n}\n\n// exports = module.exports = getPropHandler;\n\n\n/**\n * @file 判断变更是否来源于元素\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 判断变更是否来源于元素，来源于元素时，视图更新需要阻断\n *\n * @param {Object} change 变更对象\n * @param {Element} element 元素\n * @param {string?} propName 属性名，可选。需要精确判断是否来源于此属性时传入\n * @return {boolean}\n */\nfunction isDataChangeByElement(change, element, propName) {\n    var changeTarget = change.option.target;\n    return changeTarget && changeTarget.id === element.id\n        && (!propName || changeTarget.prop === propName);\n}\n\n// exports = module.exports = isDataChangeByElement;\n\n\n/**\n * @file 在对象上使用accessor表达式查找方法\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var evalExpr = require('../runtime/eval-expr');\n\n/**\n * 在对象上使用accessor表达式查找方法\n *\n * @param {Object} source 源对象\n * @param {Object} nameExpr 表达式\n * @param {Data} data 所属数据环境\n * @return {Function}\n */\nfunction findMethod(source, nameExpr, data) {\n    var method = source;\n\n    for (var i = 0; method != null && i < nameExpr.paths.length; i++) {\n        method = method[evalExpr(nameExpr.paths[i], data)];\n    }\n\n    return method;\n}\n\n// exports = module.exports = findMethod;\n\n\n/**\n * @file 数据类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('../parser/expr-type');\n// var evalExpr = require('./eval-expr');\n// var DataChangeType = require('./data-change-type');\n// var createAccessor = require('../parser/create-accessor');\n// var parseExpr = require('../parser/parse-expr');\n// var guid = require('../util/guid');\n// var dataCache = require('./data-cache');\n\n/**\n * 数据类\n *\n * @class\n * @param {Object?} data 初始数据\n * @param {Model?} parent 父级数据容器\n */\nfunction Data(data, parent) {\n    this.id = guid();\n    this.parent = parent;\n    this.raw = data || {};\n    this.listeners = [];\n}\n\n// #[begin] error\n// // 以下两个函数只在开发模式下可用，在生产模式下不存在\n// /**\n//  * DataTypes 检测\n//  */\n// Data.prototype.checkDataTypes = function () {\n//     if (this.typeChecker) {\n//         this.typeChecker(this.raw);\n//     }\n// };\n// \n// /**\n//  * 设置 type checker\n//  *\n//  * @param  {Function} typeChecker 类型校验器\n//  */\n// Data.prototype.setTypeChecker = function (typeChecker) {\n//     this.typeChecker = typeChecker;\n// };\n// \n// #[end]\n\n/**\n * 添加数据变更的事件监听器\n *\n * @param {Function} listener 监听函数\n */\nData.prototype.listen = function (listener) {\n    if (typeof listener === 'function') {\n        this.listeners.push(listener);\n    }\n};\n\n/**\n * 移除数据变更的事件监听器\n *\n * @param {Function} listener 监听函数\n */\nData.prototype.unlisten = function (listener) {\n    var len = this.listeners.length;\n    while (len--) {\n        if (!listener || this.listeners[len] === listener) {\n            this.listeners.splice(len, 1);\n        }\n    }\n};\n\n/**\n * 触发数据变更\n *\n * @param {Object} change 变更信息对象\n */\nData.prototype.fire = function (change) {\n    if (change.option.silent || change.option.silence || change.option.quiet) {\n        return;\n    }\n\n    for (var i = 0; i < this.listeners.length; i++) {\n        this.listeners[i].call(this, change);\n    }\n};\n\n/**\n * 获取数据项\n *\n * @param {string|Object?} expr 数据项路径\n * @param {Data?} callee 当前数据获取的调用环境\n * @return {*}\n */\nData.prototype.get = function (expr, callee) {\n    var value = this.raw;\n    if (!expr) {\n        return value;\n    }\n\n    expr = parseExpr(expr);\n\n    var paths = expr.paths;\n    callee = callee || this;\n\n    value = value[paths[0].value];\n\n    if (value == null && this.parent) {\n        value = this.parent.get(expr, callee);\n    }\n    else {\n        for (var i = 1, l = paths.length; value != null && i < l; i++) {\n            value = value[paths[i].value || evalExpr(paths[i], callee)];\n        }\n    }\n\n    return value;\n};\n\n\n/**\n * 数据对象变更操作\n *\n * @inner\n * @param {Object|Array} source 要变更的源数据\n * @param {Array} exprPaths 属性路径\n * @param {*} value 变更属性值\n * @param {Data} data 对应的Data对象\n * @return {*} 变更后的新数据\n */\nfunction immutableSet(source, exprPaths, value, data) {\n    if (exprPaths.length === 0) {\n        return value;\n    }\n\n    var prop = evalExpr(exprPaths[0], data);\n    var result;\n\n    if (source instanceof Array) {\n        var index = +prop;\n\n        result = source.slice(0);\n        result[isNaN(index) ? prop : index] = immutableSet(source[index], exprPaths.slice(1), value, data);\n\n        return result;\n    }\n    else if (typeof source === 'object') {\n        result = {};\n\n        for (var key in source) {\n            if (key !== prop) {\n                result[key] = source[key];\n            }\n        }\n\n        result[prop] = immutableSet(source[prop] || {}, exprPaths.slice(1), value, data);\n\n        return result;\n    }\n\n    return source;\n}\n\n/**\n * 设置数据项\n *\n * @param {string|Object} expr 数据项路径\n * @param {*} value 数据值\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n */\nData.prototype.set = function (expr, value, option) {\n    option = option || {};\n\n    // #[begin] error\n//     var exprRaw = expr;\n    // #[end]\n\n    expr = parseExpr(expr);\n\n    // #[begin] error\n//     if (expr.type !== ExprType.ACCESSOR) {\n//         throw new Error('[SAN ERROR] Invalid Expression in Data set: ' + exprRaw);\n//     }\n    // #[end]\n\n    if (this.get(expr) === value && !option.force) {\n        return;\n    }\n\n    dataCache.clear();\n    this.raw = immutableSet(this.raw, expr.paths, value, this);\n    this.fire({\n        type: DataChangeType.SET,\n        expr: expr,\n        value: value,\n        option: option\n    });\n\n    // #[begin] error\n//     this.checkDataTypes();\n    // #[end]\n\n};\n\n/**\n * 合并更新数据项\n *\n * @param {string|Object} expr 数据项路径\n * @param {Object} source 待合并的数据值\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n */\nData.prototype.merge = function (expr, source, option) {\n    option = option || {};\n\n    // #[begin] error\n//     var exprRaw = expr;\n    // #[end]\n\n    expr = parseExpr(expr);\n\n    // #[begin] error\n//     if (expr.type !== ExprType.ACCESSOR) {\n//         throw new Error('[SAN ERROR] Invalid Expression in Data merge: ' + exprRaw);\n//     }\n// \n//     if (typeof this.get(expr) !== 'object') {\n//         throw new Error('[SAN ERROR] Merge Expects a Target of Type \\'object\\'; got ' + typeof oldValue);\n//     }\n// \n//     if (typeof source !== 'object') {\n//         throw new Error('[SAN ERROR] Merge Expects a Source of Type \\'object\\'; got ' + typeof source);\n//     }\n    // #[end]\n\n    for (var key in source) { // eslint-disable-line\n        this.set(\n            createAccessor(\n                expr.paths.concat(\n                    [\n                        {\n                            type: ExprType.STRING,\n                            value: key\n                        }\n                    ]\n                )\n            ),\n            source[key],\n            option\n        );\n    }\n};\n\n/**\n * 基于更新函数更新数据项\n *\n * @param {string|Object} expr 数据项路径\n * @param {Function} fn 数据处理函数\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n */\nData.prototype.apply = function (expr, fn, option) {\n    // #[begin] error\n//     var exprRaw = expr;\n    // #[end]\n\n    expr = parseExpr(expr);\n\n    // #[begin] error\n//     if (expr.type !== ExprType.ACCESSOR) {\n//         throw new Error('[SAN ERROR] Invalid Expression in Data apply: ' + exprRaw);\n//     }\n    // #[end]\n\n    var oldValue = this.get(expr);\n\n    // #[begin] error\n//     if (typeof fn !== 'function') {\n//         throw new Error(\n//             '[SAN ERROR] Invalid Argument\\'s Type in Data apply: '\n//             + 'Expected Function but got ' + typeof fn\n//         );\n//     }\n    // #[end]\n\n    this.set(expr, fn(oldValue), option);\n};\n\n/**\n * 数组数据项splice操作\n *\n * @param {string|Object} expr 数据项路径\n * @param {Array} args splice 接受的参数列表，数组项与Array.prototype.splice的参数一致\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n * @return {Array} 新数组\n */\nData.prototype.splice = function (expr, args, option) {\n    option = option || {};\n    // #[begin] error\n//     var exprRaw = expr;\n    // #[end]\n\n    expr = parseExpr(expr);\n\n    // #[begin] error\n//     if (expr.type !== ExprType.ACCESSOR) {\n//         throw new Error('[SAN ERROR] Invalid Expression in Data splice: ' + exprRaw);\n//     }\n    // #[end]\n\n    var target = this.get(expr);\n    var returnValue = [];\n\n    if (target instanceof Array) {\n        var index = args[0];\n        var len = target.length;\n        if (index > len) {\n            index = len;\n        }\n        else if (index < 0) {\n            index = len + index;\n            if (index < 0) {\n                index = 0;\n            }\n        }\n\n        var newArray = target.slice(0);\n        returnValue = newArray.splice.apply(newArray, args);\n        dataCache.clear();\n        this.raw = immutableSet(this.raw, expr.paths, newArray, this);\n\n        this.fire({\n            expr: expr,\n            type: DataChangeType.SPLICE,\n            index: index,\n            deleteCount: returnValue.length,\n            value: returnValue,\n            insertions: args.slice(2),\n            option: option\n        });\n    }\n\n    // #[begin] error\n//     this.checkDataTypes();\n    // #[end]\n\n    return returnValue;\n};\n\n/**\n * 数组数据项push操作\n *\n * @param {string|Object} expr 数据项路径\n * @param {*} item 要push的值\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n * @return {number} 新数组的length属性\n */\nData.prototype.push = function (expr, item, option) {\n    var target = this.get(expr);\n\n    if (target instanceof Array) {\n        this.splice(expr, [target.length, 0, item], option);\n        return target.length + 1;\n    }\n};\n\n/**\n * 数组数据项pop操作\n *\n * @param {string|Object} expr 数据项路径\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n * @return {*}\n */\nData.prototype.pop = function (expr, option) {\n    var target = this.get(expr);\n\n    if (target instanceof Array) {\n        var len = target.length;\n        if (len) {\n            return this.splice(expr, [len - 1, 1], option)[0];\n        }\n    }\n};\n\n/**\n * 数组数据项shift操作\n *\n * @param {string|Object} expr 数据项路径\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n * @return {*}\n */\nData.prototype.shift = function (expr, option) {\n    return this.splice(expr, [0, 1], option)[0];\n};\n\n/**\n * 数组数据项unshift操作\n *\n * @param {string|Object} expr 数据项路径\n * @param {*} item 要unshift的值\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n * @return {number} 新数组的length属性\n */\nData.prototype.unshift = function (expr, item, option) {\n    var target = this.get(expr);\n\n    if (target instanceof Array) {\n        this.splice(expr, [0, 0, item], option);\n        return target.length + 1;\n    }\n};\n\n/**\n * 数组数据项移除操作\n *\n * @param {string|Object} expr 数据项路径\n * @param {number} index 要移除项的索引\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n */\nData.prototype.removeAt = function (expr, index, option) {\n    this.splice(expr, [index, 1], option);\n};\n\n/**\n * 数组数据项移除操作\n *\n * @param {string|Object} expr 数据项路径\n * @param {*} value 要移除的项\n * @param {Object=} option 设置参数\n * @param {boolean} option.silent 静默设置，不触发变更事件\n */\nData.prototype.remove = function (expr, value, option) {\n    var target = this.get(expr);\n\n    if (target instanceof Array) {\n        var len = target.length;\n        while (len--) {\n            if (target[len] === value) {\n                this.splice(expr, [len, 1], option);\n                break;\n            }\n        }\n    }\n};\n\n// exports = module.exports = Data;\n\n\n/**\n * @file 声明式事件的监听函数\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var evalArgs = require('../runtime/eval-args');\n// var findMethod = require('../runtime/find-method');\n// var Data = require('../runtime/data');\n\n/**\n * 声明式事件的监听函数\n *\n * @param {Object} eventBind 绑定信息对象\n * @param {boolean} isComponentEvent 是否组件自定义事件\n * @param {Data} data 数据环境\n * @param {Event} e 事件对象\n */\nfunction eventDeclarationListener(eventBind, isComponentEvent, data, e) {\n    var method = findMethod(this, eventBind.expr.name, data);\n\n    if (typeof method === 'function') {\n        var scope = new Data(\n            {$event: isComponentEvent ? e : e || window.event},\n            data\n        );\n        method.apply(this, evalArgs(eventBind.expr.args, scope, this));\n    }\n}\n\n// exports = module.exports = eventDeclarationListener;\n\n\n/**\n * @file 是否浏览器环境\n * @author errorrik(errorrik@gmail.com)\n */\n\nvar isBrowser = typeof window !== 'undefined';\n\n// exports = module.exports = isBrowser;\n\n\n/**\n * @file insertBefore 方法的兼容性封装\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * insertBefore 方法的兼容性封装\n *\n * @param {HTMLNode} targetEl 要插入的节点\n * @param {HTMLElement} parentEl 父元素\n * @param {HTMLElement?} beforeEl 在此元素之前插入\n */\nfunction insertBefore(targetEl, parentEl, beforeEl) {\n    if (parentEl) {\n        if (beforeEl) {\n            parentEl.insertBefore(targetEl, beforeEl);\n        }\n        else {\n            parentEl.appendChild(targetEl);\n        }\n    }\n}\n\n// exports = module.exports = insertBefore;\n\n\n/**\n * @file 判断元素是否不允许设置HTML\n * @author errorrik(errorrik@gmail.com)\n */\n\n// some html elements cannot set innerHTML in old ie\n// see: https://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx\n\n/**\n * 判断元素是否不允许设置HTML\n *\n * @param {HTMLElement} el 要判断的元素\n * @return {boolean}\n */\nfunction noSetHTML(el) {\n    return /^(col|colgroup|frameset|style|table|tbody|tfoot|thead|tr|select)$/i.test(el.tagName);\n}\n\n// exports = module.exports = noSetHTML;\n\n\n/**\n * @file  获取节点 stump 的 comment\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var noSetHTML = require('../browser/no-set-html');\n\n// #[begin] error\n// /**\n//  * 获取节点 stump 的 comment\n//  *\n//  * @param {HTMLElement} el HTML元素\n//  */\n// function warnSetHTML(el) {\n//     // dont warn if not in browser runtime\n//     if (!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document)) {\n//         return;\n//     }\n// \n//     // some html elements cannot set innerHTML in old ie\n//     // see: https://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx\n//     if (noSetHTML(el)) {\n//         var message = '[SAN WARNING] set html for element \"' + el.tagName\n//             + '\" may cause an error in old IE';\n//         /* eslint-disable no-console */\n//         if (typeof console === 'object' && console.warn) {\n//             console.warn(message);\n//         }\n//         else {\n//             throw new Error(message);\n//         }\n//         /* eslint-enable no-console */\n//     }\n// }\n// #[end]\n\n// exports = module.exports = warnSetHTML;\n\n\n/**\n * @file 判断是否结束桩\n * @author errorrik(errorrik@gmail.com)\n */\n\n// #[begin] reverse\n/**\n * 判断是否结束桩\n *\n * @param {HTMLElement|HTMLComment} target 要判断的元素\n * @param {string} type 桩类型\n * @return {boolean}\n */\nfunction isEndStump(target, type) {\n    return target.nodeType === 8 && target.data === '/s-' + type;\n}\n// #[end]\n\n// exports = module.exports = isEndStump;\n\n\n/**\n * @file 获取节点在组件树中的路径\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var NodeType = require('./node-type');\n\n// #[begin] reverse\n/**\n * 获取节点在组件树中的路径\n *\n * @param {Node} node 节点对象\n * @return {Array}\n */\nfunction getNodePath(node) {\n    var nodePaths = [];\n    var nodeParent = node;\n    while (nodeParent) {\n        switch (nodeParent.nodeType) {\n            case NodeType.ELEM:\n                nodePaths.unshift(nodeParent.tagName);\n                break;\n\n            case NodeType.IF:\n                nodePaths.unshift('if');\n                break;\n\n            case NodeType.FOR:\n                nodePaths.unshift('for[' + nodeParent.anode.directives['for'].raw + ']'); // eslint-disable-line dot-notation\n                break;\n\n            case NodeType.SLOT:\n                nodePaths.unshift('slot[' + (nodeParent.name || 'default') + ']');\n                break;\n\n            case NodeType.TPL:\n                nodePaths.unshift('template');\n                break;\n\n            case NodeType.CMPT:\n                nodePaths.unshift('component[' + (nodeParent.subTag || 'root') + ']');\n                break;\n\n            case NodeType.TEXT:\n                nodePaths.unshift('text');\n                break;\n        }\n\n        nodeParent = nodeParent.parent;\n    }\n\n    return nodePaths;\n}\n// #[end]\n\n// exports = module.exports = getNodePath;\n\n\n/**\n * @file text 节点类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var isBrowser = require('../browser/is-browser');\n// var removeEl = require('../browser/remove-el');\n// var insertBefore = require('../browser/insert-before');\n// var changeExprCompare = require('../runtime/change-expr-compare');\n// var evalExpr = require('../runtime/eval-expr');\n// var NodeType = require('./node-type');\n// var warnSetHTML = require('./warn-set-html');\n// var isEndStump = require('./is-end-stump');\n// var getNodePath = require('./get-node-path');\n\n\n/**\n * text 节点类\n *\n * @param {Object} aNode 抽象节点\n * @param {Component} owner 所属组件环境\n * @param {Model=} scope 所属数据环境\n * @param {Node} parent 父亲节点\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\n */\nfunction TextNode(aNode, owner, scope, parent, reverseWalker) {\n    this.aNode = aNode;\n    this.owner = owner;\n    this.scope = scope;\n    this.parent = parent;\n\n    // #[begin] reverse\n    if (reverseWalker) {\n        var currentNode = reverseWalker.current;\n        if (currentNode) {\n            switch (currentNode.nodeType) {\n                case 8:\n                    if (currentNode.data === 's-text') {\n                        this.sel = currentNode;\n                        currentNode.data = this.id;\n                        reverseWalker.goNext();\n\n                        while (1) { // eslint-disable-line\n                            currentNode = reverseWalker.current;\n                            if (!currentNode) {\n                                throw new Error('[SAN REVERSE ERROR] Text end flag not found. \\nPaths: '\n                                    + getNodePath(this).join(' > '));\n                            }\n\n                            if (isEndStump(currentNode, 'text')) {\n                                this.el = currentNode;\n                                reverseWalker.goNext();\n                                currentNode.data = this.id;\n                                break;\n                            }\n\n                            reverseWalker.goNext();\n                        }\n                    }\n                    break;\n\n                case 3:\n                    reverseWalker.goNext();\n                    if (!this.aNode.textExpr.original) {\n                        this.el = currentNode;\n                    }\n                    break;\n            }\n        }\n        else {\n            this.el = document.createTextNode('');\n            insertBefore(this.el, reverseWalker.target, reverseWalker.current);\n        }\n    }\n    // #[end]\n}\n\nTextNode.prototype.nodeType = NodeType.TEXT;\n\n/**\n * 将text attach到页面\n *\n * @param {HTMLElement} parentEl 要添加到的父元素\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\n */\nTextNode.prototype.attach = function (parentEl, beforeEl) {\n    this.content = evalExpr(this.aNode.textExpr, this.scope, this.owner);\n\n    if (this.aNode.textExpr.original) {\n        this.sel = document.createComment(this.id);\n        insertBefore(this.sel, parentEl, beforeEl);\n\n        this.el = document.createComment(this.id);\n        insertBefore(this.el, parentEl, beforeEl);\n\n        var tempFlag = document.createElement('script');\n        parentEl.insertBefore(tempFlag, this.el);\n        tempFlag.insertAdjacentHTML('beforebegin', this.content);\n        parentEl.removeChild(tempFlag);\n    }\n    else {\n        this.el = document.createTextNode(this.content);\n        insertBefore(this.el, parentEl, beforeEl);\n    }\n};\n\n/**\n * 销毁 text 节点\n */\nTextNode.prototype.dispose = function () {\n    this._prev = null;\n    this.el = null;\n    this.sel = null;\n};\n\nvar textUpdateProp = isBrowser\n    && (typeof document.createTextNode('').textContent === 'string'\n        ? 'textContent'\n        : 'data');\n\n/**\n * 更新 text 节点的视图\n *\n * @param {Array} changes 数据变化信息\n */\nTextNode.prototype._update = function (changes) {\n    if (this.aNode.textExpr.value) {\n        return;\n    }\n\n    var len = changes ? changes.length : 0;\n    while (len--) {\n        if (changeExprCompare(changes[len].expr, this.aNode.textExpr, this.scope)) {\n            var text = evalExpr(this.aNode.textExpr, this.scope, this.owner);\n\n            if (text !== this.content) {\n                this.content = text;\n\n                if (this.aNode.textExpr.original) {\n                    var startRemoveEl = this.sel.nextSibling;\n                    var parentEl = this.el.parentNode;\n\n                    while (startRemoveEl !== this.el) {\n                        var removeTarget = startRemoveEl;\n                        startRemoveEl = startRemoveEl.nextSibling;\n                        removeEl(removeTarget);\n                    }\n\n                    // #[begin] error\n//                     warnSetHTML(parentEl);\n                    // #[end]\n\n                    var tempFlag = document.createElement('script');\n                    parentEl.insertBefore(tempFlag, this.el);\n                    tempFlag.insertAdjacentHTML('beforebegin', text);\n                    parentEl.removeChild(tempFlag);\n                }\n                else {\n                    this.el[textUpdateProp] = text;\n                }\n            }\n\n            return;\n        }\n    }\n};\n\n// exports = module.exports = TextNode;\n\n\n/**\n * @file 计算两个对象 key 的并集\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 计算两个对象 key 的并集\n *\n * @param {Object} obj1 目标对象\n * @param {Object} obj2 源对象\n * @return {Array}\n */\nfunction unionKeys(obj1, obj2) {\n    var result = [];\n\n    for (var key in obj1) {\n        result.push(key);\n    }\n\n    for (var key in obj2) {\n        !obj1[key] && result.push(key);\n    }\n\n    return result;\n}\n\n// exports = module.exports = unionKeys;\n\n\n/**\n * @file 判断变更数组是否影响到数据引用摘要\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/**\n * 判断变更数组是否影响到数据引用摘要\n *\n * @param {Array} changes 变更数组\n * @param {Object} dataRef 数据引用摘要\n * @return {boolean}\n */\nfunction changesIsInDataRef(changes, dataRef) {\n    for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n\n        if (!change.overview) {\n            var paths = change.expr.paths;\n            change.overview = paths[0].value;\n\n            if (paths.length > 1) {\n                change.extOverview = paths[0].value + '.' + paths[1].value;\n                change.wildOverview = paths[0].value + '.*';\n            }\n        }\n\n        if (dataRef[change.overview]\n            || change.wildOverview && dataRef[change.wildOverview]\n            || change.extOverview && dataRef[change.extOverview]\n        ) {\n            return true;\n        }\n    }\n}\n\n// exports = module.exports = changesIsInDataRef;\n\n\n/**\n * @file 元素子节点遍历操作类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var removeEl = require('../browser/remove-el');\n\n// #[begin] reverse\n/**\n * 元素子节点遍历操作类\n *\n * @inner\n * @class\n * @param {HTMLElement} el 要遍历的元素\n */\nfunction DOMChildrenWalker(el) {\n    this.raw = [];\n    this.index = 0;\n    this.target = el;\n\n    var child = el.firstChild;\n    var next;\n    while (child) {\n        next = child.nextSibling;\n\n        switch (child.nodeType) {\n            case 3:\n                if (/^\\s*$/.test(child.data || child.textContent)) {\n                    removeEl(child);\n                }\n                else {\n                    this.raw.push(child);\n                }\n                break;\n\n            case 1:\n            case 8:\n                this.raw.push(child);\n        }\n\n        child = next;\n    }\n\n    this.current = this.raw[this.index];\n    this.next = this.raw[this.index + 1];\n}\n\n/**\n * 往下走一个元素\n */\nDOMChildrenWalker.prototype.goNext = function () {\n    this.current = this.raw[++this.index];\n    this.next = this.raw[this.index + 1];\n};\n// #[end]\n\n// exports = module.exports = DOMChildrenWalker;\n\n\n/**\n * @file 元素节点类\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var each = require('../util/each');\n// var guid = require('../util/guid');\n// var unionKeys = require('../util/union-keys');\n// var removeEl = require('../browser/remove-el');\n// var changeExprCompare = require('../runtime/change-expr-compare');\n// var changesIsInDataRef = require('../runtime/changes-is-in-data-ref');\n// var evalExpr = require('../runtime/eval-expr');\n// var LifeCycle = require('./life-cycle');\n// var NodeType = require('./node-type');\n// var reverseElementChildren = require('./reverse-element-children');\n// var isDataChangeByElement = require('./is-data-change-by-element');\n// var elementUpdateChildren = require('./element-update-children');\n// var elementOwnCreate = require('./element-own-create');\n// var elementOwnAttach = require('./element-own-attach');\n// var elementOwnDetach = require('./element-own-detach');\n// var elementOwnDispose = require('./element-own-dispose');\n// var elementOwnOnEl = require('./element-own-on-el');\n// var elementOwnToPhase = require('./element-own-to-phase');\n// var elementOwnAttached = require('./element-own-attached');\n// var elementDispose = require('./element-dispose');\n// var elementInitTagName = require('./element-init-tag-name');\n// var nodeSBindInit = require('./node-s-bind-init');\n// var nodeSBindUpdate = require('./node-s-bind-update');\n// var handleProp = require('./handle-prop');\n// var warnSetHTML = require('./warn-set-html');\n// var getNodePath = require('./get-node-path');\n\n/**\n * 元素节点类\n *\n * @param {Object} aNode 抽象节点\n * @param {Component} owner 所属组件环境\n * @param {Model=} scope 所属数据环境\n * @param {Node} parent 父亲节点\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\n */\nfunction Element(aNode, owner, scope, parent, reverseWalker) {\n    this.aNode = aNode;\n    this.owner = owner;\n    this.scope = scope;\n    this.parent = parent;\n\n    this.lifeCycle = LifeCycle.start;\n    this.children = [];\n    this._elFns = [];\n    this.parentComponent = parent.nodeType === NodeType.CMPT\n        ? parent\n        : parent.parentComponent;\n\n    this.id = guid();\n\n    elementInitTagName(this);\n\n    nodeSBindInit(this, aNode.directives.bind);\n\n    this._toPhase('inited');\n\n    // #[begin] reverse\n    if (reverseWalker) {\n        var currentNode = reverseWalker.current;\n\n        if (!currentNode) {\n            throw new Error('[SAN REVERSE ERROR] Element not found. \\nPaths: '\n                + getNodePath(this).join(' > '));\n        }\n\n        if (currentNode.nodeType !== 1) {\n            throw new Error('[SAN REVERSE ERROR] Element type not match, expect 1 but '\n                + currentNode.nodeType + '.\\nPaths: '\n                + getNodePath(this).join(' > '));\n        }\n\n        if (currentNode.tagName.toLowerCase() !== this.tagName) {\n            throw new Error('[SAN REVERSE ERROR] Element tagName not match, expect '\n                + this.tagName + ' but meat ' + currentNode.tagName.toLowerCase() + '.\\nPaths: '\n                + getNodePath(this).join(' > '));\n        }\n\n        this.el = currentNode;\n        reverseWalker.goNext();\n\n        reverseElementChildren(this);\n\n        this._attached();\n    }\n    // #[end]\n}\n\n\n\nElement.prototype.nodeType = NodeType.ELEM;\n\n\nElement.prototype.attach = elementOwnAttach;\nElement.prototype.detach = elementOwnDetach;\nElement.prototype.dispose = elementOwnDispose;\nElement.prototype._create = elementOwnCreate;\nElement.prototype._toPhase = elementOwnToPhase;\nElement.prototype._onEl = elementOwnOnEl;\n\nElement.prototype._doneLeave = function () {\n    if (this.leaveDispose) {\n        if (!this.lifeCycle.disposed) {\n            elementDispose(\n                this,\n                this.disposeNoDetach,\n                this.disposeNoTransition\n            );\n        }\n    }\n    else if (this.lifeCycle.attached) {\n        removeEl(this.el);\n        this._toPhase('detached');\n    }\n};\n\n/**\n * 视图更新\n *\n * @param {Array} changes 数据变化信息\n */\nElement.prototype._update = function (changes) {\n    if (!changesIsInDataRef(changes, this.aNode.hotspot.data)) {\n        return;\n    }\n\n    // update s-bind\n    var me = this;\n    nodeSBindUpdate(\n        this,\n        this.aNode.directives.bind,\n        changes,\n        function (name, value) {\n            if (name in me.aNode.hotspot.props) {\n                return;\n            }\n\n            getPropHandler(me.tagName, name).prop(me.el, value, name, me);\n        }\n    );\n\n    // update prop\n    var dynamicProps = this.aNode.hotspot.dynamicProps;\n    for (var i = 0, l = dynamicProps.length; i < l; i++) {\n        var prop = dynamicProps[i];\n\n        for (var j = 0, changeLen = changes.length; j < changeLen; j++) {\n            var change = changes[j];\n\n            if (!isDataChangeByElement(change, this, prop.name)\n                && (\n                    changeExprCompare(change.expr, prop.expr, this.scope)\n                    || prop.hintExpr && changeExprCompare(change.expr, prop.hintExpr, this.scope)\n                )\n            ) {\n                handleProp(this, evalExpr(prop.expr, this.scope, this.owner), prop);\n                break;\n            }\n        }\n    }\n\n    // update content\n    var htmlDirective = this.aNode.directives.html;\n    if (htmlDirective) {\n        var len = changes.length;\n        while (len--) {\n            if (changeExprCompare(changes[len].expr, htmlDirective.value, this.scope)) {\n                // #[begin] error\n//                 warnSetHTML(this.el);\n                // #[end]\n\n                this.el.innerHTML = evalExpr(htmlDirective.value, this.scope, this.owner);\n                return false;\n            }\n        }\n    }\n    else {\n        elementUpdateChildren(this, changes);\n    }\n};\n\n/**\n * 执行完成attached状态的行为\n */\nElement.prototype._attached = elementOwnAttached;\n\n// exports = module.exports = Element;\n\n\n/**\n * @file 销毁节点，清空节点上的无用成员\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/**\n * 销毁节点\n *\n * @param {Object} node 节点对象\n */\nfunction nodeDispose(node) {\n    node.el = null;\n    node.sel = null;\n    node.owner = null;\n    node.scope = null;\n    node.aNode = null;\n    node.parent = null;\n    node.parentComponent = null;\n    node.children = null;\n\n    if (node._toPhase) {\n        node._toPhase('disposed');\n    }\n\n    if (node._ondisposed) {\n        node._ondisposed();\n    }\n}\n\n// exports = module.exports = nodeDispose;\n\n\n/**\n * @file 初始化节点的 s-bind 数据\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var evalExpr = require('../runtime/eval-expr');\n\n/**\n * 初始化节点的 s-bind 数据\n *\n * @param {Object} node 节点对象\n */\nfunction nodeSBindInit(node, sBind) {\n    if (sBind && node.scope) {\n        node._sbindData = evalExpr(sBind.value, node.scope, node.owner);\n        return true;\n    }\n}\n\n// exports = module.exports = nodeSBindInit;\n\n\n/**\n * @file 更新节点的 s-bind 数据\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var unionKeys = require('../util/union-keys');\n// var evalExpr = require('../runtime/eval-expr');\n// var changeExprCompare = require('../runtime/change-expr-compare');\n\n/**\n * 初始化节点的 s-bind 数据\n *\n * @param {Object} node 节点对象\n */\nfunction nodeSBindUpdate(node, sBind, changes, updater) {\n    if (sBind) {\n        var len = changes.length;\n\n        while (len--) {\n            if (changeExprCompare(changes[len].expr, sBind.value, node.scope)) {\n                var newBindData = evalExpr(sBind.value, node.scope, node.owner);\n                var keys = unionKeys(newBindData, node._sbindData);\n\n                for (var i = 0, l = keys.length; i < l; i++) {\n                    var key = keys[i];\n                    var value = newBindData[key];\n\n                    if (value !== node._sbindData[key]) {\n                        updater(key, value);\n                    }\n                }\n\n                node._sbindData = newBindData;\n                break;\n            }\n\n        }\n    }\n}\n\n// exports = module.exports = nodeSBindUpdate;\n\n\n/**\n * @file 通过组件反解创建节点的工厂方法\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var NodeType = require('./node-type');\n// var TextNode = require('./text-node');\n// var Element = require('./element');\n// var SlotNode = require('./slot-node');\n// var ForNode = require('./for-node');\n// var IfNode = require('./if-node');\n// var TemplateNode = require('./template-node');\n\n// #[begin] reverse\n/**\n * 通过组件反解创建节点\n *\n * @param {ANode} aNode 抽象节点\n * @param {DOMChildrenWalker} reverseWalker 子元素遍历对象\n * @param {Node} parent 父亲节点\n * @param {Model=} scope 所属数据环境\n * @return {Node}\n */\nfunction createReverseNode(aNode, reverseWalker, parent, scope) {\n    var parentIsComponent = parent.nodeType === NodeType.CMPT;\n    var owner = parentIsComponent ? parent : (parent.childOwner || parent.owner);\n    scope = scope || (parentIsComponent ? parent.data : (parent.childScope || parent.scope));\n\n    if (aNode.textExpr) {\n        return new TextNode(aNode, owner, scope, parent, reverseWalker);\n    }\n\n    if (aNode.directives['if']) { // eslint-disable-line dot-notation\n        return new IfNode(aNode, owner, scope, parent, reverseWalker);\n    }\n\n    if (aNode.directives['for']) { // eslint-disable-line dot-notation\n        return new ForNode(aNode, owner, scope, parent, reverseWalker);\n    }\n\n    switch (aNode.tagName) {\n        case 'slot':\n            return new SlotNode(aNode, owner, scope, parent, reverseWalker);\n\n        case 'template':\n            return new TemplateNode(aNode, owner, scope, parent, reverseWalker);\n\n        default:\n            var ComponentType = owner.getComponentType\n                ? owner.getComponentType(aNode)\n                : owner.components[aNode.tagName];\n\n            if (ComponentType) {\n                return new ComponentType({\n                    aNode: aNode,\n                    owner: owner,\n                    scope: scope,\n                    parent: parent,\n                    subTag: aNode.tagName,\n                    reverseWalker: reverseWalker\n                });\n            }\n    }\n\n    return new Element(aNode, owner, scope, parent, reverseWalker);\n}\n// #[end]\n\n// exports = module.exports = createReverseNode;\n\n\n/**\n * @file 销毁释放元素的子元素\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 销毁释放元素的子元素\n *\n * @param {Object} element 元素节点\n * @param {boolean=} noDetach 是否不要把节点从dom移除\n * @param {boolean=} noTransition 是否不显示过渡动画效果\n */\nfunction elementDisposeChildren(element, noDetach, noTransition) {\n    var children = element.children;\n    var len = children && children.length;\n    while (len--) {\n        children[len].dispose(noDetach, noTransition);\n    }\n}\n\n// exports = module.exports = elementDisposeChildren;\n\n\n/**\n * @file 更新元素的子元素视图\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n/**\n * 更新元素的子元素视图\n *\n * @param {Object} element 要更新的元素\n * @param {Array} changes 数据变化信息\n */\nfunction elementUpdateChildren(element, changes) {\n    for (var i = 0, l = element.children.length; i < l; i++) {\n        element.children[i]._update(changes);\n    }\n}\n\n// exports = module.exports = elementUpdateChildren;\n\n\n/**\n * @file 使元素节点到达相应的生命周期\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var LifeCycle = require('./life-cycle');\n\n/**\n * 使元素节点到达相应的生命周期\n *\n * @param {string} name 生命周期名称\n */\nfunction elementOwnToPhase(name) {\n    this.lifeCycle = LifeCycle[name] || this.lifeCycle;\n}\n\n// exports = module.exports = elementOwnToPhase;\n\n\n/**\n * @file 创建节点的工厂方法\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var NodeType = require('./node-type');\n// var TextNode = require('./text-node');\n// var Element = require('./element');\n// var SlotNode = require('./slot-node');\n// var ForNode = require('./for-node');\n// var IfNode = require('./if-node');\n// var TemplateNode = require('./template-node');\n\n\n/**\n * 创建节点\n *\n * @param {ANode} aNode 抽象节点\n * @param {Node} parent 父亲节点\n * @param {Model=} scope 所属数据环境\n * @return {Node}\n */\nfunction createNode(aNode, parent, scope) {\n    var parentIsComponent = parent.nodeType === NodeType.CMPT;\n    var owner = parentIsComponent ? parent : (parent.childOwner || parent.owner);\n    scope = scope || (parentIsComponent ? parent.data : (parent.childScope || parent.scope));\n\n\n    if (aNode.textExpr) {\n        return new TextNode(aNode, owner, scope, parent);\n    }\n\n    if (aNode.directives['if']) { // eslint-disable-line dot-notation\n        return new IfNode(aNode, owner, scope, parent);\n    }\n\n    if (aNode.directives['for']) { // eslint-disable-line dot-notation\n        return new ForNode(aNode, owner, scope, parent);\n    }\n\n    switch (aNode.tagName) {\n        case 'slot':\n            return new SlotNode(aNode, owner, scope, parent);\n\n        case 'template':\n            return new TemplateNode(aNode, owner, scope, parent);\n\n        default:\n            var ComponentType = owner.getComponentType\n                ? owner.getComponentType(aNode)\n                : owner.components[aNode.tagName];\n\n            if (ComponentType) {\n                return new ComponentType({\n                    aNode: aNode,\n                    owner: owner,\n                    scope: scope,\n                    parent: parent,\n                    subTag: aNode.tagName\n                });\n            }\n    }\n\n    return new Element(aNode, owner, scope, parent);\n}\n\n// exports = module.exports = createNode;\n\n\n/**\n * @file 生成子元素\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var createNode = require('./create-node');\n\n/**\n * 生成子元素\n *\n * @param {Element} element 元素\n * @param {HTMLElement} parentEl 要添加到的父元素\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\n */\nfunction genElementChildren(element, parentEl, beforeEl) {\n    parentEl = parentEl || element.el;\n\n    var aNodeChildren = element.aNode.children;\n    for (var i = 0; i < aNodeChildren.length; i++) {\n        var child = createNode(aNodeChildren[i], element);\n        element.children.push(child);\n        child.attach(parentEl, beforeEl);\n    }\n}\n\n// exports = module.exports = genElementChildren;\n\n\n/**\n * @file 将没有 root 只有 children 的元素 attach 到页面\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var insertBefore = require('../browser/insert-before');\n// var genElementChildren = require('./gen-element-children');\n\n\n/**\n * 将没有 root 只有 children 的元素 attach 到页面\n * 主要用于 slot 和 template\n *\n * @param {HTMLElement} parentEl 要添加到的父元素\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\n */\nfunction nodeOwnOnlyChildrenAttach(parentEl, beforeEl) {\n    this.sel = document.createComment(this.id);\n    insertBefore(this.sel, parentEl, beforeEl);\n\n    genElementChildren(this, parentEl, beforeEl);\n\n    this.el = document.createComment(this.id);\n    insertBefore(this.el, parentEl, beforeEl);\n\n    this._toPhase('attached');\n}\n\n// exports = module.exports = nodeOwnOnlyChildrenAttach;\n\n\n/**\n * @file slot 节点类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('../util/each');\n// var guid = require('../util/guid');\n// var createANode = require('../parser/create-a-node');\n// var ExprType = require('../parser/expr-type');\n// var createAccessor = require('../parser/create-accessor');\n// var evalExpr = require('../runtime/eval-expr');\n// var Data = require('../runtime/data');\n// var DataChangeType = require('../runtime/data-change-type');\n// var changeExprCompare = require('../runtime/change-expr-compare');\n// var insertBefore = require('../browser/insert-before');\n// var NodeType = require('./node-type');\n// var LifeCycle = require('./life-cycle');\n// var getANodeProp = require('./get-a-node-prop');\n// var nodeDispose = require('./node-dispose');\n// var nodeSBindInit = require('./node-s-bind-init');\n// var nodeSBindUpdate = require('./node-s-bind-update');\n// var createReverseNode = require('./create-reverse-node');\n// var elementDisposeChildren = require('./element-dispose-children');\n// var elementUpdateChildren = require('./element-update-children');\n// var elementOwnToPhase = require('./element-own-to-phase');\n// var nodeOwnOnlyChildrenAttach = require('./node-own-only-children-attach');\n\n\n/**\n * slot 节点类\n *\n * @param {Object} aNode 抽象节点\n * @param {Component} owner 所属组件环境\n * @param {Model=} scope 所属数据环境\n * @param {Node} parent 父亲节点\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\n */\nfunction SlotNode(aNode, owner, scope, parent, reverseWalker) {\n    var realANode = createANode();\n    this.aNode = realANode;\n    this.owner = owner;\n    this.scope = scope;\n    this.parent = parent;\n    this.parentComponent = parent.nodeType === NodeType.CMPT\n        ? parent\n        : parent.parentComponent;\n\n    this.id = guid();\n\n    this.lifeCycle = LifeCycle.start;\n    this.children = [];\n\n    // calc slot name\n    this.nameBind = getANodeProp(aNode, 'name');\n    if (this.nameBind) {\n        this.isNamed = true;\n        this.name = evalExpr(this.nameBind.expr, this.scope, this.owner);\n    }\n\n    // calc aNode children\n    var givenSlots = owner.givenSlots;\n    var givenChildren;\n    if (givenSlots) {\n        givenChildren = this.isNamed ? givenSlots.named[this.name] : givenSlots.noname;\n    }\n\n    if (givenChildren) {\n        this.isInserted = true;\n    }\n\n    realANode.children = givenChildren || aNode.children.slice(0);\n\n    var me = this;\n\n    // calc scoped slot vars\n    realANode.vars = aNode.vars;\n    realANode.directives = aNode.directives;\n\n    var initData;\n    if (nodeSBindInit(this, aNode.directives.bind)) {\n        initData = extend({}, me._sbindData);\n    }\n\n    if (realANode.vars) {\n        initData = initData || {};\n        each(realANode.vars, function (varItem) {\n            initData[varItem.name] = evalExpr(varItem.expr, scope, owner);\n        });\n    }\n\n    // child owner & child scope\n    if (this.isInserted) {\n        this.childOwner = owner.owner;\n        this.childScope = owner.scope;\n    }\n\n    if (initData) {\n        this.isScoped = true;\n        this.childScope = new Data(initData, this.childScope || this.scope);\n    }\n\n\n    owner.slotChildren.push(this);\n\n    // #[begin] reverse\n    if (reverseWalker) {\n\n        this.sel = document.createComment(this.id);\n        insertBefore(this.sel, reverseWalker.target, reverseWalker.current);\n\n        each(this.aNode.children, function (aNodeChild) {\n            me.children.push(createReverseNode(aNodeChild, reverseWalker, me));\n        });\n\n        this.el = document.createComment(this.id);\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\n\n        this._toPhase('attached');\n    }\n    // #[end]\n}\n\nSlotNode.prototype.nodeType = NodeType.SLOT;\n\n/**\n * 销毁释放 slot\n *\n * @param {boolean=} noDetach 是否不要把节点从dom移除\n * @param {boolean=} noTransition 是否不显示过渡动画效果\n */\nSlotNode.prototype.dispose = function (noDetach, noTransition) {\n    this.childOwner = null;\n    this.childScope = null;\n\n    elementDisposeChildren(this, noDetach, noTransition);\n    nodeDispose(this);\n};\n\nSlotNode.prototype.attach = nodeOwnOnlyChildrenAttach;\nSlotNode.prototype._toPhase = elementOwnToPhase;\n\n/**\n * 视图更新函数\n *\n * @param {Array} changes 数据变化信息\n * @param {boolean=} isFromOuter 变化信息是否来源于父组件之外的组件\n * @return {boolean}\n */\nSlotNode.prototype._update = function (changes, isFromOuter) {\n    var me = this;\n\n    if (this.nameBind && evalExpr(this.nameBind.expr, this.scope, this.owner) !== me.name) {\n        this.owner._notifyNeedReload();\n        return false;\n    }\n\n    if (isFromOuter) {\n        if (this.isInserted) {\n            elementUpdateChildren(this, changes);\n        }\n    }\n    else {\n        if (this.isScoped) {\n            var varKeys = {};\n            each(this.aNode.vars, function (varItem) {\n                varKeys[varItem.name] = 1;\n                me.childScope.set(varItem.name, evalExpr(varItem.expr, me.scope, me.owner));\n            });\n\n            var scopedChanges = [];\n\n            nodeSBindUpdate(\n                this,\n                this.aNode.directives.bind,\n                changes,\n                function (name, value) {\n                    if (varKeys[name]) {\n                        return;\n                    }\n\n                    me.childScope.set(name, value);\n                    scopedChanges.push({\n                        type: DataChangeType.SET,\n                        expr: createAccessor([\n                            { type: ExprType.STRING, value: name }\n                        ]),\n                        value: value,\n                        option: {}\n                    });\n                }\n            );\n\n            each(changes, function (change) {\n                if (!me.isInserted) {\n                    scopedChanges.push(change);\n                }\n\n                each(me.aNode.vars, function (varItem) {\n                    var name = varItem.name;\n                    var relation = changeExprCompare(change.expr, varItem.expr, me.scope);\n\n                    if (relation < 1) {\n                        return;\n                    }\n\n                    if (change.type !== DataChangeType.SPLICE) {\n                        scopedChanges.push({\n                            type: DataChangeType.SET,\n                            expr: createAccessor([\n                                {type: ExprType.STRING, value: name}\n                            ]),\n                            value: me.childScope.get(name),\n                            option: change.option\n                        });\n                    }\n                    else if (relation === 2) {\n                        scopedChanges.push({\n                            expr: createAccessor([\n                                {type: ExprType.STRING, value: name}\n                            ]),\n                            type: DataChangeType.SPLICE,\n                            index: change.index,\n                            deleteCount: change.deleteCount,\n                            value: change.value,\n                            insertions: change.insertions,\n                            option: change.option\n                        });\n                    }\n                });\n            });\n\n            elementUpdateChildren(this, scopedChanges);\n        }\n        else if (!this.isInserted) {\n            elementUpdateChildren(this, changes);\n        }\n    }\n};\n\n// exports = module.exports = SlotNode;\n\n\n/**\n * @file 复制指令集合对象\n * @author errorrik(errorrik@gmail.com)\n */\n\n/**\n * 复制指令集合对象\n *\n * @param {Object} source 要复制的指令集合对象\n * @param {Object=} excludes 需要排除的key集合\n * @return {Object}\n */\nfunction cloneDirectives(source, excludes) {\n    var result = {};\n    excludes = excludes || {};\n\n    for (var key in source) {\n        if (!excludes[key]) {\n            result[key] = source[key];\n        }\n    }\n\n    return result;\n}\n\n// exports = module.exports = cloneDirectives;\n\n\n/**\n * @file 简单执行销毁节点的行为\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var removeEl = require('../browser/remove-el');\n// var nodeDispose = require('./node-dispose');\n// var elementDisposeChildren = require('./element-dispose-children');\n\n/**\n * 简单执行销毁节点的行为\n *\n * @param {boolean=} noDetach 是否不要把节点从dom移除\n */\nfunction nodeOwnSimpleDispose(noDetach) {\n    elementDisposeChildren(this, noDetach, 1);\n\n    if (!noDetach) {\n        removeEl(this.el);\n    }\n\n    nodeDispose(this);\n}\n\n// exports = module.exports = nodeOwnSimpleDispose;\n\n\n/**\n * @file 创建节点对应的 stump comment 元素\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n\n/**\n * 创建节点对应的 stump comment 主元素\n */\nfunction nodeOwnCreateStump() {\n    this.el = this.el || document.createComment(this.id);\n}\n\n// exports = module.exports = nodeOwnCreateStump;\n\n\n/**\n * @file for 指令节点类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var inherits = require('../util/inherits');\n// var each = require('../util/each');\n// var guid = require('../util/guid');\n// var createANode = require('../parser/create-a-node');\n// var ExprType = require('../parser/expr-type');\n// var parseExpr = require('../parser/parse-expr');\n// var createAccessor = require('../parser/create-accessor');\n// var cloneDirectives = require('../parser/clone-directives');\n// var Data = require('../runtime/data');\n// var DataChangeType = require('../runtime/data-change-type');\n// var changeExprCompare = require('../runtime/change-expr-compare');\n// var evalExpr = require('../runtime/eval-expr');\n// var changesIsInDataRef = require('../runtime/changes-is-in-data-ref');\n// var removeEl = require('../browser/remove-el');\n// var insertBefore = require('../browser/insert-before');\n// var LifeCycle = require('./life-cycle');\n// var NodeType = require('./node-type');\n// var createNode = require('./create-node');\n// var createReverseNode = require('./create-reverse-node');\n// var nodeOwnSimpleDispose = require('./node-own-simple-dispose');\n// var nodeOwnCreateStump = require('./node-own-create-stump');\n// var elementDisposeChildren = require('./element-dispose-children');\n// var dataCache = require('../runtime/data-cache');\n\n\n/**\n * 循环项的数据容器类\n *\n * @inner\n * @class\n * @param {Object} forElement for元素对象\n * @param {*} item 当前项的数据\n * @param {number} index 当前项的索引\n */\nfunction ForItemData(forElement, item, index) {\n    this.id = guid();\n    this.parent = forElement.scope;\n    this.raw = {};\n    this.listeners = [];\n\n    this.directive = forElement.aNode.directives['for']; // eslint-disable-line dot-notation\n    this.raw[this.directive.item.raw] = item;\n    this.raw[this.directive.index.raw] = index;\n}\n\n/**\n * 将数据操作的表达式，转换成为对parent数据操作的表达式\n * 主要是对item和index进行处理\n *\n * @param {Object} expr 表达式\n * @return {Object}\n */\nForItemData.prototype.exprResolve = function (expr) {\n    var directive = this.directive;\n    var me = this;\n\n    function resolveItem(expr) {\n        if (expr.type === ExprType.ACCESSOR\n            && expr.paths[0].value === directive.item.paths[0].value\n        ) {\n            return createAccessor(\n                directive.value.paths.concat(\n                    {\n                        type: ExprType.NUMBER,\n                        value: me.get(directive.index)\n                    },\n                    expr.paths.slice(1)\n                )\n            );\n        }\n\n        return expr;\n    }\n\n    expr = resolveItem(expr);\n\n    var resolvedPaths = [];\n\n    each(expr.paths, function (item) {\n        resolvedPaths.push(\n            item.type === ExprType.ACCESSOR\n                && item.paths[0].value === directive.index.paths[0].value\n            ? {\n                type: ExprType.NUMBER,\n                value: me.get(directive.index)\n            }\n            : resolveItem(item)\n        );\n    });\n\n    return createAccessor(resolvedPaths);\n};\n\n// 代理数据操作方法\ninherits(ForItemData, Data);\neach(\n    ['set', 'remove', 'unshift', 'shift', 'push', 'pop', 'splice'],\n    function (method) {\n        ForItemData.prototype['_' + method] = Data.prototype[method];\n        ForItemData.prototype[method] = function (expr) {\n            expr = this.exprResolve(parseExpr(expr));\n            dataCache.clear();\n            this.parent[method].apply(\n                this.parent,\n                [expr].concat(Array.prototype.slice.call(arguments, 1))\n            );\n        };\n    }\n);\n\n/**\n * 创建 for 指令元素的子元素\n *\n * @inner\n * @param {ForDirective} forElement for 指令元素对象\n * @param {*} item 子元素对应数据\n * @param {number} index 子元素对应序号\n * @return {Element}\n */\nfunction createForDirectiveChild(forElement, item, index) {\n    var itemScope = new ForItemData(forElement, item, index);\n    return createNode(forElement.itemANode, forElement, itemScope);\n}\n\n/**\n * for 指令节点类\n *\n * @param {Object} aNode 抽象节点\n * @param {Component} owner 所属组件环境\n * @param {Model=} scope 所属数据环境\n * @param {Node} parent 父亲节点\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\n */\nfunction ForNode(aNode, owner, scope, parent, reverseWalker) {\n    this.aNode = aNode;\n    this.owner = owner;\n    this.scope = scope;\n    this.parent = parent;\n    this.parentComponent = parent.nodeType === NodeType.CMPT\n        ? parent\n        : parent.parentComponent;\n\n    this.id = guid();\n    this.children = [];\n\n    this.itemANode = createANode({\n        children: aNode.children,\n        props: aNode.props,\n        events: aNode.events,\n        tagName: aNode.tagName,\n        vars: aNode.vars,\n        hotspot: aNode.hotspot,\n        directives: cloneDirectives(aNode.directives, {\n            'for': 1\n        })\n    });\n\n    this.param = aNode.directives['for']; // eslint-disable-line dot-notation\n\n    // #[begin] reverse\n    if (reverseWalker) {\n        var me = this;\n        this.listData = evalExpr(this.param.value, this.scope, this.owner) || [];\n        each(\n            this.listData,\n            function (item, i) {\n                var itemScope = new ForItemData(me, item, i);\n                var child = createReverseNode(me.itemANode, reverseWalker, me, itemScope);\n                me.children.push(child);\n            }\n        );\n\n        this._create();\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\n    }\n    // #[end]\n}\n\n\nForNode.prototype.nodeType = NodeType.FOR;\nForNode.prototype._create = nodeOwnCreateStump;\nForNode.prototype.dispose = nodeOwnSimpleDispose;\n\n/**\n * 将元素attach到页面的行为\n *\n * @param {HTMLElement} parentEl 要添加到的父元素\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\n */\nForNode.prototype.attach = function (parentEl, beforeEl) {\n    this._create();\n    insertBefore(this.el, parentEl, beforeEl);\n\n    // paint list\n    var el = this.el || parentEl.firstChild;\n    var listData = evalExpr(this.param.value, this.scope, this.owner) || [];\n    var len = listData.length;\n\n    this.listData = listData;\n    for (var i = 0; i < len; i++) {\n        var child = createForDirectiveChild(this, listData[i], i);\n        this.children.push(child);\n        child.attach(parentEl, el);\n    }\n};\n\n/**\n * 将元素从页面上移除的行为\n */\nForNode.prototype.detach = function () {\n    if (this.lifeCycle.attached) {\n        elementDisposeChildren(this);\n        this.children = [];\n        removeEl(this.el);\n        this.lifeCycle = LifeCycle.detached;\n    }\n};\n\n/* eslint-disable fecs-max-statements */\n\n/**\n * 视图更新函数\n *\n * @param {Array} changes 数据变化信息\n */\nForNode.prototype._update = function (changes) {\n\n    var me = this;\n    // 控制列表更新策略是否原样更新的变量\n    var originalUpdate = this.aNode.directives.transition;\n\n\n    var oldChildrenLen = this.children.length;\n    var childrenChanges = new Array(oldChildrenLen);\n\n    function pushToChildrenChanges(change) {\n        for (var i = 0, l = childrenChanges.length; i < l; i++) {\n            (childrenChanges[i] = childrenChanges[i] || []).push(change);\n        }\n    }\n\n    var disposeChildren = [];\n\n\n    // 判断列表是否父元素下唯一的元素\n    // 如果是的话，可以做一些更新优化\n    var parentEl = this.el.parentNode;\n    var parentFirstChild = parentEl.firstChild;\n    var parentLastChild = parentEl.lastChild;\n    var isOnlyParentChild = oldChildrenLen > 0 // 有孩子时\n            && parentFirstChild === this.children[0].el\n            && (parentLastChild === this.el || parentLastChild === this.children[oldChildrenLen - 1].el)\n        || oldChildrenLen === 0 // 无孩子时\n            && parentFirstChild === this.el\n            && parentLastChild === this.el;\n\n    // 控制列表是否整体更新的变量\n    var isChildrenRebuild;\n\n    var newList = evalExpr(this.param.value, this.scope, this.owner) || [];\n    var newLen = newList.length;\n\n    /* eslint-disable no-redeclare */\n    for (var cIndex = 0, cLen = changes.length; cIndex < cLen; cIndex++) {\n        var change = changes[cIndex];\n        var relation = changeExprCompare(change.expr, this.param.value, this.scope);\n\n        if (!relation) {\n            // 无关时，直接传递给子元素更新，列表本身不需要动\n            pushToChildrenChanges(change);\n        }\n        else if (relation > 2) {\n            // 变更表达式是list绑定表达式的子项\n            // 只需要对相应的子项进行更新\n            var changePaths = change.expr.paths;\n            var forLen = this.param.value.paths.length;\n            var changeIndex = +evalExpr(changePaths[forLen], this.scope, this.owner);\n\n            if (isNaN(changeIndex)) {\n                pushToChildrenChanges(change);\n            }\n            else {\n                change = {\n                    type: change.type,\n                    expr: createAccessor(\n                        this.param.item.paths.concat(changePaths.slice(forLen + 1))\n                    ),\n                    value: change.value,\n                    index: change.index,\n                    deleteCount: change.deleteCount,\n                    insertions: change.insertions,\n                    option: change.option\n                };\n\n                (childrenChanges[changeIndex] = childrenChanges[changeIndex] || [])\n                    .push(change);\n\n                if (this.children[changeIndex]) {\n                    if (change.type === DataChangeType.SPLICE) {\n                        this.children[changeIndex].scope._splice(\n                            change.expr,\n                            [].concat(change.index, change.deleteCount, change.insertions),\n                            { silent: 1 }\n                        );\n                    }\n                    else {\n                        this.children[changeIndex].scope._set(\n                            change.expr,\n                            change.value,\n                            { silent: 1 }\n                        );\n                    }\n                }\n            }\n        }\n        else if (change.type !== DataChangeType.SPLICE) {\n            // 变更表达式是list绑定表达式本身或母项的重新设值\n            // 此时需要更新整个列表\n\n            var getItemKey = this.aNode.hotspot.getForKey;\n            if (getItemKey && newLen && oldChildrenLen) {\n                var lcsFlags = [];\n                var newListKeys = [];\n                var oldListKeys = [];\n\n                each(newList, function (item) {\n                    newListKeys.push(getItemKey(item));\n                });\n\n                each(this.listData, function (item) {\n                    oldListKeys.push(getItemKey(item));\n                });\n\n\n                var newIndex;\n                var oldIndex;\n                for (oldIndex = 0; oldIndex <= oldChildrenLen; oldIndex++) {\n                    lcsFlags.push([]);\n\n                    for (newIndex = 0; newIndex <= newLen; newIndex++) {\n                        var lcsFlag = 0;\n                        if (newIndex && oldIndex) {\n                            lcsFlag = newListKeys[newIndex - 1] === oldListKeys[oldIndex - 1]\n                                ? lcsFlags[oldIndex - 1][newIndex - 1] + 1\n                                : Math.max(lcsFlags[oldIndex - 1][newIndex], lcsFlags[oldIndex][newIndex - 1]);\n                        }\n\n                        lcsFlags[oldIndex].push(lcsFlag);\n                    }\n                }\n\n                newIndex--;\n                oldIndex--;\n                while (1) {\n                    if (oldIndex && newIndex && oldListKeys[oldIndex - 1] === newListKeys[newIndex - 1]) {\n                        newIndex--;\n                        oldIndex--;\n\n                        // 如果数据本身引用发生变化，设置变更\n                        if (this.listData[oldIndex] !== newList[newIndex]) {\n                            (childrenChanges[oldIndex] = childrenChanges[oldIndex] || []).push({\n                                type: DataChangeType.SET,\n                                option: change.option,\n                                expr: createAccessor(this.param.item.paths.slice(0)),\n                                value: newList[newIndex]\n                            });\n                        }\n\n                        // 对list更上级数据的直接设置\n                        if (relation < 2) {\n                            (childrenChanges[oldIndex] = childrenChanges[oldIndex] || []).push(change);\n                        }\n                    }\n                    else if (newIndex && (!oldIndex || lcsFlags[oldIndex][newIndex - 1] >= lcsFlags[oldIndex - 1][newIndex])) {\n                        newIndex--;\n                        childrenChanges.splice(oldIndex, 0, 0);\n                        this.children.splice(oldIndex, 0, 0);\n                    }\n                    else if (oldIndex && (!newIndex || lcsFlags[oldIndex][newIndex - 1] < lcsFlags[oldIndex - 1][newIndex])) {\n                        oldIndex--;\n                        disposeChildren.push(this.children[oldIndex]);\n                        childrenChanges.splice(oldIndex, 1);\n                        this.children.splice(oldIndex, 1);\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            else {\n                // 老的比新的多的部分，标记需要dispose\n                if (oldChildrenLen > newLen) {\n                    disposeChildren = disposeChildren.concat(this.children.slice(newLen));\n\n                    childrenChanges = childrenChanges.slice(0, newLen);\n                    this.children = this.children.slice(0, newLen);\n                }\n\n                // 整项变更\n                for (var i = 0; i < newLen; i++) {\n                    (childrenChanges[i] = childrenChanges[i] || []).push({\n                        type: DataChangeType.SET,\n                        option: change.option,\n                        expr: createAccessor(this.param.item.paths.slice(0)),\n                        value: newList[i]\n                    });\n\n                    // 对list更上级数据的直接设置\n                    if (relation < 2) {\n                        childrenChanges[i].push(change);\n                    }\n\n                    if (this.children[i]) {\n                        this.children[i].scope._set(\n                            this.param.item,\n                            newList[i],\n                            {silent: 1}\n                        );\n                    }\n                    else {\n                        this.children[i] = 0;\n                    }\n                }\n            }\n\n            isChildrenRebuild = 1;\n        }\n        else if (relation === 2 && change.type === DataChangeType.SPLICE && !isChildrenRebuild) {\n            // 变更表达式是list绑定表达式本身数组的splice操作\n            // 此时需要删除部分项，创建部分项\n            var changeStart = change.index;\n            var deleteCount = change.deleteCount;\n            var insertionsLen = change.insertions.length;\n            var newCount = insertionsLen - deleteCount;\n\n            if (newCount) {\n                var indexChange = {\n                    type: DataChangeType.SET,\n                    option: change.option,\n                    expr: this.param.index\n                };\n\n                for (var i = changeStart + deleteCount; i < this.children.length; i++) {\n                    (childrenChanges[i] = childrenChanges[i] || []).push(indexChange);\n                    this.children[i] && this.children[i].scope._set(\n                        indexChange.expr,\n                        i - deleteCount + insertionsLen,\n                        {silent: 1}\n                    );\n                }\n            }\n\n            var deleteLen = deleteCount;\n            while (deleteLen--) {\n                if (deleteLen < insertionsLen) {\n                    var i = changeStart + deleteLen;\n                    // update\n                    (childrenChanges[i] = childrenChanges[i] || []).push({\n                        type: DataChangeType.SET,\n                        option: change.option,\n                        expr: createAccessor(this.param.item.paths.slice(0)),\n                        value: change.insertions[deleteLen]\n                    });\n                    if (this.children[i]) {\n                        this.children[i].scope._set(\n                            this.param.item,\n                            change.insertions[deleteLen],\n                            {silent: 1}\n                        );\n                    }\n                }\n            }\n\n            if (newCount < 0) {\n                disposeChildren = disposeChildren.concat(this.children.splice(changeStart + insertionsLen, -newCount));\n                childrenChanges.splice(changeStart + insertionsLen, -newCount);\n            }\n            else if (newCount > 0) {\n                var spliceArgs = [changeStart + deleteCount, 0].concat(new Array(newCount));\n                this.children.splice.apply(this.children, spliceArgs);\n                childrenChanges.splice.apply(childrenChanges, spliceArgs);\n            }\n        }\n    }\n\n    var newChildrenLen = this.children.length;\n\n    // 标记 length 是否发生变化\n    if (newChildrenLen !== oldChildrenLen && this.param.value.paths) {\n        var lengthChange = {\n            type: DataChangeType.SET,\n            option: {},\n            expr: createAccessor(\n                this.param.value.paths.concat({\n                    type: ExprType.STRING,\n                    value: 'length'\n                })\n            )\n        };\n\n        if (changesIsInDataRef([lengthChange], this.aNode.hotspot.data)) {\n            pushToChildrenChanges(lengthChange);\n        }\n    }\n\n    this.listData = newList;\n\n    // 清除应该干掉的 child\n    this._doCreateAndUpdate = doCreateAndUpdate;\n\n    // 这里不用getTransition，getTransition和scope相关，for和forItem的scope是不同的\n    // 所以getTransition结果本身也是不一致的。不如直接判断指令是否存在，如果存在就不进入暴力清除模式\n    // var violentClear = isOnlyParentChild && newChildrenLen === 0 && !elementGetTransition(me);\n    var violentClear = !originalUpdate && isOnlyParentChild && newChildrenLen === 0;\n\n    var disposedChildCount = 0;\n    for (var i = 0; i < disposeChildren.length; i++) {\n        var disposeChild = disposeChildren[i];\n        if (disposeChild) {\n            disposeChild._ondisposed = childDisposed;\n            disposeChild.dispose(violentClear, violentClear);\n        }\n        else {\n            childDisposed();\n        }\n    }\n\n    if (violentClear) {\n        // cloneNode + replaceChild is faster\n        // parentEl.innerHTML = '';\n        var replaceNode = parentEl.cloneNode(false);\n        parentEl.parentNode.replaceChild(replaceNode, parentEl);\n        this.el = document.createComment(this.id);\n        replaceNode.appendChild(this.el);\n    }\n\n    if (disposeChildren.length === 0) {\n        doCreateAndUpdate();\n    }\n\n\n    function childDisposed() {\n        disposedChildCount++;\n        if (disposedChildCount === disposeChildren.length\n            && doCreateAndUpdate === me._doCreateAndUpdate\n        ) {\n            doCreateAndUpdate();\n        }\n    }\n\n    function doCreateAndUpdate() {\n        me._doCreateAndUpdate = null;\n        if (violentClear) {\n            return;\n        }\n\n\n        var beforeEl = me.el;\n\n        // 对相应的项进行更新\n        if (oldChildrenLen === 0 && isOnlyParentChild) {\n            for (var i = 0; i < newChildrenLen; i++) {\n                me.children[i] = createForDirectiveChild(me, newList[i], i);\n                me.children[i].attach(parentEl, beforeEl);\n            }\n        }\n        else {\n            // 如果不attached则直接创建，如果存在则调用更新函数\n            var j = -1;\n            for (var i = 0; i < newChildrenLen; i++) {\n                var child = me.children[i];\n\n                if (child) {\n                    childrenChanges[i] && child._update(childrenChanges[i]);\n                }\n                else {\n                    if (j < i) {\n                        j = i + 1;\n                        beforeEl = null;\n                        while (j < newChildrenLen) {\n                            var nextChild = me.children[j];\n                            if (nextChild) {\n                                beforeEl = nextChild.sel || nextChild.el;\n                                break;\n                            }\n                            j++;\n                        }\n                    }\n\n                    me.children[i] = createForDirectiveChild(me, newList[i], i);\n                    me.children[i].attach(parentEl, beforeEl || me.el);\n                }\n            }\n        }\n    }\n};\n\n\n// exports = module.exports = ForNode;\n\n\n/**\n * @file 清洗条件 aNode\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var createANode = require('../parser/create-a-node');\n// var cloneDirectives = require('../parser/clone-directives');\n\n\n/**\n * 清洗条件 aNode，返回纯净无条件指令的 aNode\n *\n * @param {ANode} aNode 条件节点对象\n * @return {ANode}\n */\nfunction rinseCondANode(aNode) {\n    var clearANode = createANode({\n        children: aNode.children,\n        props: aNode.props,\n        events: aNode.events,\n        tagName: aNode.tagName,\n        vars: aNode.vars,\n        hotspot: aNode.hotspot,\n        directives: cloneDirectives(aNode.directives, {\n            'if': 1,\n            'else': 1,\n            'elif': 1\n        })\n    });\n\n    return clearANode;\n}\n\n// exports = module.exports = rinseCondANode;\n\n\n/**\n * @file if 指令节点类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('../util/each');\n// var guid = require('../util/guid');\n// var insertBefore = require('../browser/insert-before');\n// var evalExpr = require('../runtime/eval-expr');\n// var NodeType = require('./node-type');\n// var rinseCondANode = require('./rinse-cond-anode');\n// var createNode = require('./create-node');\n// var createReverseNode = require('./create-reverse-node');\n// var nodeOwnCreateStump = require('./node-own-create-stump');\n// var elementUpdateChildren = require('./element-update-children');\n// var nodeOwnSimpleDispose = require('./node-own-simple-dispose');\n\n/**\n * if 指令节点类\n *\n * @param {Object} aNode 抽象节点\n * @param {Component} owner 所属组件环境\n * @param {Model=} scope 所属数据环境\n * @param {Node} parent 父亲节点\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\n */\nfunction IfNode(aNode, owner, scope, parent, reverseWalker) {\n    this.aNode = aNode;\n    this.owner = owner;\n    this.scope = scope;\n    this.parent = parent;\n    this.parentComponent = parent.nodeType === NodeType.CMPT\n        ? parent\n        : parent.parentComponent;\n\n    this.id = guid();\n    this.children = [];\n\n    this.cond = this.aNode.directives['if'].value; // eslint-disable-line dot-notation\n\n    // #[begin] reverse\n    if (reverseWalker) {\n        if (evalExpr(this.cond, this.scope, this.owner)) {\n            this.elseIndex = -1;\n            this.children[0] = createReverseNode(\n                rinseCondANode(aNode),\n                reverseWalker,\n                this\n            );\n        }\n        else {\n            var me = this;\n            each(aNode.elses, function (elseANode, index) {\n                var elif = elseANode.directives.elif;\n\n                if (!elif || elif && evalExpr(elif.value, me.scope, me.owner)) {\n                    me.elseIndex = index;\n                    me.children[0] = createReverseNode(\n                        rinseCondANode(elseANode),\n                        reverseWalker,\n                        me\n                    );\n                    return false;\n                }\n            });\n        }\n\n        this._create();\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\n    }\n    // #[end]\n}\n\nIfNode.prototype.nodeType = NodeType.IF;\n\nIfNode.prototype._create = nodeOwnCreateStump;\nIfNode.prototype.dispose = nodeOwnSimpleDispose;\n\nIfNode.prototype.attach = function (parentEl, beforeEl) {\n    var me = this;\n    var elseIndex;\n    var child;\n\n    if (evalExpr(this.cond, this.scope, this.owner)) {\n        child = createNode(rinseCondANode(me.aNode), me);\n        elseIndex = -1;\n    }\n    else {\n        each(me.aNode.elses, function (elseANode, index) {\n            var elif = elseANode.directives.elif;\n\n            if (!elif || elif && evalExpr(elif.value, me.scope, me.owner)) {\n                child = createNode(rinseCondANode(elseANode), me);\n                elseIndex = index;\n                return false;\n            }\n        });\n    }\n\n    if (child) {\n        me.children[0] = child;\n        child.attach(parentEl, beforeEl);\n        me.elseIndex = elseIndex;\n    }\n\n\n    this._create();\n    insertBefore(this.el, parentEl, beforeEl);\n};\n\n\n/**\n * 视图更新函数\n *\n * @param {Array} changes 数据变化信息\n */\nIfNode.prototype._update = function (changes) {\n    var me = this;\n    var childANode = me.aNode;\n    var elseIndex;\n\n    if (evalExpr(this.cond, this.scope, this.owner)) {\n        elseIndex = -1;\n    }\n    else {\n        each(me.aNode.elses, function (elseANode, index) {\n            var elif = elseANode.directives.elif;\n\n            if (elif && evalExpr(elif.value, me.scope, me.owner) || !elif) {\n                elseIndex = index;\n                childANode = elseANode;\n                return false;\n            }\n        });\n    }\n\n    if (elseIndex === me.elseIndex) {\n        elementUpdateChildren(me, changes);\n    }\n    else {\n        var child = me.children[0];\n        me.children = [];\n        if (child) {\n            child._ondisposed = newChild;\n            child.dispose();\n        }\n        else {\n            newChild();\n        }\n\n        me.elseIndex = elseIndex;\n    }\n\n    function newChild() {\n        if (typeof elseIndex !== 'undefined') {\n            var child = createNode(rinseCondANode(childANode), me);\n            // var parentEl = getNodeStumpParent(me);\n            child.attach(me.el.parentNode, me.el);\n\n            me.children[0] = child;\n        }\n    }\n};\n\n// exports = module.exports = IfNode;\n\n\n/**\n * @file template 节点类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('../util/each');\n// var guid = require('../util/guid');\n// var insertBefore = require('../browser/insert-before');\n// var NodeType = require('./node-type');\n// var LifeCycle = require('./life-cycle');\n// var nodeDispose = require('./node-dispose');\n// var createReverseNode = require('./create-reverse-node');\n// var elementDisposeChildren = require('./element-dispose-children');\n// var elementOwnToPhase = require('./element-own-to-phase');\n// var elementUpdateChildren = require('./element-update-children');\n// var nodeOwnOnlyChildrenAttach = require('./node-own-only-children-attach');\n\n/**\n * template 节点类\n *\n * @param {Object} aNode 抽象节点\n * @param {Component} owner 所属组件环境\n * @param {Model=} scope 所属数据环境\n * @param {Node} parent 父亲节点\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\n */\nfunction TemplateNode(aNode, owner, scope, parent, reverseWalker) {\n    this.aNode = aNode;\n    this.owner = owner;\n    this.scope = scope;\n    this.parent = parent;\n    this.parentComponent = parent.nodeType === NodeType.CMPT\n        ? parent\n        : parent.parentComponent;\n\n    this.id = guid();\n    this.lifeCycle = LifeCycle.start;\n    this.children = [];\n\n    // #[begin] reverse\n    if (reverseWalker) {\n        this.sel = document.createComment(this.id);\n        insertBefore(this.sel, reverseWalker.target, reverseWalker.current);\n\n        var me = this;\n        each(this.aNode.children, function (aNodeChild) {\n            me.children.push(createReverseNode(aNodeChild, reverseWalker, me));\n        });\n\n        this.el = document.createComment(this.id);\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\n\n        this._toPhase('attached');\n    }\n    // #[end]\n}\n\n\n\nTemplateNode.prototype.nodeType = NodeType.TPL;\n\nTemplateNode.prototype.attach = nodeOwnOnlyChildrenAttach;\n\n/**\n * 销毁释放\n *\n * @param {boolean=} noDetach 是否不要把节点从dom移除\n * @param {boolean=} noTransition 是否不显示过渡动画效果\n */\nTemplateNode.prototype.dispose = function (noDetach, noTransition) {\n    elementDisposeChildren(this, noDetach, noTransition);\n    nodeDispose(this);\n};\n\n\nTemplateNode.prototype._toPhase = elementOwnToPhase;\n\n/**\n * 视图更新函数\n *\n * @param {Array} changes 数据变化信息\n */\nTemplateNode.prototype._update = function (changes) {\n    elementUpdateChildren(this, changes);\n};\n\n// exports = module.exports = TemplateNode;\n\n\n/**\n * @file 对元素的子节点进行反解\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var each = require('../util/each');\n// var DOMChildrenWalker = require('./dom-children-walker');\n// var createReverseNode = require('./create-reverse-node');\n\n// #[begin] reverse\n\n/**\n * 对元素的子节点进行反解\n *\n * @param {Object} element 元素\n */\nfunction reverseElementChildren(element) {\n    var htmlDirective = element.aNode.directives.html;\n\n    if (!htmlDirective) {\n        var reverseWalker = new DOMChildrenWalker(element.el);\n\n        each(element.aNode.children, function (aNodeChild) {\n            element.children.push(createReverseNode(aNodeChild, reverseWalker, element));\n        });\n    }\n}\n// #[end]\n\n// exports = module.exports = reverseElementChildren;\n\n\n/**\n * @file 处理元素的属性操作\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var getPropHandler = require('./get-prop-handler');\n\n/**\n * 处理元素属性操作\n *\n * @param {Object} element 元素对象\n * @param {*} value 属性值\n * @param {Object} prop 属性信息对象\n */\nfunction handleProp(element, value, prop) {\n    var name = prop.name;\n    getPropHandler(element.tagName, name).prop(element.el, value, name, element, prop);\n}\n\n// exports = module.exports = handleProp;\n\n\n/**\n * @file 创建节点对应的 HTMLElement 主元素\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var evalExpr = require('../runtime/eval-expr');\n// var createEl = require('../browser/create-el');\n// var handleProp = require('./handle-prop');\n// var LifeCycle = require('./life-cycle');\n// var NodeType = require('./node-type');\n\nvar emptyPropWhenCreate = {\n    'class': 1,\n    'style': 1,\n    'id': 1\n};\n\n/**\n * 创建节点对应的 HTMLElement 主元素\n */\nfunction elementOwnCreate() {\n    if (!this.lifeCycle.created) {\n        var isComponent = this.nodeType === NodeType.CMPT;\n        var sourceNode = this.aNode.hotspot.sourceNode;\n        var props = this.aNode.props;\n\n        if (sourceNode) {\n            this.el = sourceNode.cloneNode();\n            props = this.aNode.hotspot.dynamicProps;\n        }\n        else {\n            this.el = createEl(this.tagName);\n        }\n\n        for (var key in this._sbindData) {\n            getPropHandler(this.tagName, key).prop(this.el, this._sbindData[key], key, this);\n        }\n\n        for (var i = 0, l = props.length; i < l; i++) {\n            var prop = props[i];\n            var value = isComponent\n                ? evalExpr(prop.expr, this.data, this)\n                : evalExpr(prop.expr, this.scope, this.owner);\n\n            if (value || !emptyPropWhenCreate[prop.name]) {\n                handleProp(this, value, prop);\n            }\n        }\n\n        this._toPhase('created');\n    }\n}\n\n// exports = module.exports = elementOwnCreate;\n\n\n/**\n * @file 将元素attach到页面\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var createNode = require('./create-node');\n// var evalExpr = require('../runtime/eval-expr');\n// var insertBefore = require('../browser/insert-before');\n\n/**\n * 将元素attach到页面\n *\n * @param {Object} element 元素节点\n * @param {HTMLElement} parentEl 要添加到的父元素\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\n */\nfunction elementAttach(element, parentEl, beforeEl) {\n    element._create();\n    insertBefore(element.el, parentEl, beforeEl);\n\n    if (!element._contentReady) {\n        var htmlDirective = element.aNode.directives.html;\n\n        if (htmlDirective) {\n            element.el.innerHTML = evalExpr(htmlDirective.value, element.scope, element.owner);\n        }\n        else {\n            var aNodeChildren = element.aNode.children;\n            for (var i = 0; i < aNodeChildren.length; i++) {\n                var child = createNode(aNodeChildren[i], element);\n                element.children.push(child);\n                child.attach(element.el);\n            }\n        }\n\n        element._contentReady = 1;\n    }\n}\n\n\n// exports = module.exports = elementAttach;\n\n\n/**\n * @file 将元素attach到页面\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var elementAttach = require('./element-attach');\n\n/**\n * 将元素attach到页面\n *\n * @param {HTMLElement} parentEl 要添加到的父元素\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\n */\nfunction elementOwnAttach(parentEl, beforeEl) {\n    if (!this.lifeCycle.attached) {\n        elementAttach(this, parentEl, beforeEl);\n        this._attached();\n    }\n}\n\n// exports = module.exports = elementOwnAttach;\n\n\n/**\n * @file 获取 element 的 transition 控制对象\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var evalArgs = require('../runtime/eval-args');\n// var findMethod = require('../runtime/find-method');\n// var NodeType = require('./node-type');\n\n/**\n * 获取 element 的 transition 控制对象\n *\n * @param {Object} element 元素\n * @return {Object?}\n */\nfunction elementGetTransition(element) {\n    var directive = element.aNode.directives.transition;\n    var owner = element.owner;\n\n    if (element.nodeType === NodeType.CMPT) {\n        var cmptGivenTransition = element.givenANode && element.givenANode.directives.transition;\n        if (cmptGivenTransition) {\n            directive = cmptGivenTransition;\n        }\n        else {\n            owner = element;\n        }\n    }\n\n    var transition;\n    if (directive && owner) {\n        transition = findMethod(owner, directive.value.name);\n\n        if (typeof transition === 'function') {\n            transition = transition.apply(\n                owner,\n                evalArgs(directive.value.args, element.scope, owner)\n            );\n        }\n    }\n\n    return transition || element.transition;\n}\n\n// exports = module.exports = elementGetTransition;\n\n\n/**\n * @file 元素节点执行leave行为\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var elementGetTransition = require('./element-get-transition');\n\n\n/**\n * 元素节点执行leave行为\n *\n * @param {Object} element 元素\n */\nfunction elementLeave(element) {\n    var lifeCycle = element.lifeCycle;\n    if (lifeCycle.leaving) {\n        return;\n    }\n\n    if (element.disposeNoTransition) {\n        element._doneLeave();\n    }\n    else {\n        var transition = elementGetTransition(element);\n\n        if (transition && transition.leave) {\n            element._toPhase('leaving');\n            transition.leave(element.el, function () {\n                element._doneLeave();\n            });\n        }\n        else {\n            element._doneLeave();\n        }\n    }\n}\n\n// exports = module.exports = elementLeave;\n\n\n/**\n * @file 将元素从页面上移除\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var elementLeave = require('./element-leave');\n\n/**\n * 将元素从页面上移除\n */\nfunction elementOwnDetach() {\n    elementLeave(this);\n}\n\n\n// exports = module.exports = elementOwnDetach;\n\n\n/**\n * @file 销毁释放元素\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var elementLeave = require('./element-leave');\n\n/**\n * 销毁释放元素\n *\n * @param {boolean=} noDetach 是否不要把节点从dom移除\n * @param {boolean=} noTransition 是否不显示过渡动画效果\n */\nfunction elementOwnDispose(noDetach, noTransition) {\n    this.leaveDispose = 1;\n    this.disposeNoDetach = noDetach;\n    this.disposeNoTransition = noTransition;\n\n    elementLeave(this);\n}\n\n// exports = module.exports = elementOwnDispose;\n\n\n/**\n * @file 为元素的 el 绑定事件\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var on = require('../browser/on');\n\n/**\n * 为元素的 el 绑定事件\n *\n * @param {string} name 事件名\n * @param {Function} listener 监听器\n * @param {boolean} capture 是否是捕获阶段触发\n */\nfunction elementOwnOnEl(name, listener, capture) {\n    if (typeof listener === 'function') {\n        capture = !!capture;\n        this._elFns.push([name, listener, capture]);\n        on(this.el, name, listener, capture);\n    }\n}\n\n// exports = module.exports = elementOwnOnEl;\n\n\n/**\n * @file  事件绑定不存在的 warning\n * @author varsha(wangshuonpu@gmail.com)\n */\n\n// var each = require('../util/each');\n\n// #[begin] error\n// /**\n//  * 事件绑定不存在的 warning\n//  *\n//  * @param {Object} eventBind 事件绑定对象\n//  * @param {Component} owner 所属的组件对象\n//  */\n// function warnEventListenMethod(eventBind, owner) {\n//     var valid = true;\n//     var method = owner;\n//     each(eventBind.expr.name.paths, function (path) {\n//         if (!path.value) {\n//             return false;\n//         }\n// \n//         method = method[path.value];\n//         valid = !!method;\n//         return valid;\n//     });\n// \n//     if (!valid) {\n//         var paths = [];\n//         each(eventBind.expr.name.paths, function (path) {\n//             paths.push(path.value);\n//         });\n//         var message = '[SAN WARNING] ' + eventBind.name + ' listen fail,\"' + paths.join('.') + '\" not exist';\n// \n//         /* eslint-disable no-console */\n//         if (typeof console === 'object' && console.warn) {\n//             console.warn(message);\n//         }\n//         else {\n//             throw new Error(message);\n//         }\n//         /* eslint-enable no-console */\n//     }\n// }\n// #[end]\n\n// exports = module.exports = warnEventListenMethod;\n\n\n/**\n * @file 完成元素 attached 后的行为\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var bind = require('../util/bind');\n// var empty = require('../util/empty');\n// var isBrowser = require('../browser/is-browser');\n// var trigger = require('../browser/trigger');\n// var NodeType = require('./node-type');\n// var elementGetTransition = require('./element-get-transition');\n// var eventDeclarationListener = require('./event-declaration-listener');\n// var getPropHandler = require('./get-prop-handler');\n// var warnEventListenMethod = require('./warn-event-listen-method');\n\n/**\n * 双绑输入框CompositionEnd事件监听函数\n *\n * @inner\n */\nfunction inputOnCompositionEnd() {\n    if (!this.composing) {\n        return;\n    }\n\n    this.composing = 0;\n\n    trigger(this, 'input');\n}\n\n/**\n * 双绑输入框CompositionStart事件监听函数\n *\n * @inner\n */\nfunction inputOnCompositionStart() {\n    this.composing = 1;\n}\n\nfunction xPropOutputer(xProp, data) {\n    getPropHandler(this.tagName, xProp.name).output(this, xProp, data);\n}\n\nfunction inputXPropOutputer(element, xProp, data) {\n    var outputer = bind(xPropOutputer, element, xProp, data);\n    return function (e) {\n        if (!this.composing) {\n            outputer(e);\n        }\n    };\n}\n\n/**\n * 完成元素 attached 后的行为\n *\n * @param {Object} element 元素节点\n */\nfunction elementOwnAttached() {\n    this._toPhase('created');\n\n    var isComponent = this.nodeType === NodeType.CMPT;\n    var data = isComponent ? this.data : this.scope;\n\n    /* eslint-disable no-redeclare */\n\n    // 处理自身变化时双向绑定的逻辑\n    var xProps = this.aNode.hotspot.xProps;\n    for (var i = 0, l = xProps.length; i < l; i++) {\n        var xProp = xProps[i];\n\n        switch (xProp.name) {\n            case 'value':\n                switch (this.tagName) {\n                    case 'input':\n                    case 'textarea':\n                        if (isBrowser && window.CompositionEvent) {\n                            this._onEl('change', inputOnCompositionEnd);\n                            this._onEl('compositionstart', inputOnCompositionStart);\n                            this._onEl('compositionend', inputOnCompositionEnd);\n                        }\n\n                        this._onEl(\n                            ('oninput' in this.el) ? 'input' : 'propertychange',\n                            inputXPropOutputer(this, xProp, data)\n                        );\n\n                        break;\n\n                    case 'select':\n                        this._onEl('change', bind(xPropOutputer, this, xProp, data));\n                        break;\n                }\n                break;\n\n            case 'checked':\n                switch (this.tagName) {\n                    case 'input':\n                        switch (this.el.type) {\n                            case 'checkbox':\n                            case 'radio':\n                                this._onEl('click', bind(xPropOutputer, this, xProp, data));\n                        }\n                }\n                break;\n        }\n    }\n\n    // bind events\n    var events = isComponent\n        ? this.aNode.events.concat(this.nativeEvents)\n        : this.aNode.events;\n\n    for (var i = 0, l = events.length; i < l; i++) {\n        var eventBind = events[i];\n        var owner = isComponent ? this : this.owner;\n\n        // 判断是否是nativeEvent，下面的warn方法和事件绑定都需要\n        // 依此指定eventBind.expr.name位于owner还是owner.owner上\n        if (eventBind.modifier.native) {\n            owner = owner.owner;\n            data = this.scope || owner.data;\n        }\n\n        // #[begin] error\n//         warnEventListenMethod(eventBind, owner);\n        // #[end]\n\n        this._onEl(\n            eventBind.name,\n            bind(\n                eventDeclarationListener,\n                owner,\n                eventBind,\n                0,\n                data\n            ),\n            eventBind.modifier.capture\n        );\n    }\n\n    this._toPhase('attached');\n\n\n    if (this._isInitFromEl) {\n        this._isInitFromEl = false;\n    }\n    else {\n        var transition = elementGetTransition(this);\n        if (transition && transition.enter) {\n            transition.enter(this.el, empty);\n        }\n    }\n}\n\n// exports = module.exports = elementOwnAttached;\n\n\n/**\n * @file 销毁元素节点\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var un = require('../browser/un');\n// var removeEl = require('../browser/remove-el');\n// var elementDisposeChildren = require('./element-dispose-children');\n// var nodeDispose = require('./node-dispose');\n\n/**\n * 销毁元素节点\n *\n * @param {Object} element 要销毁的元素节点\n * @param {Object=} options 销毁行为的参数\n */\nfunction elementDispose(element) {\n    elementDisposeChildren(element, 1, 1);\n\n    // el 事件解绑\n    var len = element._elFns.length;\n    while (len--) {\n        var fn = element._elFns[len];\n        un(element.el, fn[0], fn[1], fn[2]);\n    }\n    element._elFns = null;\n\n\n    // 如果没有parent，说明是一个root component，一定要从dom树中remove\n    if (!element.disposeNoDetach || !element.parent) {\n        removeEl(element.el);\n    }\n\n    if (element._toPhase) {\n        element._toPhase('detached');\n    }\n\n    nodeDispose(element);\n}\n\n\n// exports = module.exports = elementDispose;\n\n\n/**\n * @file 初始化 element 节点的 tagName 处理\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ieOldThan9 = require('../browser/ie-old-than-9');\n\n/**\n * 初始化 element 节点的 tagName 处理\n *\n * @param {Object} node 节点对象\n */\nfunction elementInitTagName(node) {\n    node.tagName = node.tagName || node.aNode.tagName || 'div';\n\n    // #[begin] allua\n    // ie8- 不支持innerHTML输出自定义标签\n    if (ieOldThan9 && node.tagName.indexOf('-') > 0) {\n        node.tagName = 'div';\n    }\n    // #[end]\n}\n\n\n// exports = module.exports = elementInitTagName;\n\n\n/**\n * @file 给 devtool 发通知消息\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var isBrowser = require('../browser/is-browser');\n\n// #[begin] devtool\n// var san4devtool;\n// \n// /**\n//  * 给 devtool 发通知消息\n//  *\n//  * @param {string} name 消息名称\n//  * @param {*} arg 消息参数\n//  */\n// function emitDevtool(name, arg) {\n//     if (isBrowser && san4devtool && san4devtool.debug && window.__san_devtool__) {\n//         window.__san_devtool__.emit(name, arg);\n//     }\n// }\n// \n// emitDevtool.start = function (main) {\n//     san4devtool = main;\n//     emitDevtool('san', main);\n// };\n// #[end]\n\n// exports = module.exports = emitDevtool;\n\n\n/**\n * @file 组件类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var bind = require('../util/bind');\n// var each = require('../util/each');\n// var guid = require('../util/guid');\n// var extend = require('../util/extend');\n// var nextTick = require('../util/next-tick');\n// var emitDevtool = require('../util/emit-devtool');\n// var ExprType = require('../parser/expr-type');\n// var parseExpr = require('../parser/parse-expr');\n// var createAccessor = require('../parser/create-accessor');\n// var postProp = require('../parser/post-prop');\n// var removeEl = require('../browser/remove-el');\n// var Data = require('../runtime/data');\n// var evalExpr = require('../runtime/eval-expr');\n// var changeExprCompare = require('../runtime/change-expr-compare');\n// var DataChangeType = require('../runtime/data-change-type');\n// var compileComponent = require('./compile-component');\n// var componentPreheat = require('./component-preheat');\n// var LifeCycle = require('./life-cycle');\n// var getANodeProp = require('./get-a-node-prop');\n// var isDataChangeByElement = require('./is-data-change-by-element');\n// var eventDeclarationListener = require('./event-declaration-listener');\n// var reverseElementChildren = require('./reverse-element-children');\n// var camelComponentBinds = require('./camel-component-binds');\n// var NodeType = require('./node-type');\n// var nodeSBindInit = require('./node-s-bind-init');\n// var nodeSBindUpdate = require('./node-s-bind-update');\n// var elementInitTagName = require('./element-init-tag-name');\n// var elementOwnAttached = require('./element-own-attached');\n// var elementDispose = require('./element-dispose');\n// var elementUpdateChildren = require('./element-update-children');\n// var elementOwnOnEl = require('./element-own-on-el');\n// var elementOwnCreate = require('./element-own-create');\n// var elementOwnAttach = require('./element-own-attach');\n// var elementOwnDetach = require('./element-own-detach');\n// var elementOwnDispose = require('./element-own-dispose');\n// var warnEventListenMethod = require('./warn-event-listen-method');\n// var elementDisposeChildren = require('./element-dispose-children');\n// var elementAttach = require('./element-attach');\n// var handleProp = require('./handle-prop');\n// var createDataTypesChecker = require('../util/create-data-types-checker');\n\n\n\n\n/**\n * 组件类\n *\n * @class\n * @param {Object} options 初始化参数\n */\nfunction Component(options) { // eslint-disable-line\n    options = options || {};\n\n    this.lifeCycle = LifeCycle.start;\n    this.children = [];\n    this._elFns = [];\n    this.listeners = {};\n    this.slotChildren = [];\n\n    var clazz = this.constructor;\n\n    this.filters = this.filters || clazz.filters || {};\n    this.computed = this.computed || clazz.computed || {};\n    this.messages = this.messages || clazz.messages || {};\n\n    if (options.transition) {\n        this.transition = options.transition;\n    }\n\n    this.subTag = options.subTag;\n\n    // compile\n    compileComponent(clazz);\n    componentPreheat(clazz);\n\n    var me = this;\n    var protoANode = clazz.prototype.aNode;\n\n    me.givenANode = options.aNode;\n    me.givenNamedSlotBinds = [];\n    me.givenSlots = {\n        named: {}\n    };\n\n    this.owner = options.owner;\n    this.scope = options.scope;\n    this.el = options.el;\n\n    var parent = options.parent;\n    if (parent) {\n        this.parent = parent;\n        this.parentComponent = parent.nodeType === NodeType.CMPT\n            ? parent\n            : parent && parent.parentComponent;\n    }\n\n    this.id = guid();\n\n    // #[begin] reverse\n    if (this.el) {\n        var firstCommentNode = this.el.firstChild;\n        if (firstCommentNode.nodeType === 3) {\n            firstCommentNode = firstCommentNode.nextSibling;\n        }\n\n        if (firstCommentNode && firstCommentNode.nodeType === 8) {\n            var stumpMatch = firstCommentNode.data.match(/^\\s*s-data:([\\s\\S]+)?$/);\n            if (stumpMatch) {\n                var stumpText = stumpMatch[1];\n\n                // fill component data\n                options.data = (new Function(\n                    'return ' + stumpText.replace(/^[\\s\\n]*/, '')\n                ))();\n\n                if (firstCommentNode.previousSibling) {\n                    removeEl(firstCommentNode.previousSibling);\n                }\n                removeEl(firstCommentNode);\n            }\n        }\n    }\n    // #[end]\n\n    // native事件数组\n    this.nativeEvents = [];\n\n    if (this.givenANode) {\n        // 组件运行时传入的结构，做slot解析\n        this._createGivenSlots();\n\n        each(this.givenANode.events, function (eventBind) {\n            // 保存当前实例的native事件，下面创建aNode时候做合并\n            if (eventBind.modifier.native) {\n                me.nativeEvents.push(eventBind);\n                return;\n            }\n\n            // #[begin] error\n//             warnEventListenMethod(eventBind, options.owner);\n            // #[end]\n\n            me.on(\n                eventBind.name,\n                bind(eventDeclarationListener, options.owner, eventBind, 1, options.scope),\n                eventBind\n            );\n        });\n\n        this.tagName = protoANode.tagName || me.givenANode.tagName;\n        this.binds = camelComponentBinds(this.givenANode.props);\n\n        // init s-bind data\n        nodeSBindInit(this, this.givenANode.directives.bind);\n    }\n\n    this._toPhase('compiled');\n\n    // init data\n    this.data = new Data(\n        extend(\n            typeof this.initData === 'function' && this.initData() || {},\n            options.data || this._sbindData\n        )\n    );\n\n    elementInitTagName(this);\n\n    each(this.binds, function (bind) {\n        postProp(bind);\n\n        if (me.scope) {\n            var value = evalExpr(bind.expr, me.scope, me.owner);\n            if (typeof value !== 'undefined') {\n                // See: https://github.com/ecomfe/san/issues/191\n                me.data.set(bind.name, value);\n            }\n        }\n    });\n\n    // #[begin] error\n//     // 在初始化 + 数据绑定后，开始数据校验\n//     // NOTE: 只在开发版本中进行属性校验\n//     var dataTypes = this.dataTypes || clazz.dataTypes;\n//     if (dataTypes) {\n//         var dataTypeChecker = createDataTypesChecker(\n//             dataTypes,\n//             this.subTag || this.name || clazz.name\n//         );\n//         this.data.setTypeChecker(dataTypeChecker);\n//         this.data.checkDataTypes();\n//     }\n    // #[end]\n\n    this.computedDeps = {};\n    /* eslint-disable guard-for-in */\n    for (var expr in this.computed) {\n        if (!this.computedDeps[expr]) {\n            this._calcComputed(expr);\n        }\n    }\n    /* eslint-enable guard-for-in */\n\n    if (!this.dataChanger) {\n        this.dataChanger = bind(this._dataChanger, this);\n        this.data.listen(this.dataChanger);\n    }\n    this._toPhase('inited');\n\n    // #[begin] reverse\n    if (this.el) {\n        reverseElementChildren(this);\n        this._attached();\n    }\n\n    var walker = options.reverseWalker;\n    if (walker) {\n        var currentNode = walker.current;\n        if (currentNode && currentNode.nodeType === 1) {\n            this.el = currentNode;\n            walker.goNext();\n        }\n\n        reverseElementChildren(this);\n\n        this._attached();\n    }\n    // #[end]\n}\n\n\n/**\n * 初始化创建组件外部传入的插槽对象\n *\n * @protected\n */\nComponent.prototype._createGivenSlots = function () {\n    var me = this;\n    me.givenSlots.named = {};\n\n    // 组件运行时传入的结构，做slot解析\n    me.givenANode && me.scope && each(me.givenANode.children, function (child) {\n        var target;\n\n        var slotBind = !child.textExpr && getANodeProp(child, 'slot');\n        if (slotBind) {\n            !me.givenSlotInited && me.givenNamedSlotBinds.push(slotBind);\n\n            var slotName = evalExpr(slotBind.expr, me.scope, me.owner);\n            target = me.givenSlots.named[slotName];\n            if (!target) {\n                target = me.givenSlots.named[slotName] = [];\n            }\n        }\n        else if (!me.givenSlotInited) {\n            target = me.givenSlots.noname;\n            if (!target) {\n                target = me.givenSlots.noname = [];\n            }\n        }\n\n        target && target.push(child);\n    });\n\n    me.givenSlotInited = true;\n};\n\n/**\n * 类型标识\n *\n * @type {string}\n */\nComponent.prototype.nodeType = NodeType.CMPT;\n\n/**\n * 在下一个更新周期运行函数\n *\n * @param {Function} fn 要运行的函数\n */\nComponent.prototype.nextTick = nextTick;\n\n/* eslint-disable operator-linebreak */\n/**\n * 使节点到达相应的生命周期\n *\n * @protected\n * @param {string} name 生命周期名称\n */\nComponent.prototype._callHook =\nComponent.prototype._toPhase = function (name) {\n    if (!this.lifeCycle[name]) {\n        this.lifeCycle = LifeCycle[name] || this.lifeCycle;\n        if (typeof this[name] === 'function') {\n            this[name]();\n        }\n        this['_after' + name] = 1;\n\n        // 通知devtool\n        // #[begin] devtool\n//         emitDevtool('comp-' + name, this);\n        // #[end]\n    }\n};\n/* eslint-enable operator-linebreak */\n\n\n/**\n * 添加事件监听器\n *\n * @param {string} name 事件名\n * @param {Function} listener 监听器\n * @param {string?} declaration 声明式\n */\nComponent.prototype.on = function (name, listener, declaration) {\n    if (typeof listener === 'function') {\n        if (!this.listeners[name]) {\n            this.listeners[name] = [];\n        }\n        this.listeners[name].push({fn: listener, declaration: declaration});\n    }\n};\n\n/**\n * 移除事件监听器\n *\n * @param {string} name 事件名\n * @param {Function=} listener 监听器\n */\nComponent.prototype.un = function (name, listener) {\n    var nameListeners = this.listeners[name];\n    var len = nameListeners && nameListeners.length;\n\n    while (len--) {\n        if (!listener || listener === nameListeners[len].fn) {\n            nameListeners.splice(len, 1);\n        }\n    }\n};\n\n\n/**\n * 派发事件\n *\n * @param {string} name 事件名\n * @param {Object} event 事件对象\n */\nComponent.prototype.fire = function (name, event) {\n    var me = this;\n    each(this.listeners[name], function (listener) {\n        listener.fn.call(me, event);\n    });\n};\n\n/**\n * 计算 computed 属性的值\n *\n * @private\n * @param {string} computedExpr computed表达式串\n */\nComponent.prototype._calcComputed = function (computedExpr) {\n    var computedDeps = this.computedDeps[computedExpr];\n    if (!computedDeps) {\n        computedDeps = this.computedDeps[computedExpr] = {};\n    }\n\n    this.data.set(computedExpr, this.computed[computedExpr].call({\n        data: {\n            get: bind(function (expr) {\n                // #[begin] error\n//                 if (!expr) {\n//                     throw new Error('[SAN ERROR] call get method in computed need argument');\n//                 }\n                // #[end]\n\n                if (!computedDeps[expr]) {\n                    computedDeps[expr] = 1;\n\n                    if (this.computed[expr]) {\n                        this._calcComputed(expr);\n                    }\n\n                    this.watch(expr, function () {\n                        this._calcComputed(computedExpr);\n                    });\n                }\n\n                return this.data.get(expr);\n            }, this)\n        }\n    }));\n};\n\n/**\n * 派发消息\n * 组件可以派发消息，消息将沿着组件树向上传递，直到遇上第一个处理消息的组件\n *\n * @param {string} name 消息名称\n * @param {*?} value 消息值\n */\nComponent.prototype.dispatch = function (name, value) {\n    var parentComponent = this.parentComponent;\n\n    while (parentComponent) {\n        var receiver = parentComponent.messages[name] || parentComponent.messages['*'];\n        if (typeof receiver === 'function') {\n            receiver.call(\n                parentComponent,\n                {target: this, value: value, name: name}\n            );\n            break;\n        }\n\n        parentComponent = parentComponent.parentComponent;\n    }\n};\n\n/**\n * 获取组件内部的 slot\n *\n * @param {string=} name slot名称，空为default slot\n * @return {Array}\n */\nComponent.prototype.slot = function (name) {\n    var result = [];\n    var me = this;\n\n    function childrenTraversal(children) {\n        each(children, function (child) {\n            if (child.nodeType === NodeType.SLOT && child.owner === me) {\n                if (child.isNamed && child.name === name\n                    || !child.isNamed && !name\n                ) {\n                    result.push(child);\n                }\n            }\n            else {\n                childrenTraversal(child.children);\n            }\n        });\n    }\n\n    childrenTraversal(this.children);\n    return result;\n};\n\n/**\n * 获取带有 san-ref 指令的子组件引用\n *\n * @param {string} name 子组件的引用名\n * @return {Component}\n */\nComponent.prototype.ref = function (name) {\n    var refTarget;\n    var owner = this;\n\n    function childrenTraversal(children) {\n        each(children, function (child) {\n            elementTraversal(child);\n            return !refTarget;\n        });\n    }\n\n    function elementTraversal(element) {\n        var nodeType = element.nodeType;\n        if (nodeType === NodeType.TEXT) {\n            return;\n        }\n\n        if (element.owner === owner) {\n            var ref;\n            switch (element.nodeType) {\n                case NodeType.ELEM:\n                    ref = element.aNode.directives.ref;\n                    if (ref && evalExpr(ref.value, element.scope, owner) === name) {\n                        refTarget = element.el;\n                    }\n                    break;\n\n                case NodeType.CMPT:\n                    ref = element.givenANode.directives.ref;\n                    if (ref && evalExpr(ref.value, element.scope, owner) === name) {\n                        refTarget = element;\n                    }\n            }\n\n            !refTarget && childrenTraversal(element.slotChildren);\n        }\n\n        !refTarget && childrenTraversal(element.children);\n    }\n\n    childrenTraversal(this.children);\n\n    return refTarget;\n};\n\n\n/**\n * 视图更新函数\n *\n * @param {Array?} changes 数据变化信息\n */\nComponent.prototype._update = function (changes) {\n    if (this.lifeCycle.disposed) {\n        return;\n    }\n\n    var me = this;\n\n\n    var needReloadForSlot = false;\n    this._notifyNeedReload = function () {\n        needReloadForSlot = true;\n    };\n\n    if (changes) {\n        nodeSBindUpdate(\n            this,\n            this.givenANode.directives.bind,\n            changes,\n            function (name, value) {\n                if (name in me.givenANode.hotspot.props) {\n                    return;\n                }\n\n                me.data.set(name, value, {\n                    target: {\n                        id: me.owner.id\n                    }\n                });\n            }\n        );\n\n\n        each(changes, function (change) {\n            var changeExpr = change.expr;\n\n            each(me.binds, function (bindItem) {\n                var relation;\n                var setExpr = bindItem.name;\n                var updateExpr = bindItem.expr;\n\n                if (!isDataChangeByElement(change, me, setExpr)\n                    && (relation = changeExprCompare(changeExpr, updateExpr, me.scope))\n                ) {\n                    if (relation > 2) {\n                        setExpr = createAccessor(\n                            [\n                                {\n                                    type: ExprType.STRING,\n                                    value: setExpr\n                                }\n                            ].concat(changeExpr.paths.slice(updateExpr.paths.length))\n                        );\n                        updateExpr = changeExpr;\n                    }\n\n                    if (relation >= 2 && change.type === DataChangeType.SPLICE) {\n                        me.data.splice(setExpr, [change.index, change.deleteCount].concat(change.insertions), {\n                            target: {\n                                id: me.owner.id\n                            }\n                        });\n                    }\n                    else {\n                        me.data.set(setExpr, evalExpr(updateExpr, me.scope, me.owner), {\n                            target: {\n                                id: me.owner.id\n                            }\n                        });\n                    }\n                }\n            });\n\n            each(me.givenNamedSlotBinds, function (bindItem) {\n                needReloadForSlot = needReloadForSlot || changeExprCompare(changeExpr, bindItem.expr, me.scope);\n                return !needReloadForSlot;\n            });\n        });\n\n        if (needReloadForSlot) {\n            this._createGivenSlots();\n            this._repaintChildren();\n        }\n        else {\n            var slotChildrenLen = this.slotChildren.length;\n            while (slotChildrenLen--) {\n                var slotChild = this.slotChildren[slotChildrenLen];\n\n                if (slotChild.lifeCycle.disposed) {\n                    this.slotChildren.splice(slotChildrenLen, 1);\n                }\n                else if (slotChild.isInserted) {\n                    slotChild._update(changes, 1);\n                }\n            }\n        }\n    }\n\n    var dataChanges = this.dataChanges;\n    if (dataChanges) {\n        this.dataChanges = null;\n        each(this.aNode.hotspot.dynamicProps, function (prop) {\n            each(dataChanges, function (change) {\n                if (changeExprCompare(change.expr, prop.expr, me.data)\n                    || prop.hintExpr && changeExprCompare(change.expr, prop.hintExpr, me.data)\n                ) {\n                    handleProp(me, evalExpr(prop.expr, me.data, me), prop);\n                    return false;\n                }\n            });\n        });\n\n        elementUpdateChildren(this, dataChanges);\n        if (needReloadForSlot) {\n            this._createGivenSlots();\n            this._repaintChildren();\n        }\n\n        this._toPhase('updated');\n\n        if (this.owner) {\n            this._updateBindxOwner(dataChanges);\n            this.owner._update();\n        }\n    }\n\n    this._notifyNeedReload = null;\n};\n\nComponent.prototype._updateBindxOwner = function (dataChanges) {\n    var me = this;\n\n    if (this.owner) {\n        each(dataChanges, function (change) {\n            each(me.binds, function (bindItem) {\n                var changeExpr = change.expr;\n                if (bindItem.x\n                    && !isDataChangeByElement(change, me.owner)\n                    && changeExprCompare(changeExpr, parseExpr(bindItem.name), me.data)\n                ) {\n                    var updateScopeExpr = bindItem.expr;\n                    if (changeExpr.paths.length > 1) {\n                        updateScopeExpr = createAccessor(\n                            bindItem.expr.paths.concat(changeExpr.paths.slice(1))\n                        );\n                    }\n\n                    me.scope.set(\n                        updateScopeExpr,\n                        evalExpr(changeExpr, me.data, me),\n                        {\n                            target: {\n                                id: me.id,\n                                prop: bindItem.name\n                            }\n                        }\n                    );\n                }\n            });\n        });\n    }\n};\n\n/**\n * 重新绘制组件的内容\n * 当 dynamic slot name 发生变更或 slot 匹配发生变化时，重新绘制\n * 在组件级别重绘有点粗暴，但是能保证视图结果正确性\n */\nComponent.prototype._repaintChildren = function () {\n    elementDisposeChildren(this, 0, 1);\n    this.children = [];\n\n    this._contentReady = 0;\n    this.slotChildren = [];\n    elementAttach(this);\n};\n\n\n/**\n * 组件内部监听数据变化的函数\n *\n * @private\n * @param {Object} change 数据变化信息\n */\nComponent.prototype._dataChanger = function (change) {\n    if (this.lifeCycle.created && this._aftercreated) {\n        if (!this.dataChanges) {\n            nextTick(this._update, this);\n            this.dataChanges = [];\n        }\n\n        this.dataChanges.push(change);\n    }\n    else if (this.lifeCycle.inited && this.owner) {\n        this._updateBindxOwner([change]);\n    }\n};\n\n\n/**\n * 监听组件的数据变化\n *\n * @param {string} dataName 变化的数据项\n * @param {Function} listener 监听函数\n */\nComponent.prototype.watch = function (dataName, listener) {\n    var dataExpr = parseExpr(dataName);\n\n    this.data.listen(bind(function (change) {\n        if (changeExprCompare(change.expr, dataExpr, this.data)) {\n            listener.call(this, evalExpr(dataExpr, this.data, this), change);\n        }\n    }, this));\n};\n\n/**\n * 组件销毁的行为\n *\n * @param {Object} options 销毁行为的参数\n */\nComponent.prototype.dispose = elementOwnDispose;\n\nComponent.prototype._doneLeave = function () {\n    if (this.leaveDispose) {\n        if (!this.lifeCycle.disposed) {\n            // 这里不用挨个调用 dispose 了，因为 children 释放链会调用的\n            this.slotChildren = null;\n\n            this.data.unlisten();\n            this.dataChanger = null;\n            this.dataChanges = null;\n\n            elementDispose(\n                this,\n                this.disposeNoDetach,\n                this.disposeNoTransition\n            );\n            this.listeners = null;\n\n            this.givenANode = null;\n            this.givenSlots = null;\n            this.givenNamedSlotBinds = null;\n        }\n    }\n    else if (this.lifeCycle.attached) {\n        removeEl(this.el);\n        this._toPhase('detached');\n    }\n};\n\n/**\n * 完成组件 attached 后的行为\n *\n * @param {Object} element 元素节点\n */\nComponent.prototype._attached = elementOwnAttached;\n\nComponent.prototype.attach = elementOwnAttach;\nComponent.prototype.detach = elementOwnDetach;\nComponent.prototype._create = elementOwnCreate;\nComponent.prototype._onEl = elementOwnOnEl;\n\n\n// exports = module.exports = Component;\n\n\n/**\n * @file 创建组件类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var Component = require('./component');\n// var inherits = require('../util/inherits');\n\n/**\n * 创建组件类\n *\n * @param {Object} proto 组件类的方法表\n * @return {Function}\n */\nfunction defineComponent(proto) {\n    // 如果传入一个不是 san component 的 constructor，直接返回不是组件构造函数\n    // 这种场景导致的错误 san 不予考虑\n    if (typeof proto === 'function') {\n        return proto;\n    }\n\n    // #[begin] error\n//     if (typeof proto !== 'object') {\n//         throw new Error('[SAN FATAL] param must be a plain object.');\n//     }\n    // #[end]\n\n    function ComponentClass(option) { // eslint-disable-line\n        Component.call(this, option);\n    }\n\n    ComponentClass.prototype = proto;\n    inherits(ComponentClass, Component);\n\n    return ComponentClass;\n}\n\n// exports = module.exports = defineComponent;\n\n\n/**\n * @file 编译组件类\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var createANode = require('../parser/create-a-node');\n// var parseTemplate = require('../parser/parse-template');\n// var parseText = require('../parser/parse-text');\n// var defineComponent = require('./define-component');\n\n\n/**\n * 编译组件类。预解析template和components\n *\n * @param {Function} ComponentClass 组件类\n */\nfunction compileComponent(ComponentClass) {\n    var proto = ComponentClass.prototype;\n\n    // pre define components class\n    if (!proto.hasOwnProperty('_cmptReady')) {\n        proto.components = ComponentClass.components || proto.components || {};\n        var components = proto.components;\n\n        for (var key in components) { // eslint-disable-line\n            var componentClass = components[key];\n\n            if (typeof componentClass === 'object') {\n                components[key] = defineComponent(componentClass);\n            }\n            else if (componentClass === 'self') {\n                components[key] = ComponentClass;\n            }\n        }\n\n        proto._cmptReady = 1;\n    }\n\n\n    // pre compile template\n    if (!proto.hasOwnProperty('aNode')) {\n        proto.aNode = createANode();\n\n        var tpl = ComponentClass.template || proto.template;\n        if (tpl) {\n            var aNode = parseTemplate(tpl, {\n                trimWhitespace: proto.trimWhitespace || ComponentClass.trimWhitespace,\n                delimiters: proto.delimiters || ComponentClass.delimiters\n            });\n            var firstChild = aNode.children[0];\n\n            // #[begin] error\n//             if (aNode.children.length !== 1 || firstChild.textExpr) {\n//                 throw new Error('[SAN FATAL] template must have a root element.');\n//             }\n            // #[end]\n\n            proto.aNode = firstChild;\n            if (firstChild.tagName === 'template') {\n                firstChild.tagName = null;\n            }\n\n            var componentPropExtra = {\n                'class': {name: 'class', expr: parseText('{{class | _class | _sep(\" \")}}')},\n                'style': {name: 'style', expr: parseText('{{style | _style | _sep(\";\")}}')},\n                'id': {name: 'id', expr: parseText('{{id}}')}\n            };\n\n            var len = firstChild.props.length;\n            while (len--) {\n                var prop = firstChild.props[len];\n                var extra = componentPropExtra[prop.name];\n\n                if (extra) {\n                    firstChild.props.splice(len, 1);\n                    componentPropExtra[prop.name] = prop;\n\n                    if (prop.name !== 'id') {\n                        prop.expr.segs.push(extra.expr.segs[0]);\n                        prop.expr.value = null;\n                    }\n                }\n            }\n\n            firstChild.props.push(\n                componentPropExtra['class'], // eslint-disable-line dot-notation\n                componentPropExtra.style,\n                componentPropExtra.id\n            );\n        }\n    }\n}\n\n// exports = module.exports = compileComponent;\n\n\n/**\n * @file 组件预热\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var ExprType = require('../parser/expr-type');\n// var each = require('../util/each');\n// var createEl = require('../browser/create-el');\n// var getPropHandler = require('./get-prop-handler');\n// var getANodeProp = require('./get-a-node-prop');\n// var isBrowser = require('../browser/is-browser');\n\n/**\n * 组件预热，分析组件aNode的数据引用等信息\n *\n * @param {Function} ComponentClass 组件类\n */\nfunction componentPreheat(ComponentClass) {\n    var stack = [];\n\n    function recordHotspotData(refs, notContentData) {\n        var len = stack.length;\n        each(stack, function (aNode, index) {\n            if (!notContentData || index !== len - 1) {\n                each(refs, function (ref) {\n                    aNode.hotspot.data[ref] = 1;\n                });\n            }\n        });\n    }\n\n\n    function analyseANodeHotspot(aNode) {\n        if (!aNode.hotspot) {\n            stack.push(aNode);\n\n\n            if (aNode.textExpr) {\n                aNode.hotspot = {data: {}};\n                recordHotspotData(analyseExprDataHotspot(aNode.textExpr));\n            }\n            else {\n                var sourceNode;\n                if (isBrowser && aNode.tagName && !/^(template|slot|select|input|option)$/i.test(aNode.tagName)) {\n                    sourceNode = createEl(aNode.tagName);\n                }\n\n                aNode.hotspot = {\n                    data: {},\n                    dynamicProps: [],\n                    xProps: [],\n                    props: {},\n                    sourceNode: sourceNode\n                };\n\n\n                // === analyse hotspot data: start\n                each(aNode.vars, function (varItem) {\n                    recordHotspotData(analyseExprDataHotspot(varItem.expr));\n                });\n\n                each(aNode.props, function (prop) {\n                    recordHotspotData(analyseExprDataHotspot(prop.expr));\n                });\n\n                /* eslint-disable guard-for-in */\n                for (var key in aNode.directives) {\n                    var directive = aNode.directives[key];\n                    recordHotspotData(analyseExprDataHotspot(directive.value), !/^(html|bind)$/.test(key));\n\n                    // init trackBy getKey function\n                    if (key === 'for') {\n                        var trackBy = directive.trackBy;\n                        if (trackBy\n                            && trackBy.type === ExprType.ACCESSOR\n                            && trackBy.paths[0].value === directive.item.raw\n                        ) {\n                            aNode.hotspot.getForKey = new Function(\n                                directive.item.raw,\n                                'return ' + trackBy.raw\n                            );\n                        }\n                    }\n                }\n                /* eslint-enable guard-for-in */\n\n                each(aNode.elses, function (child) {\n                    analyseANodeHotspot(child);\n                });\n\n                each(aNode.children, function (child) {\n                    analyseANodeHotspot(child);\n                });\n                // === analyse hotspot data: end\n\n\n                // === analyse hotspot props: start\n                each(aNode.props, function (prop, index) {\n                    aNode.hotspot.props[prop.name] = index;\n\n                    if (prop.name === 'id') {\n                        prop.id = true;\n                        aNode.hotspot.idProp = prop;\n                        aNode.hotspot.dynamicProps.push(prop);\n                    }\n                    else if (prop.expr.value != null) {\n                        if (sourceNode) {\n                            getPropHandler(aNode.tagName, prop.name)\n                                .prop(sourceNode, prop.expr.value, prop.name, aNode);\n                        }\n                    }\n                    else {\n                        if (prop.x) {\n                            aNode.hotspot.xProps.push(prop);\n                        }\n                        aNode.hotspot.dynamicProps.push(prop);\n                    }\n                });\n\n                // ie 下，如果 option 没有 value 属性，select.value = xx 操作不会选中 option\n                // 所以没有设置 value 时，默认把 option 的内容作为 value\n                if (aNode.tagName === 'option'\n                    && !getANodeProp(aNode, 'value')\n                    && aNode.children[0]\n                ) {\n                    var valueProp = {\n                        name: 'value',\n                        expr: aNode.children[0].textExpr\n                    };\n                    aNode.props.push(valueProp);\n                    aNode.hotspot.dynamicProps.push(valueProp);\n                    aNode.hotspot.props.value = aNode.props.length - 1;\n                }\n                // === analyse hotspot props: end\n            }\n\n            stack.pop();\n        }\n    }\n\n    analyseANodeHotspot(ComponentClass.prototype.aNode);\n}\n\n/**\n * 分析表达式的数据引用\n *\n * @param {Object} expr 要分析的表达式\n * @return {Array}\n */\nfunction analyseExprDataHotspot(expr) {\n    var refs = [];\n\n    function analyseExprs(exprs) {\n        each(exprs, function (expr) {\n            refs = refs.concat(analyseExprDataHotspot(expr));\n        });\n    }\n\n    switch (expr.type) {\n        case ExprType.ACCESSOR:\n            var paths = expr.paths;\n            refs.push(paths[0].value);\n\n            if (paths.length > 1) {\n                refs.push(paths[0].value + '.' + (paths[1].value || '*'));\n            }\n\n            analyseExprs(paths.slice(1));\n            break;\n\n        case ExprType.UNARY:\n            return analyseExprDataHotspot(expr.expr);\n\n        case ExprType.TEXT:\n        case ExprType.BINARY:\n        case ExprType.TERTIARY:\n            analyseExprs(expr.segs);\n            break;\n\n        case ExprType.INTERP:\n            refs = analyseExprDataHotspot(expr.expr);\n\n            each(expr.filters, function (filter) {\n                analyseExprs(filter.name.paths);\n                analyseExprs(filter.args);\n            });\n\n            break;\n\n    }\n\n    return refs;\n}\n\n// exports = module.exports = componentPreheat;\n\n\n/**\n * @file 将 binds 的 name 从 kebabcase 转换成 camelcase\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var kebab2camel = require('../util/kebab2camel');\n// var each = require('../util/each');\n\n/**\n * 将 binds 的 name 从 kebabcase 转换成 camelcase\n *\n * @param {Array} binds binds集合\n * @return {Array}\n */\nfunction camelComponentBinds(binds) {\n    var result = [];\n    each(binds, function (bind) {\n        result.push({\n            name: kebab2camel(bind.name),\n            expr: bind.expr,\n            x: bind.x,\n            raw: bind.raw\n        });\n    });\n\n    return result;\n}\n\n// exports = module.exports = camelComponentBinds;\n\n\n/**\n * @file 编译源码的 helper 方法集合\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('../util/each');\n// var ExprType = require('../parser/expr-type');\n\n// #[begin] ssr\n// \n// /**\n//  * 编译源码的 helper 方法集合对象\n//  */\n// var compileExprSource = {\n// \n//     /**\n//      * 字符串字面化\n//      *\n//      * @param {string} source 需要字面化的字符串\n//      * @return {string} 字符串字面化结果\n//      */\n//     stringLiteralize: function (source) {\n//         return '\"'\n//             + source\n//                 .replace(/\\x5C/g, '\\\\\\\\')\n//                 .replace(/\"/g, '\\\\\"')\n//                 .replace(/\\x0A/g, '\\\\n')\n//                 .replace(/\\x09/g, '\\\\t')\n//                 .replace(/\\x0D/g, '\\\\r')\n//                 // .replace( /\\x08/g, '\\\\b' )\n//                 // .replace( /\\x0C/g, '\\\\f' )\n//             + '\"';\n//     },\n// \n//     /**\n//      * 生成数据访问表达式代码\n//      *\n//      * @param {Object?} accessorExpr accessor表达式对象\n//      * @return {string}\n//      */\n//     dataAccess: function (accessorExpr) {\n//         var code = 'componentCtx.data';\n//         if (accessorExpr) {\n//             each(accessorExpr.paths, function (path) {\n//                 if (path.type === ExprType.ACCESSOR) {\n//                     code += '[' + compileExprSource.dataAccess(path) + ']';\n//                     return;\n//                 }\n// \n//                 switch (typeof path.value) {\n//                     case 'string':\n//                         code += '.' + path.value;\n//                         break;\n// \n//                     case 'number':\n//                         code += '[' + path.value + ']';\n//                         break;\n//                 }\n//             });\n//         }\n// \n//         return code;\n//     },\n// \n//     /**\n//      * 生成插值代码\n//      *\n//      * @param {Object} interpExpr 插值表达式对象\n//      * @return {string}\n//      */\n//     interp: function (interpExpr) {\n//         var code = compileExprSource.expr(interpExpr.expr);\n// \n// \n//         each(interpExpr.filters, function (filter) {\n//             code = 'componentCtx.callFilter(\"' + filter.name.paths[0].value + '\", [' + code;\n//             each(filter.args, function (arg) {\n//                 code += ', ' + compileExprSource.expr(arg);\n//             });\n//             code += '])';\n//         });\n// \n//         if (!interpExpr.original) {\n//             return 'escapeHTML(' + code + ')';\n//         }\n// \n//         return code;\n//     },\n// \n//     /**\n//      * 生成文本片段代码\n//      *\n//      * @param {Object} textExpr 文本片段表达式对象\n//      * @return {string}\n//      */\n//     text: function (textExpr) {\n//         if (textExpr.segs.length === 0) {\n//             return '\"\"';\n//         }\n// \n//         var code = '';\n// \n//         each(textExpr.segs, function (seg) {\n//             var segCode = compileExprSource.expr(seg);\n//             code += code ? ' + ' + segCode : segCode;\n//         });\n// \n//         return code;\n//     },\n// \n//     /**\n//      * 生成数组字面量代码\n//      *\n//      * @param {Object} arrayExpr 数组字面量表达式对象\n//      * @return {string}\n//      */\n//     array: function (arrayExpr) {\n//         var code = [];\n// \n//         each(arrayExpr.items, function (item) {\n//             code.push((item.spread ? '...' : '') + compileExprSource.expr(item.expr));\n//         });\n// \n//         return '[\\n' + code.join(',\\n') + '\\n]';\n//     },\n// \n//     /**\n//      * 生成对象字面量代码\n//      *\n//      * @param {Object} objExpr 对象字面量表达式对象\n//      * @return {string}\n//      */\n//     object: function (objExpr) {\n//         var code = [];\n// \n//         each(objExpr.items, function (item) {\n//             if (item.spread) {\n//                 code.push('...' + compileExprSource.expr(item.expr));\n//             }\n//             else {\n//                 code.push(compileExprSource.expr(item.name) + ':' + compileExprSource.expr(item.expr));\n//             }\n//         });\n// \n//         return '{\\n' + code.join(',\\n') + '\\n}';\n//     },\n// \n//     /**\n//      * 二元表达式操作符映射表\n//      *\n//      * @type {Object}\n//      */\n//     binaryOp: {\n//         /* eslint-disable */\n//         43: '+',\n//         45: '-',\n//         42: '*',\n//         47: '/',\n//         60: '<',\n//         62: '>',\n//         76: '&&',\n//         94: '!=',\n//         121: '<=',\n//         122: '==',\n//         123: '>=',\n//         155: '!==',\n//         183: '===',\n//         248: '||'\n//         /* eslint-enable */\n//     },\n// \n//     /**\n//      * 生成表达式代码\n//      *\n//      * @param {Object} expr 表达式对象\n//      * @return {string}\n//      */\n//     expr: function (expr) {\n//         switch (expr.type) {\n//             case ExprType.UNARY:\n//                 return '!' + compileExprSource.expr(expr.expr);\n// \n//             case ExprType.BINARY:\n//                 return compileExprSource.expr(expr.segs[0])\n//                     + compileExprSource.binaryOp[expr.operator]\n//                     + compileExprSource.expr(expr.segs[1]);\n// \n//             case ExprType.TERTIARY:\n//                 return compileExprSource.expr(expr.segs[0])\n//                     + '?' + compileExprSource.expr(expr.segs[1])\n//                     + ':' + compileExprSource.expr(expr.segs[2]);\n// \n//             case ExprType.STRING:\n//                 return compileExprSource.stringLiteralize(expr.literal || expr.value);\n// \n//             case ExprType.NUMBER:\n//                 return expr.value;\n// \n//             case ExprType.BOOL:\n//                 return expr.value ? 'true' : 'false';\n// \n//             case ExprType.ACCESSOR:\n//                 return compileExprSource.dataAccess(expr);\n// \n//             case ExprType.INTERP:\n//                 return compileExprSource.interp(expr);\n// \n//             case ExprType.TEXT:\n//                 return compileExprSource.text(expr);\n// \n//             case ExprType.ARRAY:\n//                 return compileExprSource.array(expr);\n// \n//             case ExprType.OBJECT:\n//                 return compileExprSource.object(expr);\n//         }\n//     }\n// };\n// #[end]\n\n// exports = module.exports = compileExprSource;\n\n\n/**\n * @file 编译源码的中间buffer类\n * @author errorrik(errorrik@gmail.com)\n */\n\n// var each = require('../util/each');\n// var compileExprSource = require('./compile-expr-source');\n\n\n// #[begin] ssr\n// /**\n//  * 编译源码的中间buffer类\n//  *\n//  * @class\n//  */\n// function CompileSourceBuffer() {\n//     this.segs = [];\n// }\n// \n// /**\n//  * 添加原始代码，将原封不动输出\n//  *\n//  * @param {string} code 原始代码\n//  */\n// CompileSourceBuffer.prototype.addRaw = function (code) {\n//     this.segs.push({\n//         type: 'RAW',\n//         code: code\n//     });\n// };\n// \n// /**\n//  * 添加被拼接为html的原始代码\n//  *\n//  * @param {string} code 原始代码\n//  */\n// CompileSourceBuffer.prototype.joinRaw = function (code) {\n//     this.segs.push({\n//         type: 'JOIN_RAW',\n//         code: code\n//     });\n// };\n// \n// /**\n//  * 添加renderer方法的起始源码\n//  */\n// CompileSourceBuffer.prototype.addRendererStart = function () {\n//     this.addRaw('function (data, parentCtx, givenSlots) {');\n//     this.addRaw('var html = \"\";');\n// };\n// \n// /**\n//  * 添加renderer方法的结束源码\n//  */\n// CompileSourceBuffer.prototype.addRendererEnd = function () {\n//     this.addRaw('return html;');\n//     this.addRaw('}');\n// };\n// \n// /**\n//  * 添加被拼接为html的静态字符串\n//  *\n//  * @param {string} str 被拼接的字符串\n//  */\n// CompileSourceBuffer.prototype.joinString = function (str) {\n//     this.segs.push({\n//         str: str,\n//         type: 'JOIN_STRING'\n//     });\n// };\n// \n// /**\n//  * 添加被拼接为html的数据访问\n//  *\n//  * @param {Object?} accessor 数据访问表达式对象\n//  */\n// CompileSourceBuffer.prototype.joinDataStringify = function () {\n//     this.segs.push({\n//         type: 'JOIN_DATA_STRINGIFY'\n//     });\n// };\n// \n// /**\n//  * 添加被拼接为html的表达式\n//  *\n//  * @param {Object} expr 表达式对象\n//  */\n// CompileSourceBuffer.prototype.joinExpr = function (expr) {\n//     this.segs.push({\n//         expr: expr,\n//         type: 'JOIN_EXPR'\n//     });\n// };\n// \n// /**\n//  * 生成编译后代码\n//  *\n//  * @return {string}\n//  */\n// CompileSourceBuffer.prototype.toCode = function () {\n//     var code = [];\n//     var temp = '';\n// \n//     function genStrLiteral() {\n//         if (temp) {\n//             code.push('html += ' + compileExprSource.stringLiteralize(temp) + ';');\n//         }\n// \n//         temp = '';\n//     }\n// \n//     each(this.segs, function (seg) {\n//         if (seg.type === 'JOIN_STRING') {\n//             temp += seg.str;\n//             return;\n//         }\n// \n//         genStrLiteral();\n//         switch (seg.type) {\n//             case 'JOIN_DATA_STRINGIFY':\n//                 code.push('html += stringifier.any(' + compileExprSource.dataAccess() + ');');\n//                 break;\n// \n//             case 'JOIN_EXPR':\n//                 code.push('html += ' + compileExprSource.expr(seg.expr) + ';');\n//                 break;\n// \n//             case 'JOIN_RAW':\n//                 code.push('html += ' + seg.code + ';');\n//                 break;\n// \n//             case 'RAW':\n//                 code.push(seg.code);\n//                 break;\n// \n//         }\n//     });\n// \n//     genStrLiteral();\n// \n//     return code.join('\\n');\n// };\n// \n// #[end]\n\n// exports = module.exports = CompileSourceBuffer;\n\n\n/**\n * @file 将组件编译成 render 方法的 js 源码\n * @author errorrik(errorrik@gmail.com)\n */\n\n\n// var each = require('../util/each');\n// var guid = require('../util/guid');\n// var parseExpr = require('../parser/parse-expr');\n// var createANode = require('../parser/create-a-node');\n// var cloneDirectives = require('../parser/clone-directives');\n// var autoCloseTags = require('../browser/auto-close-tags');\n// var CompileSourceBuffer = require('./compile-source-buffer');\n// var compileExprSource = require('./compile-expr-source');\n// var rinseCondANode = require('./rinse-cond-anode');\n// var getANodeProp = require('./get-a-node-prop');\n\n// #[begin] ssr\n// \n// /**\n//  * 生成序列化时起始桩的html\n//  *\n//  * @param {string} type 桩类型标识\n//  * @param {string?} content 桩内的内容\n//  * @return {string}\n//  */\n// function serializeStump(type, content) {\n//     return '<!--s-' + type + (content ? ':' + content : '') + '-->';\n// }\n// \n// /**\n//  * 生成序列化时结束桩的html\n//  *\n//  * @param {string} type 桩类型标识\n//  * @return {string}\n//  */\n// function serializeStumpEnd(type) {\n//     return '<!--/s-' + type + '-->';\n// }\n// \n// /**\n//  * element 的编译方法集合对象\n//  *\n//  * @inner\n//  */\n// var elementSourceCompiler = {\n// \n//     /* eslint-disable max-params */\n//     /**\n//      * 编译元素标签头\n//      *\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {string} tagName 标签名\n//      * @param {Array} props 属性列表\n//      * @param {string?} extraProp 额外的属性串\n//      */\n//     tagStart: function (sourceBuffer, tagName, props, extraProp, bindDirective) {\n//         sourceBuffer.joinString('<' + tagName);\n//         sourceBuffer.joinString(extraProp || '');\n// \n//         // index list\n//         var propsIndex = {};\n//         each(props, function (prop) {\n//             propsIndex[prop.name] = prop;\n//         });\n// \n//         each(props, function (prop) {\n//             if (prop.name === 'slot') {\n//                 return;\n//             }\n// \n//             if (prop.name === 'value') {\n//                 switch (tagName) {\n//                     case 'textarea':\n//                         return;\n// \n//                     case 'select':\n//                         sourceBuffer.addRaw('$selectValue = '\n//                             + compileExprSource.expr(prop.expr)\n//                             + ' || \"\";'\n//                         );\n//                         return;\n// \n//                     case 'option':\n//                         sourceBuffer.addRaw('$optionValue = '\n//                             + compileExprSource.expr(prop.expr)\n//                             + ';'\n//                         );\n//                         // value\n//                         sourceBuffer.addRaw('if ($optionValue != null) {');\n//                         sourceBuffer.joinRaw('\" value=\\\\\"\" + $optionValue + \"\\\\\"\"');\n//                         sourceBuffer.addRaw('}');\n// \n//                         // selected\n//                         sourceBuffer.addRaw('if ($optionValue === $selectValue) {');\n//                         sourceBuffer.joinString(' selected');\n//                         sourceBuffer.addRaw('}');\n//                         return;\n//                 }\n//             }\n// \n//             switch (prop.name) {\n//                 case 'readonly':\n//                 case 'disabled':\n//                 case 'multiple':\n//                     if (prop.raw === '') {\n//                         sourceBuffer.joinString(' ' + prop.name);\n//                     }\n//                     else {\n//                         sourceBuffer.joinRaw('boolAttrFilter(\"' + prop.name + '\", '\n//                             + compileExprSource.expr(prop.expr)\n//                             + ')'\n//                         );\n//                     }\n//                     break;\n// \n//                 case 'checked':\n//                     if (tagName === 'input') {\n//                         var valueProp = propsIndex.value;\n//                         var valueCode = compileExprSource.expr(valueProp.expr);\n// \n//                         if (valueProp) {\n//                             switch (propsIndex.type.raw) {\n//                                 case 'checkbox':\n//                                     sourceBuffer.addRaw('if (contains('\n//                                         + compileExprSource.expr(prop.expr)\n//                                         + ', '\n//                                         + valueCode\n//                                         + ')) {'\n//                                     );\n//                                     sourceBuffer.joinString(' checked');\n//                                     sourceBuffer.addRaw('}');\n//                                     break;\n// \n//                                 case 'radio':\n//                                     sourceBuffer.addRaw('if ('\n//                                         + compileExprSource.expr(prop.expr)\n//                                         + ' === '\n//                                         + valueCode\n//                                         + ') {'\n//                                     );\n//                                     sourceBuffer.joinString(' checked');\n//                                     sourceBuffer.addRaw('}');\n//                                     break;\n//                             }\n//                         }\n//                     }\n//                     break;\n// \n//                 default:\n//                     if (prop.attr) {\n//                         sourceBuffer.joinString(' ' + prop.attr);\n//                     }\n//                     else {\n//                         sourceBuffer.joinRaw('attrFilter(\"' + prop.name + '\", '\n//                             + (prop.x ? 'escapeHTML(' : '')\n//                             + compileExprSource.expr(prop.expr)\n//                             + (prop.x ? ')' : '')\n//                             + ')'\n//                         );\n//                     }\n//                     break;\n//             }\n//         });\n// \n//         if (bindDirective) {\n//             sourceBuffer.addRaw(\n//                 '(function ($bindObj) {for (var $key in $bindObj) {'\n//                 + 'var $value = $bindObj[$key];'\n//             );\n// \n//             if (tagName === 'textarea') {\n//                 sourceBuffer.addRaw(\n//                     'if ($key === \"value\") {'\n//                     + 'continue;'\n//                     + '}'\n//                 );\n//             }\n// \n//             sourceBuffer.addRaw('switch ($key) {\\n'\n//                 + 'case \"readonly\":\\n'\n//                 + 'case \"disabled\":\\n'\n//                 + 'case \"multiple\":\\n'\n//                 + 'case \"multiple\":\\n'\n//                 + 'html += boolAttrFilter($key, escapeHTML($value));\\n'\n//                 + 'break;\\n'\n//                 + 'default:\\n'\n//                 + 'html += attrFilter($key, escapeHTML($value));'\n//                 + '}'\n//             );\n// \n//             sourceBuffer.addRaw(\n//                 '}})('\n//                 + compileExprSource.expr(bindDirective.value)\n//                 + ');'\n//             );\n//         }\n// \n//         sourceBuffer.joinString('>');\n//     },\n//     /* eslint-enable max-params */\n// \n//     /**\n//      * 编译元素闭合\n//      *\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {string} tagName 标签名\n//      */\n//     tagEnd: function (sourceBuffer, tagName) {\n//         if (!autoCloseTags[tagName]) {\n//             sourceBuffer.joinString('</' + tagName + '>');\n//         }\n// \n//         if (tagName === 'select') {\n//             sourceBuffer.addRaw('$selectValue = null;');\n//         }\n// \n//         if (tagName === 'option') {\n//             sourceBuffer.addRaw('$optionValue = null;');\n//         }\n//     },\n// \n//     /**\n//      * 编译元素内容\n//      *\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {ANode} aNode 元素的抽象节点信息\n//      * @param {Component} owner 所属组件实例环境\n//      */\n//     inner: function (sourceBuffer, aNode, owner) {\n//         // inner content\n//         if (aNode.tagName === 'textarea') {\n//             var valueProp = getANodeProp(aNode, 'value');\n//             if (valueProp) {\n//                 sourceBuffer.joinRaw('escapeHTML('\n//                     + compileExprSource.expr(valueProp.expr)\n//                     + ')'\n//                 );\n//             }\n// \n//             return;\n//         }\n// \n//         var htmlDirective = aNode.directives.html;\n//         if (htmlDirective) {\n//             sourceBuffer.joinExpr(htmlDirective.value);\n//         }\n//         else {\n//             /* eslint-disable no-use-before-define */\n//             each(aNode.children, function (aNodeChild) {\n//                 sourceBuffer.addRaw(aNodeCompiler.compile(aNodeChild, sourceBuffer, owner));\n//             });\n//             /* eslint-enable no-use-before-define */\n//         }\n//     }\n// };\n// \n// /**\n//  * ANode 的编译方法集合对象\n//  *\n//  * @inner\n//  */\n// var aNodeCompiler = {\n// \n//     /**\n//      * 编译节点\n//      *\n//      * @param {ANode} aNode 抽象节点\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {Component} owner 所属组件实例环境\n//      * @param {Object} extra 编译所需的一些额外信息\n//      */\n//     compile: function (aNode, sourceBuffer, owner, extra) {\n//         extra = extra || {};\n//         var compileMethod = 'compileElement';\n// \n//         if (aNode.textExpr) {\n//             compileMethod = 'compileText';\n//         }\n//         else if (aNode.directives['if']) { // eslint-disable-line dot-notation\n//             compileMethod = 'compileIf';\n//         }\n//         else if (aNode.directives['for']) { // eslint-disable-line dot-notation\n//             compileMethod = 'compileFor';\n//         }\n//         else if (aNode.tagName === 'slot') {\n//             compileMethod = 'compileSlot';\n//         }\n//         else if (aNode.tagName === 'template') {\n//             compileMethod = 'compileTemplate';\n//         }\n//         else {\n//             var ComponentType = owner.getComponentType\n//                 ? owner.getComponentType(aNode)\n//                 : owner.components[aNode.tagName];\n//             if (ComponentType) {\n//                 compileMethod = 'compileComponent';\n//                 extra.ComponentClass = ComponentType;\n//             }\n//         }\n// \n//         aNodeCompiler[compileMethod](aNode, sourceBuffer, owner, extra);\n//     },\n// \n//     /**\n//      * 编译文本节点\n//      *\n//      * @param {ANode} aNode 节点对象\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      */\n//     compileText: function (aNode, sourceBuffer) {\n//         if (aNode.textExpr.original) {\n//             sourceBuffer.joinString(serializeStump('text'));\n//         }\n// \n//         sourceBuffer.joinExpr(aNode.textExpr);\n// \n//         if (aNode.textExpr.original) {\n//             sourceBuffer.joinString(serializeStumpEnd('text'));\n//         }\n//     },\n// \n//     /**\n//      * 编译template节点\n//      *\n//      * @param {ANode} aNode 节点对象\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {Component} owner 所属组件实例环境\n//      */\n//     compileTemplate: function (aNode, sourceBuffer, owner) {\n//         elementSourceCompiler.inner(sourceBuffer, aNode, owner);\n//     },\n// \n//     /**\n//      * 编译 if 节点\n//      *\n//      * @param {ANode} aNode 节点对象\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {Component} owner 所属组件实例环境\n//      */\n//     compileIf: function (aNode, sourceBuffer, owner) {\n//         sourceBuffer.addRaw('(function () {');\n// \n//         sourceBuffer.addRaw('var ifIndex = null;');\n// \n//         // output main if\n//         var ifDirective = aNode.directives['if']; // eslint-disable-line dot-notation\n//         sourceBuffer.addRaw('if (' + compileExprSource.expr(ifDirective.value) + ') {');\n//         sourceBuffer.addRaw(\n//             aNodeCompiler.compile(\n//                 rinseCondANode(aNode),\n//                 sourceBuffer,\n//                 owner\n//             )\n//         );\n//         sourceBuffer.addRaw('}');\n// \n//         // output elif and else\n//         each(aNode.elses, function (elseANode, index) {\n//             var elifDirective = elseANode.directives.elif;\n//             if (elifDirective) {\n//                 sourceBuffer.addRaw('else if (' + compileExprSource.expr(elifDirective.value) + ') {');\n//             }\n//             else {\n//                 sourceBuffer.addRaw('else {');\n//             }\n// \n//             sourceBuffer.addRaw(\n//                 aNodeCompiler.compile(\n//                     rinseCondANode(elseANode),\n//                     sourceBuffer,\n//                     owner\n//                 )\n//             );\n//             sourceBuffer.addRaw('}');\n//         });\n// \n//         sourceBuffer.addRaw('})();');\n//     },\n// \n//     /**\n//      * 编译 for 节点\n//      *\n//      * @param {ANode} aNode 节点对象\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {Component} owner 所属组件实例环境\n//      */\n//     compileFor: function (aNode, sourceBuffer, owner) {\n//         var forElementANode = createANode({\n//             children: aNode.children,\n//             props: aNode.props,\n//             events: aNode.events,\n//             tagName: aNode.tagName,\n//             directives: cloneDirectives(aNode.directives, {\n//                 'for': 1\n//             }),\n//             hotspot: aNode.hotspot\n//         });\n// \n//         var forDirective = aNode.directives['for']; // eslint-disable-line dot-notation\n//         var itemName = forDirective.item.raw;\n//         var indexName = forDirective.index.raw;\n//         var listName = guid();\n// \n//         if (indexName === '$index') {\n//             indexName = guid();\n//         }\n// \n//         sourceBuffer.addRaw('var ' + listName + ' = ' + compileExprSource.expr(forDirective.value) + ';');\n//         sourceBuffer.addRaw('for ('\n//             + 'var ' + indexName + ' = 0; '\n//             + indexName + ' < ' + listName + '.length; '\n//             + indexName + '++) {'\n//         );\n//         sourceBuffer.addRaw('componentCtx.data.' + indexName + '=' + indexName + ';');\n//         sourceBuffer.addRaw('componentCtx.data.' + itemName + '= ' + listName + '[' + indexName + '];');\n//         sourceBuffer.addRaw(\n//             aNodeCompiler.compile(\n//                 forElementANode,\n//                 sourceBuffer,\n//                 owner\n//             )\n//         );\n//         sourceBuffer.addRaw('}');\n//     },\n// \n//     /**\n//      * 编译 slot 节点\n//      *\n//      * @param {ANode} aNode 节点对象\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {Component} owner 所属组件实例环境\n//      */\n//     compileSlot: function (aNode, sourceBuffer, owner) {\n//         sourceBuffer.addRaw('(function () {');\n// \n//         sourceBuffer.addRaw('function $defaultSlotRender(componentCtx) {');\n//         sourceBuffer.addRaw('  var html = \"\";');\n//         each(aNode.children, function (aNodeChild) {\n//             sourceBuffer.addRaw(aNodeCompiler.compile(aNodeChild, sourceBuffer, owner));\n//         });\n//         sourceBuffer.addRaw('  return html;');\n//         sourceBuffer.addRaw('}');\n// \n//         sourceBuffer.addRaw('  var $givenSlot = [];');\n// \n//         var nameProp = getANodeProp(aNode, 'name');\n//         if (nameProp) {\n//             sourceBuffer.addRaw('var $slotName = ' + compileExprSource.expr(nameProp.expr) + ';');\n//         }\n//         else {\n//             sourceBuffer.addRaw('var $slotName = null;');\n//         }\n// \n//         sourceBuffer.addRaw('var $ctxGivenSlots = componentCtx.givenSlots;');\n//         sourceBuffer.addRaw('for (var $i = 0; $i < $ctxGivenSlots.length; $i++) {');\n//         sourceBuffer.addRaw('  if ($ctxGivenSlots[$i][1] == $slotName) {');\n//         sourceBuffer.addRaw('    $givenSlot.push($ctxGivenSlots[$i][0]);');\n//         sourceBuffer.addRaw('  }');\n//         sourceBuffer.addRaw('}');\n// \n// \n//         sourceBuffer.addRaw('var $isInserted = $givenSlot.length > 0;');\n//         sourceBuffer.addRaw('if (!$isInserted) { $givenSlot.push($defaultSlotRender); }');\n// \n//         sourceBuffer.addRaw('var $slotCtx = $isInserted ? componentCtx.owner : componentCtx;');\n// \n//         if (aNode.vars || aNode.directives.bind) {\n//             sourceBuffer.addRaw('$slotCtx = {data: extend({}, $slotCtx.data), filters: $slotCtx.filters, callFilter: $slotCtx.callFilter};'); // eslint-disable-line\n// \n//             if (aNode.directives.bind) {\n//                 sourceBuffer.addRaw('extend($slotCtx.data, ' + compileExprSource.expr(aNode.directives.bind.value) + ');'); // eslint-disable-line\n//             }\n// \n//             each(aNode.vars, function (varItem) {\n//                 sourceBuffer.addRaw(\n//                     '$slotCtx.data[\"' + varItem.name + '\"] = '\n//                     + compileExprSource.expr(varItem.expr)\n//                     + ';'\n//                 );\n//             });\n//         }\n// \n//         sourceBuffer.addRaw('for (var $renderIndex = 0; $renderIndex < $givenSlot.length; $renderIndex++) {');\n//         sourceBuffer.addRaw('  html += $givenSlot[$renderIndex]($slotCtx);');\n//         sourceBuffer.addRaw('}');\n// \n//         sourceBuffer.addRaw('})();');\n//     },\n// \n//     /**\n//      * 编译普通节点\n//      *\n//      * @param {ANode} aNode 节点对象\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {Component} owner 所属组件实例环境\n//      * @param {Object} extra 编译所需的一些额外信息\n//      */\n//     compileElement: function (aNode, sourceBuffer, owner, extra) {\n//         extra = extra || {};\n//         // if (aNode.tagName === 'option'\n//         //     && !getANodeProp(aNode, 'value')\n//         //     && aNode.children[0]\n//         // ) {\n//         //     aNode.props.push({\n//         //         name: 'value',\n//         //         expr: aNode.children[0].textExpr\n//         //     });\n//         // }\n// \n//         elementSourceCompiler.tagStart(\n//             sourceBuffer,\n//             aNode.tagName,\n//             aNode.props,\n//             extra.prop,\n//             aNode.directives.bind\n//         );\n// \n//         elementSourceCompiler.inner(sourceBuffer, aNode, owner);\n//         elementSourceCompiler.tagEnd(sourceBuffer, aNode.tagName);\n//     },\n// \n//     /**\n//      * 编译组件节点\n//      *\n//      * @param {ANode} aNode 节点对象\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//      * @param {Component} owner 所属组件实例环境\n//      * @param {Object} extra 编译所需的一些额外信息\n//      * @param {Function} extra.ComponentClass 对应组件类\n//      */\n//     compileComponent: function (aNode, sourceBuffer, owner, extra) {\n//         if (aNode) {\n//             sourceBuffer.addRaw('var $slotName = null;');\n//             sourceBuffer.addRaw('var $givenSlots = [];');\n//             each(aNode.children, function (child) {\n//                 var slotBind = !child.textExpr && getANodeProp(child, 'slot');\n//                 if (slotBind) {\n//                     sourceBuffer.addRaw('$slotName = ' + compileExprSource.expr(slotBind.expr) + ';');\n//                     sourceBuffer.addRaw('$givenSlots.push([function (componentCtx) {');\n//                     sourceBuffer.addRaw('  var html = \"\";');\n//                     sourceBuffer.addRaw(aNodeCompiler.compile(child, sourceBuffer, owner));\n//                     sourceBuffer.addRaw('  return html;');\n//                     sourceBuffer.addRaw('}, $slotName]);');\n//                 }\n//                 else {\n//                     sourceBuffer.addRaw('$givenSlots.push([function (componentCtx) {');\n//                     sourceBuffer.addRaw('  var html = \"\";');\n//                     sourceBuffer.addRaw(aNodeCompiler.compile(child, sourceBuffer, owner));\n//                     sourceBuffer.addRaw('  return html;');\n//                     sourceBuffer.addRaw('}]);');\n//                 }\n//             });\n//         }\n// \n//         var ComponentClass = extra.ComponentClass;\n//         var component = new ComponentClass({\n//             aNode: aNode,\n//             owner: owner,\n//             subTag: aNode.tagName\n//         });\n// \n//         var givenData = [];\n// \n//         each(component.binds, function (prop) {\n//             givenData.push(\n//                 compileExprSource.stringLiteralize(prop.name)\n//                 + ':'\n//                 + compileExprSource.expr(prop.expr)\n//             );\n//         });\n// \n//         var givenDataHTML = '{' + givenData.join(',\\n') + '}';\n//         if (aNode.directives.bind){\n//             givenDataHTML = 'extend('\n//                 + compileExprSource.expr(aNode.directives.bind.value)\n//                  + ', '\n//                 + givenDataHTML\n//                 + ')';\n//         }\n// \n//         sourceBuffer.addRaw('html += (');\n//         sourceBuffer.addRendererStart();\n//         compileComponentSource(sourceBuffer, component, extra && extra.prop);\n//         sourceBuffer.addRendererEnd();\n//         sourceBuffer.addRaw(')(' + givenDataHTML + ', componentCtx, $givenSlots);');\n//         sourceBuffer.addRaw('$givenSlots = null;');\n//     }\n// };\n// /* eslint-disable guard-for-in */\n// \n// /**\n//  * 生成组件 renderer 时 ctx 对象构建的代码\n//  *\n//  * @inner\n//  * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\n//  * @param {Object} component 组件实例\n//  * @param {string?} extraProp 额外的属性串\n//  */\n// function compileComponentSource(sourceBuffer, component, extraProp) {\n//     sourceBuffer.addRaw(genComponentContextCode(component));\n//     sourceBuffer.addRaw('componentCtx.owner = parentCtx;');\n//     sourceBuffer.addRaw('componentCtx.givenSlots = givenSlots;');\n// \n// \n//     sourceBuffer.addRaw('data = extend(componentCtx.data, data);');\n//     sourceBuffer.addRaw('for (var $i = 0; $i < componentCtx.computedNames.length; $i++) {');\n//     sourceBuffer.addRaw('  var $computedName = componentCtx.computedNames[$i];');\n//     sourceBuffer.addRaw('  data[$computedName] = componentCtx.computed[$computedName]();');\n//     sourceBuffer.addRaw('}');\n// \n//     extraProp = extraProp || '';\n// \n//     var eventDeclarations = [];\n//     for (var key in component.listeners) {\n//         each(component.listeners[key], function (listener) {\n//             if (listener.declaration) {\n//                 eventDeclarations.push(listener.declaration);\n//             }\n//         });\n//     }\n// \n//     elementSourceCompiler.tagStart(\n//         sourceBuffer,\n//         component.tagName,\n//         component.aNode.props,\n//         extraProp,\n//         component.aNode.directives.bind\n//     );\n// \n//     if (!component.owner) {\n//         sourceBuffer.joinString('<!--s-data:');\n//         sourceBuffer.joinDataStringify();\n//         sourceBuffer.joinString('-->');\n//     }\n// \n// \n// \n//     elementSourceCompiler.inner(sourceBuffer, component.aNode, component);\n//     elementSourceCompiler.tagEnd(sourceBuffer, component.tagName);\n// }\n// \n// var stringifier = {\n//     obj: function (source) {\n//         var prefixComma;\n//         var result = '{';\n// \n//         for (var key in source) {\n//             if (typeof source[key] === 'undefined') {\n//                 continue;\n//             }\n// \n//             if (prefixComma) {\n//                 result += ',';\n//             }\n//             prefixComma = 1;\n// \n//             result += compileExprSource.stringLiteralize(key) + ':' + stringifier.any(source[key]);\n//         }\n// \n//         return result + '}';\n//     },\n// \n//     arr: function (source) {\n//         var prefixComma;\n//         var result = '[';\n// \n//         each(source, function (value) {\n//             if (prefixComma) {\n//                 result += ',';\n//             }\n//             prefixComma = 1;\n// \n//             result += stringifier.any(value);\n//         });\n// \n//         return result + ']';\n//     },\n// \n//     str: function (source) {\n//         return compileExprSource.stringLiteralize(source);\n//     },\n// \n//     date: function (source) {\n//         return 'new Date(' + source.getTime() + ')';\n//     },\n// \n//     any: function (source) {\n//         switch (typeof source) {\n//             case 'string':\n//                 return stringifier.str(source);\n// \n//             case 'number':\n//                 return '' + source;\n// \n//             case 'boolean':\n//                 return source ? 'true' : 'false';\n// \n//             case 'object':\n//                 if (!source) {\n//                     return null;\n//                 }\n// \n//                 if (source instanceof Array) {\n//                     return stringifier.arr(source);\n//                 }\n// \n//                 if (source instanceof Date) {\n//                     return stringifier.date(source);\n//                 }\n// \n//                 return stringifier.obj(source);\n//         }\n// \n//         throw new Error('Cannot Stringify:' + source);\n//     }\n// };\n// \n// /**\n//  * 生成组件 renderer 时 ctx 对象构建的代码\n//  *\n//  * @inner\n//  * @param {Object} component 组件实例\n//  * @return {string}\n//  */\n// function genComponentContextCode(component) {\n//     var code = ['var componentCtx = {'];\n// \n//     // given anode\n//     code.push('givenSlots: [],');\n// \n//     // filters\n//     code.push('filters: {');\n//     var filterCode = [];\n//     for (var key in component.filters) {\n//         var filter = component.filters[key];\n// \n//         if (typeof filter === 'function') {\n//             filterCode.push(key + ': ' + filter.toString());\n//         }\n//     }\n//     code.push(filterCode.join(','));\n//     code.push('},');\n// \n//     code.push(\n//         'callFilter: function (name, args) {',\n//         '    var filter = this.filters[name] || DEFAULT_FILTERS[name];',\n//         '    if (typeof filter === \"function\") {',\n//         '        return filter.apply(this, args);',\n//         '    }',\n//         '},'\n//     );\n// \n//     /* eslint-disable no-redeclare */\n//     // computed obj\n//     code.push('computed: {');\n//     var computedCode = [];\n//     for (var key in component.computed) {\n//         var computed = component.computed[key];\n// \n//         if (typeof computed === 'function') {\n//             computedCode.push(key + ': '\n//                 + computed.toString().replace(\n//                     /this.data.get\\(([^\\)]+)\\)/g,\n//                     function (match, exprLiteral) {\n//                         var exprStr = (new Function('return ' + exprLiteral))();\n//                         var expr = parseExpr(exprStr);\n// \n//                         return compileExprSource.expr(expr);\n//                     })\n//             );\n//         }\n//     }\n//     code.push(computedCode.join(','));\n//     code.push('},');\n// \n//     // computed names\n//     code.push('computedNames: [');\n//     computedCode = [];\n//     for (var key in component.computed) {\n//         var computed = component.computed[key];\n// \n//         if (typeof computed === 'function') {\n//             computedCode.push('\"' + key + '\"');\n//         }\n//     }\n//     code.push(computedCode.join(','));\n//     code.push('],');\n//     /* eslint-enable no-redeclare */\n// \n//     // data\n//     code.push('data: ' + stringifier.any(component.data.get()) + ',');\n// \n//     // tagName\n//     code.push('tagName: \"' + component.tagName + '\"');\n//     code.push('};');\n// \n//     return code.join('\\n');\n// }\n// \n// /* eslint-enable guard-for-in */\n// \n// /* eslint-disable no-unused-vars */\n// /* eslint-disable fecs-camelcase */\n// \n// /**\n//  * 组件编译的模板函数\n//  *\n//  * @inner\n//  */\n// function componentCompilePreCode() {\n//     var $version = '3.6.1';\n// \n//     function extend(target, source) {\n//         if (source) {\n//             Object.keys(source).forEach(function (key) {\n//                 let value = source[key];\n//                 if (typeof value !== 'undefined') {\n//                     target[key] = value;\n//                 }\n//             });\n//         }\n// \n//         return target;\n//     }\n// \n//     function each(array, iterator) {\n//         if (array && array.length > 0) {\n//             for (var i = 0, l = array.length; i < l; i++) {\n//                 if (iterator(array[i], i) === false) {\n//                     break;\n//                 }\n//             }\n//         }\n//     }\n// \n//     function contains(array, value) {\n//         var result;\n//         each(array, function (item) {\n//             result = item === value;\n//             return !result;\n//         });\n// \n//         return result;\n//     }\n// \n//     var HTML_ENTITY = {\n//         /* jshint ignore:start */\n//         '&': '&amp;',\n//         '<': '&lt;',\n//         '>': '&gt;',\n//         '\"': '&quot;',\n//         /* eslint-disable quotes */\n//         \"'\": '&#39;'\n//         /* eslint-enable quotes */\n//         /* jshint ignore:end */\n//     };\n// \n//     function htmlFilterReplacer(c) {\n//         return HTML_ENTITY[c];\n//     }\n// \n//     function escapeHTML(source) {\n//         if (source == null) {\n//             return '';\n//         }\n// \n//         return String(source).replace(/[&<>\"']/g, htmlFilterReplacer);\n//     }\n// \n//     var DEFAULT_FILTERS = {\n//         url: encodeURIComponent,\n//         _class: function (source) {\n//             if (source instanceof Array) {\n//                 return source.join(' ');\n//             }\n// \n//             return source;\n//         },\n//         _style: function (source) {\n//             if (typeof source === 'object') {\n//                 var result = '';\n//                 if (source) {\n//                     Object.keys(source).forEach(function (key) {\n//                         result += key + ':' + source[key] + ';';\n//                     });\n//                 }\n// \n//                 return result;\n//             }\n// \n//             return source || '';\n//         },\n//         _sep: function (source, sep) {\n//             return source ? sep + source : '';\n//         }\n//     };\n// \n//     function attrFilter(name, value) {\n//         if (value) {\n//             return ' ' + name + '=\"' + value + '\"';\n//         }\n// \n//         return '';\n//     }\n// \n//     function boolAttrFilter(name, value) {\n//         if (value && value !== 'false' && value !== '0') {\n//             return ' ' + name;\n//         }\n// \n//         return '';\n//     }\n// \n//     function stringLiteralize(source) {\n//         return '\"'\n//             + source\n//                 .replace(/\\x5C/g, '\\\\\\\\')\n//                 .replace(/\"/g, '\\\\\"')\n//                 .replace(/\\x0A/g, '\\\\n')\n//                 .replace(/\\x09/g, '\\\\t')\n//                 .replace(/\\x0D/g, '\\\\r')\n//             + '\"';\n//     }\n// \n//     var stringifier = {\n//         obj: function (source) {\n//             var prefixComma;\n//             var result = '{';\n// \n//             Object.keys(source).forEach(function (key) {\n//                 if (typeof source[key] === 'undefined') {\n//                     return;\n//                 }\n// \n//                 if (prefixComma) {\n//                     result += ',';\n//                 }\n//                 prefixComma = 1;\n// \n//                 result += stringLiteralize(key) + ':' + stringifier.any(source[key]);\n//             });\n// \n//             return result + '}';\n//         },\n// \n//         arr: function (source) {\n//             var prefixComma;\n//             var result = '[';\n// \n//             each(source, function (value) {\n//                 if (prefixComma) {\n//                     result += ',';\n//                 }\n//                 prefixComma = 1;\n// \n//                 result += stringifier.any(value);\n//             });\n// \n//             return result + ']';\n//         },\n// \n//         str: function (source) {\n//             return stringLiteralize(source);\n//         },\n// \n//         date: function (source) {\n//             return 'new Date(' + source.getTime() + ')';\n//         },\n// \n//         any: function (source) {\n//             switch (typeof source) {\n//                 case 'string':\n//                     return stringifier.str(source);\n// \n//                 case 'number':\n//                     return '' + source;\n// \n//                 case 'boolean':\n//                     return source ? 'true' : 'false';\n// \n//                 case 'object':\n//                     if (!source) {\n//                         return null;\n//                     }\n// \n//                     if (source instanceof Array) {\n//                         return stringifier.arr(source);\n//                     }\n// \n//                     if (source instanceof Date) {\n//                         return stringifier.date(source);\n//                     }\n// \n//                     return stringifier.obj(source);\n//             }\n// \n//             throw new Error('Cannot Stringify:' + source);\n//         }\n//     };\n// }\n// /* eslint-enable no-unused-vars */\n// /* eslint-enable fecs-camelcase */\n// \n// /**\n//  * 将组件编译成 render 方法的 js 源码\n//  *\n//  * @param {Function} ComponentClass 组件类\n//  * @return {string}\n//  */\n// function compileJSSource(ComponentClass) {\n//     var sourceBuffer = new CompileSourceBuffer();\n// \n//     sourceBuffer.addRendererStart();\n//     sourceBuffer.addRaw(\n//         componentCompilePreCode.toString()\n//             .split('\\n')\n//             .slice(1)\n//             .join('\\n')\n//             .replace(/\\}\\s*$/, '')\n//     );\n// \n//     // 先初始化个实例，让模板编译成 ANode，并且能获得初始化数据\n//     var component = new ComponentClass();\n// \n//     compileComponentSource(sourceBuffer, component);\n//     sourceBuffer.addRendererEnd();\n//     return sourceBuffer.toCode();\n// }\n// #[end]\n\n// exports = module.exports = compileJSSource;\n\n    /* eslint-disable no-unused-vars */\n//     var nextTick = require('./util/next-tick');\n//     var inherits = require('./util/inherits');\n//     var parseTemplate = require('./parser/parse-template');\n//     var parseExpr = require('./parser/parse-expr');\n//     var ExprType = require('./parser/expr-type');\n//     var LifeCycle = require('./view/life-cycle');\n//     var NodeType = require('./view/node-type');\n//     var Component = require('./view/component');\n//     var compileComponent = require('./view/compile-component');\n//     var defineComponent = require('./view/define-component');\n//     var emitDevtool = require('./util/emit-devtool');\n//     var compileJSSource = require('./view/compile-js-source');\n//     var Data = require('./runtime/data');\n//     var evalExpr = require('./runtime/eval-expr');\n//     var DataTypes = require('./util/data-types');\n\n\n    var san = {\n        /**\n         * san版本号\n         *\n         * @type {string}\n         */\n        version: '3.6.1',\n\n        // #[begin] devtool\n//         /**\n//          * 是否开启调试。开启调试时 devtool 会工作\n//          *\n//          * @type {boolean}\n//          */\n//         debug: true,\n        // #[end]\n\n        // #[begin] ssr\n//         /**\n//          * 将组件类编译成 renderer 方法\n//          *\n//          * @param {Function} ComponentClass 组件类\n//          * @return {function(Object):string}\n//          */\n//         compileToRenderer: function (ComponentClass) {\n//             var renderer = ComponentClass.__ssrRenderer;\n// \n//             if (!renderer) {\n//                 var code = compileJSSource(ComponentClass);\n//                 renderer = (new Function('return ' + code))();\n//                 ComponentClass.__ssrRenderer = renderer;\n//             }\n// \n//             return renderer;\n//         },\n// \n//         /**\n//          * 将组件类编译成 renderer 方法的源文件\n//          *\n//          * @param {Function} ComponentClass 组件类\n//          * @return {string}\n//          */\n//         compileToSource: compileJSSource,\n        // #[end]\n\n        /**\n         * 组件基类\n         *\n         * @type {Function}\n         */\n        Component: Component,\n\n        /**\n         * 创建组件类\n         *\n         * @param {Object} proto 组件类的方法表\n         * @return {Function}\n         */\n        defineComponent: defineComponent,\n\n        /**\n         * 编译组件类。预解析template和components\n         *\n         * @param {Function} ComponentClass 组件类\n         */\n        compileComponent: compileComponent,\n\n        /**\n         * 解析 template\n         *\n         * @inner\n         * @param {string} source template 源码\n         * @return {ANode}\n         */\n        parseTemplate: parseTemplate,\n\n        /**\n         * 解析表达式\n         *\n         * @param {string} source 源码\n         * @return {Object}\n         */\n        parseExpr: parseExpr,\n\n        /**\n         * 表达式类型枚举\n         *\n         * @const\n         * @type {Object}\n         */\n        ExprType: ExprType,\n\n        /**\n         * 生命周期\n         */\n        LifeCycle: LifeCycle,\n\n        /**\n         * 节点类型\n         *\n         * @const\n         * @type {Object}\n         */\n        NodeType: NodeType,\n\n        /**\n         * 在下一个更新周期运行函数\n         *\n         * @param {Function} fn 要运行的函数\n         */\n        nextTick: nextTick,\n\n        /**\n         * 数据类\n         *\n         * @class\n         * @param {Object?} data 初始数据\n         * @param {Data?} parent 父级数据对象\n         */\n        Data: Data,\n\n        /**\n         * 计算表达式的值\n         *\n         * @param {Object} expr 表达式对象\n         * @param {Data} data 数据对象\n         * @param {Component=} owner 组件对象，用于表达式中filter的执行\n         * @return {*}\n         */\n        evalExpr: evalExpr,\n\n        /**\n         * 构建类之间的继承关系\n         *\n         * @param {Function} subClass 子类函数\n         * @param {Function} superClass 父类函数\n         */\n        inherits: inherits,\n\n        /**\n         * DataTypes\n         *\n         * @type {Object}\n         */\n        DataTypes: DataTypes\n    };\n\n    // export\n    if (true) {\n        // For CommonJS\n        exports = module.exports = san;\n    }\n    else {}\n\n    // #[begin] devtool\n//     emitDevtool.start(san);\n    // #[end]\n})(this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../_timers-browserify@2.0.10@timers-browserify/main.js */ \"./node_modules/_timers-browserify@2.0.10@timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3NhbkAzLjYuMUBzYW4vZGlzdC9zYW4uanM/M2I3ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLDZCQUE2QjtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7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O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7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Q0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLFdBQVc7QUFDOUIsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvX3NhbkAzLjYuMUBzYW4vZGlzdC9zYW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNhblxuICogQ29weXJpZ2h0IDIwMTYgQmFpZHUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEBmaWxlIOS4u+aWh+S7tlxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIG90YWt1c3RheShvdGFrdXN0YXlAZ21haWwuY29tKVxuICogICAgICAgICBqdW5tZXIoanVubWVyQGZveG1haWwuY29tKVxuICovXG5cbihmdW5jdGlvbiAocm9vdCkge1xuICAgIC8vIOS6uuW3peiwg+aVtOaJk+WMheS7o+eggemhuuW6j++8jOmAmui/h+azqOmHiuaJi+W3peWGmeS4gOS6m+S+nei1llxuLy8gICAgIC8vIHJlcXVpcmUoJy4vdXRpbC9ndWlkJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2VtcHR5Jyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2V4dGVuZCcpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdXRpbC9pbmhlcml0cycpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdXRpbC9lYWNoJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2NvbnRhaW5zJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2JpbmQnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvb24nKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvdW4nKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvc3ZnLXRhZ3MnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvY3JlYXRlLWVsJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi9icm93c2VyL3JlbW92ZS1lbCcpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdXRpbC9uZXh0LXRpY2snKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvaWUnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvaWUtb2xkLXRoYW4tOScpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vYnJvd3Nlci9pbnB1dC1ldmVudC1jb21wYXRpYmxlJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi9icm93c2VyL2F1dG8tY2xvc2UtdGFncycpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdXRpbC9kYXRhLXR5cGVzLmpzJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2NyZWF0ZS1kYXRhLXR5cGVzLWNoZWNrZXIuanMnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3BhcnNlci93YWxrZXInKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3BhcnNlci9jcmVhdGUtYS1ub2RlJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2UtdGVtcGxhdGUnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3J1bnRpbWUvY2hhbmdlLWV4cHItY29tcGFyZScpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vcnVudGltZS9kYXRhLWNoYW5nZS10eXBlJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi9ydW50aW1lL2RlZmF1bHQtZmlsdGVycycpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdmlldy9saWZlLWN5Y2xlJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi92aWV3L25vZGUtdHlwZScpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdmlldy9nZXQtcHJvcC1oYW5kbGVyJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi92aWV3L2lzLWRhdGEtY2hhbmdlLWJ5LWVsZW1lbnQnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3ZpZXcvZXZlbnQtZGVjbGFyYXRpb24tbGlzdGVuZXInKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3ZpZXcvY3JlYXRlLW5vZGUnKTtcblxuXG4gICAgLyoqXG4gKiBAZmlsZSDnlJ/miJDllK/kuIBpZFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vKipcbiAqIOWUr+S4gGlk55qE6LW35aeL5YC8XG4gKlxuICogQGlubmVyXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgZ3VpZEluZGV4ID0gMTtcblxuLyoqXG4gKiDllK/kuIBpZOeahOWJjee8gFxuICpcbiAqIEBpbm5lclxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIGd1aWRQcmVmaXggPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLnRvU3RyaW5nKDE2KS5zbGljZSg4KTtcblxuLyoqXG4gKiDojrflj5bllK/kuIBpZFxuICpcbiAqIEBpbm5lclxuICogQHJldHVybiB7c3RyaW5nfSDllK/kuIBpZFxuICovXG5mdW5jdGlvbiBndWlkKCkge1xuICAgIHJldHVybiAnXycgKyBndWlkUHJlZml4ICsgKGd1aWRJbmRleCsrKTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ3VpZDtcblxuXG4vKipcbiAqIEBmaWxlIOepuuWHveaVsFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vKipcbiAqIOWVpemDveS4jeW5slxuICovXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVtcHR5O1xuXG5cbi8qKlxuICogQGZpbGUg5bGe5oCn5ou36LSdXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOWvueixoeWxnuaAp+aLt+i0nVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQg55uu5qCH5a+56LGhXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIOa6kOWvueixoVxuICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57nm67moIflr7nosaFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuXG5cbi8qKlxuICogQGZpbGUg5p6E5bu657G75LmL6Ze055qE57un5om/5YWz57O7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcblxuLyoqXG4gKiDmnoTlu7rnsbvkuYvpl7TnmoTnu6fmib/lhbPns7tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJDbGFzcyDlrZDnsbvlh73mlbBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ2xhc3Mg54i257G75Ye95pWwXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgLyoganNoaW50IC1XMDU0ICovXG4gICAgdmFyIHN1YkNsYXNzUHJvdG8gPSBzdWJDbGFzcy5wcm90b3R5cGU7XG4gICAgdmFyIEYgPSBuZXcgRnVuY3Rpb24oKTtcbiAgICBGLnByb3RvdHlwZSA9IHN1cGVyQ2xhc3MucHJvdG90eXBlO1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IG5ldyBGKCk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgZXh0ZW5kKHN1YkNsYXNzLnByb3RvdHlwZSwgc3ViQ2xhc3NQcm90byk7XG4gICAgLyoganNoaW50ICtXMDU0ICovXG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGluaGVyaXRzO1xuXG5cbi8qKlxuICogQGZpbGUg6YGN5Y6G5pWw57uEXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8qKlxuICog6YGN5Y6G5pWw57uE6ZuG5ZCIXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkg5pWw57uE5rqQXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFueSxudW1iZXIpOmJvb2xlYW59IGl0ZXJhdG9yIOmBjeWOhuWHveaVsFxuICovXG5mdW5jdGlvbiBlYWNoKGFycmF5LCBpdGVyYXRvcikge1xuICAgIGlmIChhcnJheSAmJiBhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IoYXJyYXlbaV0sIGkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlYWNoO1xuXG5cbi8qKlxuICogQGZpbGUg5Yik5pat5pWw57uE5Lit5piv5ZCm5YyF5ZCr5p+Q6aG5XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4vZWFjaCcpO1xuXG4vKipcbiAqIOWIpOaWreaVsOe7hOS4reaYr+WQpuWMheWQq+afkOmhuVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IOaVsOe7hFxuICogQHBhcmFtIHsqfSB2YWx1ZSDljIXlkKvnmoTpoblcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBlYWNoKGFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXN1bHQgPSBpdGVtID09PSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjb250YWlucztcblxuXG4vKipcbiAqIEBmaWxlIGJpbmTlh73mlbBcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQg5pa55rOV55qE5YW85a655oCn5bCB6KOFXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyDopoFiaW5k55qE5Ye95pWwXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyB0aGlz5oyH5ZCR5a+56LGhXG4gKiBAcGFyYW0gey4uLip9IGFyZ3Mg6aKE6K6+55qE5Yid5aeL5Y+C5pWwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgdmFyIG5hdGl2ZUJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgLy8gI1tiZWdpbl0gYWxsdWFcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHtcbiAgICAvLyAjW2VuZF1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAvLyAjW2JlZ2luXSBhbGx1YVxuICAgIH1cblxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgLy8gI1tlbmRdXG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGJpbmQ7XG5cblxuLyoqXG4gKiBAZmlsZSBET00g5LqL5Lu25oyC6L29XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIERPTSDkuovku7bmjILovb1cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIERPTeWFg+e0oFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIOebkeWQrOWHveaVsFxuICogQHBhcmFtIHtib29sZWFufSBjYXB0dXJlIOaYr+WQpuaYr+aNleiOt+mYtuautVxuICovXG5mdW5jdGlvbiBvbihlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIC8vICNbYmVnaW5dIGFsbHVhXG4gICAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAvLyAjW2VuZF1cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAvLyAjW2JlZ2luXSBhbGx1YVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyAjW2VuZF1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gb247XG5cblxuLyoqXG4gKiBAZmlsZSBET00g5LqL5Lu25Y246L29XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIERPTSDkuovku7bljbjovb1cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIERPTeWFg+e0oFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIOebkeWQrOWHveaVsFxuICogQHBhcmFtIHtib29sZWFufSBjYXB0dXJlIOaYr+WQpuaYr+aNleiOt+mYtuautVxuICovXG5mdW5jdGlvbiB1bihlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIC8vICNbYmVnaW5dIGFsbHVhXG4gICAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAvLyAjW2VuZF1cbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAvLyAjW2JlZ2luXSBhbGx1YVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyAjW2VuZF1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdW47XG5cblxuLyoqXG4gKiBAZmlsZSDlsIblrZfnrKbkuLLpgJflj7fliIfliIbov5Tlm57lr7nosaFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbi8qKlxuICog5bCG5a2X56ym5Liy6YCX5Y+35YiH5YiG6L+U5Zue5a+56LGhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSDmupDlrZfnrKbkuLJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIyT2JqKHNvdXJjZSkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBlYWNoKFxuICAgICAgICBzb3VyY2Uuc3BsaXQoJywnKSxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSAxO1xuICAgICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzcGxpdFN0cjJPYmo7XG5cblxuLyoqXG4gKiBAZmlsZSBTVkfmoIfnrb7ooahcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBzcGxpdFN0cjJPYmogPSByZXF1aXJlKCcuLi91dGlsL3NwbGl0LXN0ci0yLW9iaicpO1xuXG4vKipcbiAqIHN2Z1RhZ3NcbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvc3ZnZHRkLmh0bWwg5Y+q5Y+W5bi455SoXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgc3ZnVGFncyA9IHNwbGl0U3RyMk9iaignJ1xuICAgIC8vIHN0cnVjdHVyZVxuICAgICsgJ3N2ZyxnLGRlZnMsZGVzYyxtZXRhZGF0YSxzeW1ib2wsdXNlLCdcbiAgICAvLyBpbWFnZSAmIHNoYXBlXG4gICAgKyAnaW1hZ2UscGF0aCxyZWN0LGNpcmNsZSxsaW5lLGVsbGlwc2UscG9seWxpbmUscG9seWdvbiwnXG4gICAgLy8gdGV4dFxuICAgICsgJ3RleHQsdHNwYW4sdHJlZix0ZXh0cGF0aCwnXG4gICAgLy8gb3RoZXJcbiAgICArICdtYXJrZXIscGF0dGVybixjbGlwcGF0aCxtYXNrLGZpbHRlcixjdXJzb3IsdmlldyxhbmltYXRlLCdcbiAgICAvLyBmb250XG4gICAgKyAnZm9udCxmb250LWZhY2UsZ2x5cGgsbWlzc2luZy1nbHlwaCcpO1xuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdmdUYWdzO1xuXG5cbi8qKlxuICogQGZpbGUgRE9N5Yib5bu6XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgc3ZnVGFncyA9IHJlcXVpcmUoJy4vc3ZnLXRhZ3MnKTtcblxuLyoqXG4gKiDliJvlu7ogRE9NIOWFg+e0oFxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdGFnTmFtZSB0YWdOYW1lXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWwodGFnTmFtZSkge1xuICAgIGlmIChzdmdUYWdzW3RhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVsO1xuXG5cbi8qKlxuICogQGZpbGUg56e76ZmkRE9NXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOWwhiBET00g5LuO6aG16Z2i5Lit56e76ZmkXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRE9N5YWD57SgXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUVsKGVsKSB7XG4gICAgaWYgKGVsICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZW1vdmVFbDtcblxuXG4vKipcbiAqIEBmaWxlIOWcqOS4i+S4gOS4quaXtumXtOWRqOacn+i/kOihjOS7u+WKoVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8g6K+l5pa55rOV5Y+C54Wn5LqGdnVlMi41LjDnmoTlrp7njrDvvIzmhJ/osKJ2dWXlm6LpmJ9cbi8vIFNFRTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iLzA5NDhkOTk5ZjJmZGRmOWY5MDk5MTk1NjQ5M2Y5NzYyNzNjNWRhMWYvc3JjL2NvcmUvdXRpbC9lbnYuanMjTDY4XG5cblxuLy8gdmFyIGJpbmQgPSByZXF1aXJlKCcuL2JpbmQnKTtcblxuLyoqXG4gKiDkuIvkuIDkuKrlkajmnJ/opoHmiafooYznmoTku7vliqHliJfooahcbiAqXG4gKiBAaW5uZXJcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xudmFyIG5leHRUYXNrcyA9IFtdO1xuXG4vKipcbiAqIOaJp+ihjOS4i+S4gOS4quWRqOacn+S7u+WKoeeahOWHveaVsFxuICpcbiAqIEBpbm5lclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgbmV4dEhhbmRsZXI7XG5cbi8qKlxuICog5rWP6KeI5Zmo5piv5ZCm5pSv5oyB5Y6f55SfUHJvbWlzZVxuICog5a+5UHJvbWlzZeWBmuWIpOaWre+8jOaYr+S4uuS6huemgeeUqOS4gOS6m+S4jeS4peiwqOeahFByb21pc2XnmoRwb2x5ZmlsbFxuICpcbiAqIEBpbm5lclxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnZhciBpc05hdGl2ZVByb21pc2UgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoUHJvbWlzZSk7XG5cbi8qKlxuICog5Zyo5LiL5LiA5Liq5pe26Ze05ZGo5pyf6L+Q6KGM5Lu75YqhXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiDopoHov5DooYznmoTku7vliqHlh73mlbBcbiAqIEBwYXJhbSB7T2JqZWN0PX0gdGhpc0FyZyB0aGlz5oyH5ZCR5a+56LGhXG4gKi9cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCB0aGlzQXJnKSB7XG4gICAgaWYgKHRoaXNBcmcpIHtcbiAgICAgICAgZm4gPSBiaW5kKGZuLCB0aGlzQXJnKTtcbiAgICB9XG4gICAgbmV4dFRhc2tzLnB1c2goZm4pO1xuXG4gICAgaWYgKG5leHRIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhc2tzID0gbmV4dFRhc2tzLnNsaWNlKDApO1xuICAgICAgICBuZXh0VGFza3MgPSBbXTtcbiAgICAgICAgbmV4dEhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0YXNrc1tpXSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOmdnuagh+WHhuaWueazle+8jOS9huaYr+atpOaWueazlemdnuW4uOWQu+WQiOimgeaxguOAglxuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShuZXh0SGFuZGxlcik7XG4gICAgfVxuICAgIC8vIOeUqE1lc3NhZ2VDaGFubmVs5Y675YGac2V0SW1tZWRpYXRl55qEcG9seWZpbGxcbiAgICAvLyDljp/nkIbmmK/lsIbmlrDnmoRtZXNzYWdl5LqL5Lu25Yqg5YWl5Yiw5Y6f5pyJ55qEZG9tIGV2ZW50c+S5i+WQjlxuICAgIGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbmV4dEhhbmRsZXI7XG4gICAgICAgIHBvcnQucG9zdE1lc3NhZ2UoMSk7XG4gICAgfVxuICAgIC8vIGZvciBuYXRpdmUgYXBwXG4gICAgZWxzZSBpZiAoaXNOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dEhhbmRsZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChuZXh0SGFuZGxlciwgMCk7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcblxuXG4vKipcbiAqIEBmaWxlIGll54mI5pys5Y+3XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOS7jnVzZXJBZ2VudOS4rWll54mI5pys5Y+355qE5Yy56YWN5L+h5oGvXG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG52YXIgaWVWZXJzaW9uTWF0Y2ggPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL21zaWVcXHMqKFswLTldKykvaSk7XG5cbi8qKlxuICogaWXniYjmnKzlj7fvvIzpnZ5pZeaXtuS4ujBcbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgaWUgPSBpZVZlcnNpb25NYXRjaCA/IGllVmVyc2lvbk1hdGNoWzFdIC0gMCA6IDA7XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGllO1xuXG5cbi8qKlxuICogQGZpbGUg5piv5ZCmIElFIOW5tuS4lOWwj+S6jiA5XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgaWUgPSByZXF1aXJlKCcuL2llJyk7XG5cbi8vIEhBQ0s6XG4vLyAxLiBJRTjkuIvvvIzorr7nva5pbm5lckhUTUzml7blpoLmnpzku6VodG1sIGNvbW1lbnTlvIDlpLTvvIxjb21tZW505Lya6KKr6Ieq5Yqo5ruk5o6JXG4vLyAgICDkuLrkuobkv53or4FzdHVtcOWtmOWcqO+8jOmcgOimgeiuvue9ruWujGh0bWzlkI7vvIxjcmVhdGVDb21tZW505bm2YXBwZW5kQ2hpbGQvaW5zZXJ0QmVmb3JlXG4vLyAyLiBJRTjkuIvvvIxpbm5lckhUTUzov5jkuI3mlK/mjIFjdXN0b20gZWxlbWVudO+8jOaJgOS7pemcgOimgeeUqGRpduabv+S7o++8jOS4jeeUqGNyZWF0ZUVsZW1lbnRcbi8vIDMuIOiZveeEtklFOOW3sue7j+S8mOWMluS6huWtl+espuS4sivov57mjqXvvIznoo7niYfljJbov57mjqXmgKfog73kuI3lho3pgIDljJZcbi8vICAgIOS9huaYr+eUseS6juS4iumdouWkmuS4quWFvOWuueWcuuaZr+mDveeUqCA8IDkg5Yik5pat77yM5omA5Lul5a2X56ym5Liy6L+e5o6l5Lmf5rK/55SoXG4vLyAgICDmiYDku6Xnu5PmnpzmmK9JRTjkuIvlrZfnrKbkuLLov57mjqXnlKjnmoTmmK/mlbDnu4Rqb2lu55qE5pa55byPXG5cbi8vICNbYmVnaW5dIGFsbHVhXG4vKipcbiAqIOaYr+WQpiBJRSDlubbkuJTlsI/kuo4gOVxuICovXG52YXIgaWVPbGRUaGFuOSA9IGllICYmIGllIDwgOTtcbi8vICNbZW5kXVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpZU9sZFRoYW45O1xuXG5cbi8qKlxuICogQGZpbGUgRE9NIOS6i+S7tuaMgui9vVxuICogQGF1dGhvciBkYWZyb2soby5vQG11Zy5kb2cpXG4gKi9cblxuLyoqXG4gKiBET00g5LqL5Lu25oyC6L29XG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBET03lhYPntKBcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCNXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIGV2ZW50TmFtZSkge1xuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaWdnZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDop6PlhrMgSUU5IOWcqOihqOWNleWFg+e0oOS4reWIoOmZpOWtl+espuaXtuS4jeinpuWPkeS6i+S7tueahOmXrumimFxuICogQGF1dGhvciBkYWZyb2soby5vQG11Zy5kb2cpXG4gKi9cblxuLy8gdmFyIGllID0gcmVxdWlyZSgnLi9pZScpO1xuLy8gdmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xuLy8gdmFyIHRyaWdnZXIgPSByZXF1aXJlKCcuL3RyaWdnZXInKTtcblxuLy8gI1tiZWdpbl0gYWxsdWFcbmlmIChpZSA9PT0gOSkge1xuICAgIG9uKGRvY3VtZW50LCAnc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCBlbC50YWdOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gI1tlbmRdXG5cblxuLyoqXG4gKiBAZmlsZSDoh6rpl63lkIjmoIfnrb7ooahcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBzcGxpdFN0cjJPYmogPSByZXF1aXJlKCcuLi91dGlsL3NwbGl0LXN0ci0yLW9iaicpO1xuXG4vKipcbiAqIOiHqumXreWQiOagh+etvuWIl+ihqFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBhdXRvQ2xvc2VUYWdzID0gc3BsaXRTdHIyT2JqKCdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxrZXlnZW4scGFyYW0sc291cmNlLHRyYWNrLHdicicpO1xuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBhdXRvQ2xvc2VUYWdzO1xuXG5cbi8qKlxuICogQGZpbGUgZGF0YSB0eXBlc1xuICogQGF1dGhvciBsZW9uIDxsdWRhZmFAb3V0bG9vay5jb20+XG4gKi9cblxuLy8gdmFyIGJpbmQgPSByZXF1aXJlKCcuL2JpbmQnKTtcbi8vIHZhciBlbXB0eSA9IHJlcXVpcmUoJy4vZW1wdHknKTtcbi8vIHZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuXG4vLyAjW2JlZ2luXSBlcnJvclxuLy8gdmFyIEFOT05ZTU9VU19DTEFTU19OQU1FID0gJzw8YW5vbnltb3VzPj4nO1xuLy8gXG4vLyAvKipcbi8vICAqIOiOt+WPlueyvuehrueahOexu+Wei1xuLy8gICpcbi8vICAqIEBOT1RFIOWmguaenCBvYmog5piv5LiA5LiqIERPTUVsZW1lbnTvvIzmiJHku6zkvJrov5Tlm54gYGVsZW1lbnRg77ybXG4vLyAgKlxuLy8gICogQHBhcmFtICB7Kn0gb2JqIOebruagh1xuLy8gICogQHJldHVybiB7c3RyaW5nfVxuLy8gICovXG4vLyBmdW5jdGlvbiBnZXREYXRhVHlwZShvYmopIHtcbi8vIFxuLy8gICAgIGlmIChvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKSB7XG4vLyAgICAgICAgIHJldHVybiAnZWxlbWVudCc7XG4vLyAgICAgfVxuLy8gXG4vLyAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbi8vICAgICAgICAgLmNhbGwob2JqKVxuLy8gICAgICAgICAuc2xpY2UoOCwgLTEpXG4vLyAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuLy8gfVxuLy8gI1tlbmRdXG5cbi8qKlxuICog5Yib5bu66ZO+5byP55qE5pWw5o2u57G75Z6L5qCh6aqM5ZmoXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHZhbGlkYXRlIOecn+ato+eahOagoemqjOWZqFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICB2YXIgY2hhaW5lZENoZWNrZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBjaGFpbmVkQ2hlY2tlci5pc1JlcXVpcmVkID0gZW1wdHk7XG5cbiAgICAvLyDlj6rlnKggZXJyb3Ig5Yqf6IO95ZCv55So5pe25omN5pyJ5a6e6ZmF5LiK55qEIGRhdGFUeXBlcyDmo4DmtYtcbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgIHZhciBjaGVja1R5cGUgPSBmdW5jdGlvbiAoaXNSZXF1aXJlZCwgZGF0YSwgZGF0YU5hbWUsIGNvbXBvbmVudE5hbWUsIGZ1bGxEYXRhTmFtZSkge1xuLy8gXG4vLyAgICAgICAgIHZhciBkYXRhVmFsdWUgPSBkYXRhW2RhdGFOYW1lXTtcbi8vICAgICAgICAgdmFyIGRhdGFUeXBlID0gZ2V0RGF0YVR5cGUoZGF0YVZhbHVlKTtcbi8vIFxuLy8gICAgICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVNfQ0xBU1NfTkFNRTtcbi8vIFxuLy8gICAgICAgICAvLyDlpoLmnpzmmK8gbnVsbCDmiJYgdW5kZWZpbmVk77yM6YKj5LmI6KaB5o+Q5YmN6L+U5Zue5ZWmXG4vLyAgICAgICAgIGlmIChkYXRhVmFsdWUgPT0gbnVsbCkge1xuLy8gICAgICAgICAgICAgLy8g5pivIHJlcXVpcmVkIOWwseaKpemUmVxuLy8gICAgICAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbi8vICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbi8vICAgICAgICAgICAgICAgICAgICAgKyAnVGhlIGAnICsgZGF0YU5hbWUgKyAnYCAnXG4vLyAgICAgICAgICAgICAgICAgICAgICsgJ2lzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgJ1xuLy8gICAgICAgICAgICAgICAgICAgICArICdidXQgaXRzIHZhbHVlIGlzICcgKyBkYXRhVHlwZVxuLy8gICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAvLyDkuI3mmK8gcmVxdWlyZWTvvIzpgqPlsLHmmK8gb2sg55qEXG4vLyAgICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICB2YWxpZGF0ZShkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKTtcbi8vIFxuLy8gICAgIH07XG4vLyBcbi8vICAgICBjaGFpbmVkQ2hlY2tlciA9IGJpbmQoY2hlY2tUeXBlLCBudWxsLCBmYWxzZSk7XG4vLyAgICAgY2hhaW5lZENoZWNrZXIuaXNSZXF1aXJlZCA9IGJpbmQoY2hlY2tUeXBlLCBudWxsLCB0cnVlKTtcbiAgICAvLyAjW2VuZF1cblxuXG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrZXI7XG5cbn1cblxuLy8gI1tiZWdpbl0gZXJyb3Jcbi8vIC8qKlxuLy8gICog55Sf5oiQ5Li76KaB57G75Z6L5pWw5o2u5qCh6aqM5ZmoXG4vLyAgKlxuLy8gICogQHBhcmFtICB7c3RyaW5nfSB0eXBlIOS4u+exu+Wei1xuLy8gICogQHJldHVybiB7RnVuY3Rpb259XG4vLyAgKi9cbi8vIGZ1bmN0aW9uIGNyZWF0ZVByaW1hcnlUeXBlQ2hlY2tlcih0eXBlKSB7XG4vLyBcbi8vICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihmdW5jdGlvbiAoZGF0YSwgZGF0YU5hbWUsIGNvbXBvbmVudE5hbWUsIGZ1bGxEYXRhTmFtZSkge1xuLy8gXG4vLyAgICAgICAgIHZhciBkYXRhVmFsdWUgPSBkYXRhW2RhdGFOYW1lXTtcbi8vICAgICAgICAgdmFyIGRhdGFUeXBlID0gZ2V0RGF0YVR5cGUoZGF0YVZhbHVlKTtcbi8vIFxuLy8gICAgICAgICBpZiAoZGF0YVR5cGUgIT09IHR5cGUpIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuLy8gICAgICAgICAgICAgICAgICsgJ0ludmFsaWQgJyArIGNvbXBvbmVudE5hbWUgKyAnIGRhdGEgYCcgKyBmdWxsRGF0YU5hbWUgKyAnYCBvZiB0eXBlJ1xuLy8gICAgICAgICAgICAgICAgICsgJygnICsgZGF0YVR5cGUgKyAnIHN1cHBsaWVkIHRvICcgKyBjb21wb25lbnROYW1lICsgJywgJ1xuLy8gICAgICAgICAgICAgICAgICsgJ2V4cGVjdGVkICcgKyB0eXBlICsgJyknXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICB9KTtcbi8vIFxuLy8gfVxuLy8gXG4vLyBcbi8vIFxuLy8gLyoqXG4vLyAgKiDnlJ/miJAgYXJyYXlPZiDmoKHpqozlmahcbi8vICAqXG4vLyAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gYXJyYXlJdGVtQ2hlY2tlciDmlbDnu4TkuK3mr4/pobnmlbDmja7nmoTmoKHpqozlmahcbi8vICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuLy8gICovXG4vLyBmdW5jdGlvbiBjcmVhdGVBcnJheU9mQ2hlY2tlcihhcnJheUl0ZW1DaGVja2VyKSB7XG4vLyBcbi8vICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihmdW5jdGlvbiAoZGF0YSwgZGF0YU5hbWUsIGNvbXBvbmVudE5hbWUsIGZ1bGxEYXRhTmFtZSkge1xuLy8gXG4vLyAgICAgICAgIGlmICh0eXBlb2YgYXJyYXlJdGVtQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICAgICAgKyAnRGF0YSBgJyArIGRhdGFOYW1lICsgJ2Agb2YgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgJ1xuLy8gICAgICAgICAgICAgICAgICsgJ0RhdGFUeXBlIG5vdGF0aW9uIGluc2lkZSBgYXJyYXlPZmAsIGV4cGVjdGVkIGBmdW5jdGlvbmAnXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuLy8gICAgICAgICB2YXIgZGF0YVR5cGUgPSBnZXREYXRhVHlwZShkYXRhVmFsdWUpO1xuLy8gXG4vLyAgICAgICAgIGlmIChkYXRhVHlwZSAhPT0gJ2FycmF5Jykge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICAgICAgKyAnSW52YWxpZCAnICsgY29tcG9uZW50TmFtZSArICcgZGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIG9mIHR5cGUnXG4vLyAgICAgICAgICAgICAgICAgKyAnKCcgKyBkYXRhVHlwZSArICcgc3VwcGxpZWQgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnLCAnXG4vLyAgICAgICAgICAgICAgICAgKyAnZXhwZWN0ZWQgYXJyYXkpJ1xuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbi8vICAgICAgICAgICAgIGFycmF5SXRlbUNoZWNrZXIoZGF0YVZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUgKyAnWycgKyBpICsgJ10nKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgfSk7XG4vLyBcbi8vIH1cbi8vIFxuLy8gLyoqXG4vLyAgKiDnlJ/miJAgaW5zdGFuY2VPZiDmo4DmtYvlmahcbi8vICAqXG4vLyAgKiBAcGFyYW0gIHtGdW5jdGlvbnxDbGFzc30gZXhwZWN0ZWRDbGFzcyDmnJ/lvoXnmoTnsbtcbi8vICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuLy8gICovXG4vLyBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZU9mQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4vLyBcbi8vICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihmdW5jdGlvbiAoZGF0YSwgZGF0YU5hbWUsIGNvbXBvbmVudE5hbWUsIGZ1bGxEYXRhTmFtZSkge1xuLy8gXG4vLyAgICAgICAgIHZhciBkYXRhVmFsdWUgPSBkYXRhW2RhdGFOYW1lXTtcbi8vIFxuLy8gICAgICAgICBpZiAoZGF0YVZhbHVlIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykge1xuLy8gICAgICAgICAgICAgcmV0dXJuO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdmFyIGRhdGFWYWx1ZUNsYXNzTmFtZSA9IGRhdGFWYWx1ZS5jb25zdHJ1Y3RvciAmJiBkYXRhVmFsdWUuY29uc3RydWN0b3IubmFtZVxuLy8gICAgICAgICAgICAgPyBkYXRhVmFsdWUuY29uc3RydWN0b3IubmFtZVxuLy8gICAgICAgICAgICAgOiBBTk9OWU1PVVNfQ0xBU1NfTkFNRTtcbi8vIFxuLy8gICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTX0NMQVNTX05BTUU7XG4vLyBcbi8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICArICdJbnZhbGlkICcgKyBjb21wb25lbnROYW1lICsgJyBkYXRhIGAnICsgZnVsbERhdGFOYW1lICsgJ2Agb2YgdHlwZSdcbi8vICAgICAgICAgICAgICsgJygnICsgZGF0YVZhbHVlQ2xhc3NOYW1lICsgJyBzdXBwbGllZCB0byAnICsgY29tcG9uZW50TmFtZSArICcsICdcbi8vICAgICAgICAgICAgICsgJ2V4cGVjdGVkIGluc3RhbmNlIG9mICcgKyBleHBlY3RlZENsYXNzTmFtZSArICcpJ1xuLy8gICAgICAgICApO1xuLy8gXG4vLyBcbi8vICAgICB9KTtcbi8vIFxuLy8gfVxuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkCBzaGFwZSDmoKHpqozlmahcbi8vICAqXG4vLyAgKiBAcGFyYW0gIHtPYmplY3R9IHNoYXBlVHlwZXMgc2hhcGUg5qCh6aqM6KeE5YiZXG4vLyAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbi8vICAqL1xuLy8gZnVuY3Rpb24gY3JlYXRlU2hhcGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbi8vIFxuLy8gICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGZ1bmN0aW9uIChkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKSB7XG4vLyBcbi8vICAgICAgICAgaWYgKGdldERhdGFUeXBlKHNoYXBlVHlwZXMpICE9PSAnb2JqZWN0Jykge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICAgICAgKyAnRGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIG9mIGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkICdcbi8vICAgICAgICAgICAgICAgICArICdEYXRhVHlwZSBub3RhdGlvbiBpbnNpZGUgYHNoYXBlYCwgZXhwZWN0ZWQgYG9iamVjdGAnXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuLy8gICAgICAgICB2YXIgZGF0YVR5cGUgPSBnZXREYXRhVHlwZShkYXRhVmFsdWUpO1xuLy8gXG4vLyAgICAgICAgIGlmIChkYXRhVHlwZSAhPT0gJ29iamVjdCcpIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuLy8gICAgICAgICAgICAgICAgICsgJ0ludmFsaWQgJyArIGNvbXBvbmVudE5hbWUgKyAnIGRhdGEgYCcgKyBmdWxsRGF0YU5hbWUgKyAnYCBvZiB0eXBlJ1xuLy8gICAgICAgICAgICAgICAgICsgJygnICsgZGF0YVR5cGUgKyAnIHN1cHBsaWVkIHRvICcgKyBjb21wb25lbnROYW1lICsgJywgJ1xuLy8gICAgICAgICAgICAgICAgICsgJ2V4cGVjdGVkIG9iamVjdCknXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgZm9yICh2YXIgc2hhcGVLZXlOYW1lIGluIHNoYXBlVHlwZXMpIHtcbi8vICAgICAgICAgICAgIGlmIChzaGFwZVR5cGVzLmhhc093blByb3BlcnR5KHNoYXBlS2V5TmFtZSkpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNbc2hhcGVLZXlOYW1lXTtcbi8vICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgPT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgY2hlY2tlcihkYXRhVmFsdWUsIHNoYXBlS2V5TmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lICsgJy4nICsgc2hhcGVLZXlOYW1lKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgIH0pO1xuLy8gXG4vLyB9XG4vLyBcbi8vIC8qKlxuLy8gICog55Sf5oiQIG9uZU9mIOagoemqjOWZqFxuLy8gICpcbi8vICAqIEBwYXJhbSAge0FycmF5fSBleHBlY3RlZEVudW1WYWx1ZXMg5pyf5b6F55qE5p6a5Li+5YC8XG4vLyAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbi8vICAqL1xuLy8gZnVuY3Rpb24gY3JlYXRlT25lT2ZDaGVja2VyKGV4cGVjdGVkRW51bVZhbHVlcykge1xuLy8gXG4vLyAgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZnVuY3Rpb24gKGRhdGEsIGRhdGFOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUpIHtcbi8vIFxuLy8gICAgICAgICBpZiAoZ2V0RGF0YVR5cGUoZXhwZWN0ZWRFbnVtVmFsdWVzKSAhPT0gJ2FycmF5Jykge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICAgICAgKyAnRGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIG9mIGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkICdcbi8vICAgICAgICAgICAgICAgICArICdEYXRhVHlwZSBub3RhdGlvbiBpbnNpZGUgYG9uZU9mYCwgYXJyYXkgaXMgZXhwZWN0ZWQuJ1xuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHZhciBkYXRhVmFsdWUgPSBkYXRhW2RhdGFOYW1lXTtcbi8vIFxuLy8gICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRFbnVtVmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4vLyAgICAgICAgICAgICBpZiAoZGF0YVZhbHVlID09PSBleHBlY3RlZEVudW1WYWx1ZXNbaV0pIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbi8vICAgICAgICAgICAgICsgJ0ludmFsaWQgJyArIGNvbXBvbmVudE5hbWUgKyAnIGRhdGEgYCcgKyBmdWxsRGF0YU5hbWUgKyAnYCBvZiB2YWx1ZSdcbi8vICAgICAgICAgICAgICsgJyhgJyArIGRhdGFWYWx1ZSArICdgIHN1cHBsaWVkIHRvICcgKyBjb21wb25lbnROYW1lICsgJywgJ1xuLy8gICAgICAgICAgICAgKyAnZXhwZWN0ZWQgb25lIG9mICcgKyBleHBlY3RlZEVudW1WYWx1ZXMuam9pbignLCcpICsgJyknXG4vLyAgICAgICAgICk7XG4vLyBcbi8vICAgICB9KTtcbi8vIFxuLy8gfVxuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkCBvbmVPZlR5cGUg5qCh6aqM5ZmoXG4vLyAgKlxuLy8gICogQHBhcmFtICB7QXJyYXk8RnVuY3Rpb24+fSBleHBlY3RlZEVudW1PZlR5cGVWYWx1ZXMg5pyf5b6F55qE5p6a5Li+57G75Z6LXG4vLyAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbi8vICAqL1xuLy8gZnVuY3Rpb24gY3JlYXRlT25lT2ZUeXBlQ2hlY2tlcihleHBlY3RlZEVudW1PZlR5cGVWYWx1ZXMpIHtcbi8vIFxuLy8gICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGZ1bmN0aW9uIChkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKSB7XG4vLyBcbi8vICAgICAgICAgaWYgKGdldERhdGFUeXBlKGV4cGVjdGVkRW51bU9mVHlwZVZhbHVlcykgIT09ICdhcnJheScpIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuLy8gICAgICAgICAgICAgICAgICsgJ0RhdGEgYCcgKyBkYXRhTmFtZSArICdgIG9mIGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkICdcbi8vICAgICAgICAgICAgICAgICArICdEYXRhVHlwZSBub3RhdGlvbiBpbnNpZGUgYG9uZU9mYCwgYXJyYXkgaXMgZXhwZWN0ZWQuJ1xuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHZhciBkYXRhVmFsdWUgPSBkYXRhW2RhdGFOYW1lXTtcbi8vIFxuLy8gICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRFbnVtT2ZUeXBlVmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4vLyBcbi8vICAgICAgICAgICAgIHZhciBjaGVja2VyID0gZXhwZWN0ZWRFbnVtT2ZUeXBlVmFsdWVzW2ldO1xuLy8gXG4vLyAgICAgICAgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgICAgICAgICAgICBjb250aW51ZTtcbi8vICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgdHJ5IHtcbi8vICAgICAgICAgICAgICAgICBjaGVja2VyKGRhdGEsIGRhdGFOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUpO1xuLy8gICAgICAgICAgICAgICAgIC8vIOWmguaenCBjaGVja2VyIOWujOaIkOagoemqjOayoeaKpemUme+8jOmCo+Wwsei/lOWbnuS6hlxuLy8gICAgICAgICAgICAgICAgIHJldHVybjtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4vLyAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5pyJ6ZSZ6K+v77yM6YKj5LmI5bqU6K+l5oqK6ZSZ6K+v5ZCe5o6JXG4vLyAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIC8vIOaJgOacieeahOWPr+aOpeWPlyB0eXBlIOmDveWksei0peS6hu+8jOaJjeS4ouS4gOS4quW8guW4uFxuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbi8vICAgICAgICAgICAgICsgJ0ludmFsaWQgJyArIGNvbXBvbmVudE5hbWUgKyAnIGRhdGEgYCcgKyBkYXRhTmFtZSArICdgIG9mIHZhbHVlJ1xuLy8gICAgICAgICAgICAgKyAnKGAnICsgZGF0YVZhbHVlICsgJ2Agc3VwcGxpZWQgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnKSdcbi8vICAgICAgICAgKTtcbi8vIFxuLy8gICAgIH0pO1xuLy8gXG4vLyB9XG4vLyBcbi8vIC8qKlxuLy8gICog55Sf5oiQIG9iamVjdE9mIOagoemqjOWZqFxuLy8gICpcbi8vICAqIEBwYXJhbSAge0Z1bmN0aW9ufSB0eXBlQ2hlY2tlciDlr7nosaHlsZ7mgKflgLzmoKHpqozlmahcbi8vICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuLy8gICovXG4vLyBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZkNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbi8vIFxuLy8gICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGZ1bmN0aW9uIChkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKSB7XG4vLyBcbi8vICAgICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICAgICAgKyAnRGF0YSBgJyArIGRhdGFOYW1lICsgJ2Agb2YgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgJ1xuLy8gICAgICAgICAgICAgICAgICsgJ0RhdGFUeXBlIG5vdGF0aW9uIGluc2lkZSBgb2JqZWN0T2ZgLCBleHBlY3RlZCBmdW5jdGlvbidcbi8vICAgICAgICAgICAgICk7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICB2YXIgZGF0YVZhbHVlID0gZGF0YVtkYXRhTmFtZV07XG4vLyAgICAgICAgIHZhciBkYXRhVHlwZSA9IGdldERhdGFUeXBlKGRhdGFWYWx1ZSk7XG4vLyBcbi8vICAgICAgICAgaWYgKGRhdGFUeXBlICE9PSAnb2JqZWN0Jykge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICAgICAgKyAnSW52YWxpZCAnICsgY29tcG9uZW50TmFtZSArICcgZGF0YSBgJyArIGRhdGFOYW1lICsgJ2Agb2YgdHlwZSdcbi8vICAgICAgICAgICAgICAgICArICcoJyArIGRhdGFUeXBlICsgJyBzdXBwbGllZCB0byAnICsgY29tcG9uZW50TmFtZSArICcsICdcbi8vICAgICAgICAgICAgICAgICArICdleHBlY3RlZCBvYmplY3QpJ1xuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIGZvciAodmFyIGRhdGFLZXlOYW1lIGluIGRhdGFWYWx1ZSkge1xuLy8gICAgICAgICAgICAgaWYgKGRhdGFWYWx1ZS5oYXNPd25Qcm9wZXJ0eShkYXRhS2V5TmFtZSkpIHtcbi8vICAgICAgICAgICAgICAgICB0eXBlQ2hlY2tlcihcbi8vICAgICAgICAgICAgICAgICAgICAgZGF0YVZhbHVlLFxuLy8gICAgICAgICAgICAgICAgICAgICBkYXRhS2V5TmFtZSxcbi8vICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbi8vICAgICAgICAgICAgICAgICAgICAgZnVsbERhdGFOYW1lICsgJy4nICsgZGF0YUtleU5hbWVcbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyBcbi8vIFxuLy8gICAgIH0pO1xuLy8gXG4vLyB9XG4vLyBcbi8vIC8qKlxuLy8gICog55Sf5oiQIGV4YWN0IOagoemqjOWZqFxuLy8gICpcbi8vICAqIEBwYXJhbSAge09iamVjdH0gc2hhcGVUeXBlcyBvYmplY3Qg5b2i5oCB5a6a5LmJXG4vLyAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbi8vICAqL1xuLy8gZnVuY3Rpb24gY3JlYXRlRXhhY3RDaGVja2VyKHNoYXBlVHlwZXMpIHtcbi8vIFxuLy8gICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGZ1bmN0aW9uIChkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lLCBzZWNyZXQpIHtcbi8vIFxuLy8gICAgICAgICBpZiAoZ2V0RGF0YVR5cGUoc2hhcGVUeXBlcykgIT09ICdvYmplY3QnKSB7XG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbi8vICAgICAgICAgICAgICAgICArICdEYXRhIGAnICsgZGF0YU5hbWUgKyAnYCBvZiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCAnXG4vLyAgICAgICAgICAgICAgICAgKyAnRGF0YVR5cGUgbm90YXRpb24gaW5zaWRlIGBleGFjdGAnXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuLy8gICAgICAgICB2YXIgZGF0YVZhbHVlVHlwZSA9IGdldERhdGFUeXBlKGRhdGFWYWx1ZSk7XG4vLyBcbi8vICAgICAgICAgaWYgKGRhdGFWYWx1ZVR5cGUgIT09ICdvYmplY3QnKSB7XG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbi8vICAgICAgICAgICAgICAgICArICdJbnZhbGlkIGRhdGEgYCcgKyBmdWxsRGF0YU5hbWUgKyAnYCBvZiB0eXBlIGAnICsgZGF0YVZhbHVlVHlwZSArICdgJ1xuLy8gICAgICAgICAgICAgICAgICsgJyhzdXBwbGllZCB0byAnICsgY29tcG9uZW50TmFtZSArICcsIGV4cGVjdGVkIGBvYmplY3RgKSdcbi8vICAgICAgICAgICAgICk7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICB2YXIgYWxsS2V5cyA9IHt9O1xuLy8gXG4vLyAgICAgICAgIC8vIOWFiOWQiOWFpSBzaGFwZVR5cGVzXG4vLyAgICAgICAgIGV4dGVuZChhbGxLZXlzLCBzaGFwZVR5cGVzKTtcbi8vICAgICAgICAgLy8g5YaN5ZCI5YWlIGRhdGFWYWx1ZVxuLy8gICAgICAgICBleHRlbmQoYWxsS2V5cywgZGF0YVZhbHVlKTtcbi8vICAgICAgICAgLy8g5L+d6K+BIGFsbEtleXMg55qE57G75Z6L5q2j56GuXG4vLyBcbi8vICAgICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbi8vICAgICAgICAgICAgIGlmIChhbGxLZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbi8vIFxuLy8gICAgICAgICAgICAgICAgIC8vIGRhdGFWYWx1ZSDkuK3mnInkuIDkuKrlpJrkvZnnmoTmlbDmja7poblcbi8vICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICArICdJbnZhbGlkIGRhdGEgYCcgKyBmdWxsRGF0YU5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCAnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICArICdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4gJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKyAnKGAnICsga2V5ICsgJ2AgaXMgbm90IGRlZmluZWQgaW4gYERhdGFUeXBlcy5leGFjdGApJ1xuLy8gICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBkYXRhVmFsdWUpKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKyAnSW52YWxpZCBkYXRhIGAnICsgZnVsbERhdGFOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2AgJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKyAnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuICdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICsgJyhgJyArIGtleSArICdgIGlzIG1hcmtlZCBgcmVxdWlyZWRgIGluIGBEYXRhVHlwZXMuZXhhY3RgKSdcbi8vICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjaGVja2VyKFxuLy8gICAgICAgICAgICAgICAgICAgICBkYXRhVmFsdWUsXG4vLyAgICAgICAgICAgICAgICAgICAgIGtleSxcbi8vICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbi8vICAgICAgICAgICAgICAgICAgICAgZnVsbERhdGFOYW1lICsgJy4nICsga2V5LFxuLy8gICAgICAgICAgICAgICAgICAgICBzZWNyZXRcbi8vICAgICAgICAgICAgICAgICApO1xuLy8gXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgIH0pO1xuLy8gXG4vLyB9XG4vLyAjW2VuZF1cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIGZlY3MtdmFsaWQtdmFyLWpzZG9jICovXG52YXIgRGF0YVR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGVtcHR5KSxcbiAgICBvYmplY3Q6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZW1wdHkpLFxuICAgIGZ1bmM6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZW1wdHkpLFxuICAgIHN0cmluZzogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihlbXB0eSksXG4gICAgbnVtYmVyOiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGVtcHR5KSxcbiAgICBib29sOiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGVtcHR5KSxcbiAgICBzeW1ib2w6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZW1wdHkpLFxuICAgIGFueTogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcixcbiAgICBhcnJheU9mOiBjcmVhdGVDaGFpbmFibGVDaGVja2VyLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVDaGFpbmFibGVDaGVja2VyLFxuICAgIG9iamVjdE9mOiBjcmVhdGVDaGFpbmFibGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVDaGFpbmFibGVDaGVja2VyXG59O1xuXG4vLyAjW2JlZ2luXSBlcnJvclxuLy8gRGF0YVR5cGVzID0ge1xuLy8gXG4vLyAgICAgYW55OiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGVtcHR5KSxcbi8vIFxuLy8gICAgIC8vIOexu+Wei+ajgOa1i1xuLy8gICAgIGFycmF5OiBjcmVhdGVQcmltYXJ5VHlwZUNoZWNrZXIoJ2FycmF5JyksXG4vLyAgICAgb2JqZWN0OiBjcmVhdGVQcmltYXJ5VHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuLy8gICAgIGZ1bmM6IGNyZWF0ZVByaW1hcnlUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbi8vICAgICBzdHJpbmc6IGNyZWF0ZVByaW1hcnlUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4vLyAgICAgbnVtYmVyOiBjcmVhdGVQcmltYXJ5VHlwZUNoZWNrZXIoJ251bWJlcicpLFxuLy8gICAgIGJvb2w6IGNyZWF0ZVByaW1hcnlUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuLy8gICAgIHN5bWJvbDogY3JlYXRlUHJpbWFyeVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcbi8vIFxuLy8gICAgIC8vIOWkjeWQiOexu+Wei+ajgOa1i1xuLy8gICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZDaGVja2VyLFxuLy8gICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlT2ZDaGVja2VyLFxuLy8gICAgIHNoYXBlOiBjcmVhdGVTaGFwZUNoZWNrZXIsXG4vLyAgICAgb25lT2Y6IGNyZWF0ZU9uZU9mQ2hlY2tlcixcbi8vICAgICBvbmVPZlR5cGU6IGNyZWF0ZU9uZU9mVHlwZUNoZWNrZXIsXG4vLyAgICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mQ2hlY2tlcixcbi8vICAgICBleGFjdDogY3JlYXRlRXhhY3RDaGVja2VyXG4vLyBcbi8vIH07XG4vLyAvKiBlc2xpbnQtZW5hYmxlIGZlY3MtdmFsaWQtdmFyLWpzZG9jICovXG4vLyAjW2VuZF1cblxuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IERhdGFUeXBlcztcblxuXG4vKipcbiAqIEBmaWxlIOWIm+W7uuaVsOaNruajgOa1i+WHveaVsFxuICogQGF1dGhvciBsZW9uPGx1ZGFmYUBvdXRsb29rLmNvbT5cbiAqL1xuXG5cbi8vICNbYmVnaW5dIGVycm9yXG4vLyBcbi8vIC8qKlxuLy8gICog5Yib5bu65pWw5o2u5qOA5rWL5Ye95pWwXG4vLyAgKlxuLy8gICogQHBhcmFtICB7T2JqZWN0fSBkYXRhVHlwZXMgICAgIOaVsOaNruagvOW8j1xuLy8gICogQHBhcmFtICB7c3RyaW5nfSBjb21wb25lbnROYW1lIOe7hOS7tuWQjVxuLy8gICogQHJldHVybiB7RnVuY3Rpb259XG4vLyAgKi9cbi8vIGZ1bmN0aW9uIGNyZWF0ZURhdGFUeXBlc0NoZWNrZXIoZGF0YVR5cGVzLCBjb21wb25lbnROYW1lKSB7XG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDmoKHpqowgZGF0YSDmmK/lkKbmu6HotrMgZGF0YSB0eXBlcyDnmoTmoLzlvI9cbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSAgeyp9IGRhdGEg5pWw5o2uXG4vLyAgICAgICovXG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4vLyBcbi8vICAgICAgICAgZm9yICh2YXIgZGF0YVR5cGVOYW1lIGluIGRhdGFUeXBlcykge1xuLy8gXG4vLyAgICAgICAgICAgICBpZiAoZGF0YVR5cGVzLmhhc093blByb3BlcnR5KGRhdGFUeXBlTmFtZSkpIHtcbi8vIFxuLy8gICAgICAgICAgICAgICAgIHZhciBkYXRhVHlwZUNoZWNrZXIgPSBkYXRhVHlwZXNbZGF0YVR5cGVOYW1lXTtcbi8vIFxuLy8gICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKyBjb21wb25lbnROYW1lICsgJzonICsgZGF0YVR5cGVOYW1lICsgJyBpcyBpbnZhbGlkOyAnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBzYW4uRGF0YVR5cGVzJ1xuLy8gICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgICAgIGRhdGFUeXBlQ2hlY2tlcihcbi8vICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbi8vICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVOYW1lLFxuLy8gICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lLFxuLy8gICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZU5hbWVcbi8vICAgICAgICAgICAgICAgICApO1xuLy8gXG4vLyBcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgfTtcbi8vIFxuLy8gfVxuLy8gXG4vLyAjW2VuZF1cblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEYXRhVHlwZXNDaGVja2VyO1xuXG5cbi8qKlxuICogQGZpbGUg5a2X56ym5Liy5rqQ56CB6K+75Y+W57G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8qKlxuICog5a2X56ym5Liy5rqQ56CB6K+75Y+W57G777yM55So5LqO5qih5p2/5a2X56ym5Liy6Kej5p6Q6L+H56iLXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOimgeivu+WPlueahOWtl+espuS4slxuICovXG5mdW5jdGlvbiBXYWxrZXIoc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5sZW4gPSB0aGlzLnNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5pbmRleCA9IDA7XG59XG5cbi8qKlxuICog6I635Y+W5b2T5YmN5a2X56ym56CBXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5XYWxrZXIucHJvdG90eXBlLmN1cnJlbnRDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJDb2RlKHRoaXMuaW5kZXgpO1xufTtcblxuLyoqXG4gKiDmiKrlj5blrZfnrKbkuLLniYfmrrVcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQg6LW35aeL5L2N572uXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIOe7k+adn+S9jee9rlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5XYWxrZXIucHJvdG90eXBlLmN1dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiDlkJHliY3or7vlj5blrZfnrKZcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2Ug6K+75Y+W5a2X56ym5pWwXG4gKi9cbldhbGtlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICB0aGlzLmluZGV4ICs9IGRpc3RhbmNlO1xufTtcblxuLyoqXG4gKiDor7vlj5bkuIvkuIDkuKrlrZfnrKbvvIzov5Tlm57kuIvkuIDkuKrlrZfnrKbnmoQgY29kZVxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuV2Fsa2VyLnByb3RvdHlwZS5uZXh0Q29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdvKDEpO1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb2RlKCk7XG59O1xuXG4vKipcbiAqIOiOt+WPluebuOW6lOS9jee9ruWtl+espueahCBjb2RlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOWtl+espuS9jee9rlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5XYWxrZXIucHJvdG90eXBlLmNoYXJDb2RlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xufTtcblxuLyoqXG4gKiDlkJHliY3or7vlj5blrZfnrKbvvIznm7TliLDpgYfliLDmjIflrprlrZfnrKblho3lgZzmraJcbiAqIOacquaMh+WumuWtl+espuaXtu+8jOW9k+mBh+WIsOesrOS4gOS4qumdnuepuuagvOOAgeWItuihqOespueahOWtl+espuWBnOatolxuICpcbiAqIEBwYXJhbSB7bnVtYmVyPX0gY2hhckNvZGUg5oyH5a6a5a2X56ym55qEY29kZVxuICogQHJldHVybiB7Ym9vbGVhbn0g5b2T5oyH5a6a5a2X56ym5pe277yM6L+U5Zue5piv5ZCm56Kw5Yiw5oyH5a6a55qE5a2X56ymXG4gKi9cbldhbGtlci5wcm90b3R5cGUuZ29VbnRpbCA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5sZW4gJiYgKGNvZGUgPSB0aGlzLmN1cnJlbnRDb2RlKCkpKSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgLy8g56m65qC8IHNwYWNlXG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgLy8g5Yi26KGo56ymIHRhYlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgLy8gXFxyXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgLy8gXFxuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICog5ZCR5YmN6K+75Y+W56ym5ZCI6KeE5YiZ55qE5a2X56ym54mH5q6177yM5bm26L+U5Zue6KeE5YiZ5Yy56YWN57uT5p6cXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlZyDlrZfnrKbniYfmrrXnmoTmraPliJnooajovr7lvI9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNYXRjaFN0YXJ0IOaYr+WQpuW/hemhu+WMuemFjeW9k+WJjeS9jee9rlxuICogQHJldHVybiB7QXJyYXk/fVxuICovXG5XYWxrZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHJlZywgaXNNYXRjaFN0YXJ0KSB7XG4gICAgcmVnLmxhc3RJbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICB2YXIgbWF0Y2ggPSByZWcuZXhlYyh0aGlzLnNvdXJjZSk7XG4gICAgaWYgKG1hdGNoICYmICghaXNNYXRjaFN0YXJ0IHx8IHRoaXMuaW5kZXggPT09IG1hdGNoLmluZGV4KSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gcmVnLmxhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbn07XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFdhbGtlcjtcblxuXG4vKipcbiAqIEBmaWxlIOaooeadv+ino+aekOeUn+aIkOeahOaKveixoeiKgueCuVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDliJvlu7rmqKHmnb/op6PmnpDnlJ/miJDnmoTmir3osaHoioLngrlcbiAqXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMg6IqC54K55Y+C5pWwXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMudGFnTmFtZSDmoIfnrb7lkI1cbiAqIEBwYXJhbSB7QU5vZGU9fSBvcHRpb25zLnBhcmVudCDniLboioLngrlcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbnMudGV4dEV4cHIg5paH5pys6IqC54K56KGo6L6+5byP5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFOb2RlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghb3B0aW9ucy50ZXh0RXhwcikge1xuICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgfHwge307XG4gICAgICAgIG9wdGlvbnMucHJvcHMgPSBvcHRpb25zLnByb3BzIHx8IFtdO1xuICAgICAgICBvcHRpb25zLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzIHx8IFtdO1xuICAgICAgICBvcHRpb25zLmNoaWxkcmVuID0gb3B0aW9ucy5jaGlsZHJlbiB8fCBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlQU5vZGU7XG5cblxuLyoqXG4gKiBAZmlsZSDmiooga2ViYWIgY2FzZSDlrZfnrKbkuLLovazmjaLmiJAgY2FtZWwgY2FzZVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDmiooga2ViYWIgY2FzZSDlrZfnrKbkuLLovazmjaLmiJAgY2FtZWwgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug5rqQ5a2X56ym5LiyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGtlYmFiMmNhbWVsKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24gKG1hdGNoLCBhbHBoYSkge1xuICAgICAgICByZXR1cm4gYWxwaGEudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ga2ViYWIyY2FtZWw7XG5cblxuLyoqXG4gKiBAZmlsZSDooajovr7lvI/nsbvlnotcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog6KGo6L6+5byP57G75Z6LXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRXhwclR5cGUgPSB7XG4gICAgU1RSSU5HOiAxLFxuICAgIE5VTUJFUjogMixcbiAgICBCT09MOiAzLFxuICAgIEFDQ0VTU09SOiA0LFxuICAgIElOVEVSUDogNSxcbiAgICBDQUxMOiA2LFxuICAgIFRFWFQ6IDcsXG4gICAgQklOQVJZOiA4LFxuICAgIFVOQVJZOiA5LFxuICAgIFRFUlRJQVJZOiAxMCxcbiAgICBPQkpFQ1Q6IDExLFxuICAgIEFSUkFZOiAxMlxufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRXhwclR5cGU7XG5cblxuLyoqXG4gKiBAZmlsZSDliJvlu7rorr/pl67ooajovr7lvI/lr7nosaFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG5cbi8qKlxuICog5Yib5bu66K6/6Zeu6KGo6L6+5byP5a+56LGhXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGF0aHMg6K6/6Zeu6Lev5b6EXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc29yKHBhdGhzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogRXhwclR5cGUuQUNDRVNTT1IsXG4gICAgICAgIHBhdGhzOiBwYXRoc1xuICAgIH07XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFjY2Vzc29yO1xuXG5cbi8qKlxuICogQGZpbGUg6K+75Y+W5a2X56ym5LiyXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG5cbi8qKlxuICog6K+75Y+W5a2X56ym5LiyXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZFN0cmluZyh3YWxrZXIpIHtcbiAgICB2YXIgc3RhcnRDb2RlID0gd2Fsa2VyLmN1cnJlbnRDb2RlKCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSB3YWxrZXIuaW5kZXg7XG4gICAgdmFyIGNoYXJDb2RlO1xuXG4gICAgd2Fsa0xvb3A6IHdoaWxlICgoY2hhckNvZGUgPSB3YWxrZXIubmV4dENvZGUoKSkpIHtcbiAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgY2FzZSA5MjogLy8gXFxcbiAgICAgICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0YXJ0Q29kZTpcbiAgICAgICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICAgICAgYnJlYWsgd2Fsa0xvb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGl0ZXJhbCA9IHdhbGtlci5jdXQoc3RhcnRJbmRleCwgd2Fsa2VyLmluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBFeHByVHlwZS5TVFJJTkcsXG4gICAgICAgIC8vIOWkhOeQhuWtl+espui9rOS5iVxuICAgICAgICB2YWx1ZTogKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBsaXRlcmFsKSkoKVxuICAgIH07XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRTdHJpbmc7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bmlbDlrZdcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcblxuLyoqXG4gKiDor7vlj5bmlbDlrZdcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7V2Fsa2VyfSB3YWxrZXIg5rqQ56CB6K+75Y+W5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlYWROdW1iZXIod2Fsa2VyKSB7XG4gICAgdmFyIG1hdGNoID0gd2Fsa2VyLm1hdGNoKC9cXHMqKC0/WzAtOV0rKFxcLlswLTldKyk/KS9nKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IEV4cHJUeXBlLk5VTUJFUixcbiAgICAgICAgdmFsdWU6ICttYXRjaFsxXVxuICAgIH07XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWROdW1iZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5ZpZGVudFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDor7vlj5ZpZGVudFxuICog6L+Z6YeM55qEIGlkZW50IOaMh+agh+ivhuespihpZGVudGlmaWVyKe+8jOS5n+WwseaYr+mAmuW4uOaEj+S5ieS4iueahOWPmOmHj+WQjVxuICog6L+Z6YeM6buY6K6k55qE5Y+Y6YeP5ZCN6KeE5YiZ5Li677ya55Sx576O5YWD56ym5Y+3KCQp44CB5pWw5a2X44CB5a2X5q+N5oiW6ICF5LiL5YiS57q/KF8p5p6E5oiQ55qE5a2X56ym5LiyXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZWFkSWRlbnQod2Fsa2VyKSB7XG4gICAgdmFyIG1hdGNoID0gd2Fsa2VyLm1hdGNoKC9cXHMqKFtcXCQwLTlhLXpfXSspL2lnLCAxKTtcblxuICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgaWYgKCFtYXRjaCkge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRkFUQUxdIGV4cGVjdCBhbiBpZGVudDogJyArIHdhbGtlci5jdXQod2Fsa2VyLmluZGV4KSk7XG4vLyAgICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgcmV0dXJuIG1hdGNoWzFdO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZWFkSWRlbnQ7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bkuInlhYPooajovr7lvI9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZExvZ2ljYWxPUkV4cHIgPSByZXF1aXJlKCcuL3JlYWQtbG9naWNhbC1vci1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W5LiJ5YWD6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZFRlcnRpYXJ5RXhwcih3YWxrZXIpIHtcbiAgICB2YXIgY29uZGl0aW9uYWwgPSByZWFkTG9naWNhbE9SRXhwcih3YWxrZXIpO1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDYzKSB7IC8vID9cbiAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICB2YXIgeWVzRXhwciA9IHJlYWRUZXJ0aWFyeUV4cHIod2Fsa2VyKTtcbiAgICAgICAgd2Fsa2VyLmdvVW50aWwoKTtcblxuICAgICAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDU4KSB7IC8vIDpcbiAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuVEVSVElBUlksXG4gICAgICAgICAgICAgICAgc2VnczogW1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgeWVzRXhwcixcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRlcnRpYXJ5RXhwcih3YWxrZXIpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb25kaXRpb25hbDtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZFRlcnRpYXJ5RXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluiuv+mXruihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciBjcmVhdGVBY2Nlc3NvciA9IHJlcXVpcmUoJy4vY3JlYXRlLWFjY2Vzc29yJyk7XG4vLyB2YXIgcmVhZElkZW50ID0gcmVxdWlyZSgnLi9yZWFkLWlkZW50Jyk7XG4vLyB2YXIgcmVhZFRlcnRpYXJ5RXhwciA9IHJlcXVpcmUoJy4vcmVhZC10ZXJ0aWFyeS1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W6K6/6Zeu6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZEFjY2Vzc29yKHdhbGtlcikge1xuICAgIHZhciBmaXJzdFNlZyA9IHJlYWRJZGVudCh3YWxrZXIpO1xuICAgIHN3aXRjaCAoZmlyc3RTZWcpIHtcbiAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQk9PTCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmlyc3RTZWcgPT09ICd0cnVlJ1xuICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQWNjZXNzb3IoW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5TVFJJTkcsXG4gICAgICAgICAgICB2YWx1ZTogZmlyc3RTZWdcbiAgICAgICAgfVxuICAgIF0pO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG4gICAgYWNjZXNzb3JMb29wOiB3aGlsZSAoMSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG5cbiAgICAgICAgc3dpdGNoICh3YWxrZXIuY3VycmVudENvZGUoKSkge1xuICAgICAgICAgICAgY2FzZSA0NjogLy8gLlxuICAgICAgICAgICAgICAgIHdhbGtlci5nbygxKTtcblxuICAgICAgICAgICAgICAgIC8vIGlkZW50IGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRocy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuU1RSSU5HLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVhZElkZW50KHdhbGtlcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5MTogLy8gW1xuICAgICAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aHMucHVzaChyZWFkVGVydGlhcnlFeHByKHdhbGtlcikpO1xuICAgICAgICAgICAgICAgIHdhbGtlci5nb1VudGlsKDkzKTsgLy8gXVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrIGFjY2Vzc29yTG9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRBY2Nlc3NvcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluaLrOWPt+ihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIHJlYWRUZXJ0aWFyeUV4cHIgPSByZXF1aXJlKCcuL3JlYWQtdGVydGlhcnktZXhwcicpO1xuXG4vKipcbiAqIOivu+WPluaLrOWPt+ihqOi+vuW8j1xuICpcbiAqIEBwYXJhbSB7V2Fsa2VyfSB3YWxrZXIg5rqQ56CB6K+75Y+W5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlYWRQYXJlbnRoZXNpemVkRXhwcih3YWxrZXIpIHtcbiAgICB3YWxrZXIuZ28oMSk7XG4gICAgdmFyIGV4cHIgPSByZWFkVGVydGlhcnlFeHByKHdhbGtlcik7XG4gICAgd2Fsa2VyLmdvVW50aWwoNDEpOyAvLyApXG5cbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZFBhcmVudGhlc2l6ZWRFeHByO1xuXG5cbi8qKlxuICogQGZpbGUg6K+75Y+W5LiA5YWD6KGo6L6+5byPXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIHJlYWRTdHJpbmcgPSByZXF1aXJlKCcuL3JlYWQtc3RyaW5nJyk7XG4vLyB2YXIgcmVhZE51bWJlciA9IHJlcXVpcmUoJy4vcmVhZC1udW1iZXInKTtcbi8vIHZhciByZWFkQWNjZXNzb3IgPSByZXF1aXJlKCcuL3JlYWQtYWNjZXNzb3InKTtcbi8vIHZhciByZWFkUGFyZW50aGVzaXplZEV4cHIgPSByZXF1aXJlKCcuL3JlYWQtcGFyZW50aGVzaXplZC1leHByJyk7XG5cblxuLyoqXG4gKiDor7vlj5bkuIDlhYPooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkVW5hcnlFeHByKHdhbGtlcikge1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICBzd2l0Y2ggKHdhbGtlci5jdXJyZW50Q29kZSgpKSB7XG4gICAgICAgIGNhc2UgMzM6IC8vICFcbiAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuVU5BUlksXG4gICAgICAgICAgICAgICAgZXhwcjogcmVhZFVuYXJ5RXhwcih3YWxrZXIpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgMzQ6IC8vIFwiXG4gICAgICAgIGNhc2UgMzk6IC8vICdcbiAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKHdhbGtlcik7XG5cbiAgICAgICAgLy8gbnVtYmVyXG4gICAgICAgIGNhc2UgNDU6XG4gICAgICAgIGNhc2UgNDg6XG4gICAgICAgIGNhc2UgNDk6XG4gICAgICAgIGNhc2UgNTA6XG4gICAgICAgIGNhc2UgNTE6XG4gICAgICAgIGNhc2UgNTI6XG4gICAgICAgIGNhc2UgNTM6XG4gICAgICAgIGNhc2UgNTQ6XG4gICAgICAgIGNhc2UgNTU6XG4gICAgICAgIGNhc2UgNTY6XG4gICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICByZXR1cm4gcmVhZE51bWJlcih3YWxrZXIpO1xuXG4gICAgICAgIGNhc2UgNDA6IC8vIChcbiAgICAgICAgICAgIHJldHVybiByZWFkUGFyZW50aGVzaXplZEV4cHIod2Fsa2VyKTtcblxuICAgICAgICAvLyBhcnJheSBsaXRlcmFsXG4gICAgICAgIGNhc2UgOTE6IC8vIFtcbiAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgIHZhciBhcnJJdGVtcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKCF3YWxrZXIuZ29VbnRpbCg5MykpIHsgLy8gXVxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0ge307XG4gICAgICAgICAgICAgICAgYXJySXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmICh3YWxrZXIuY3VycmVudENvZGUoKSA9PT0gNDYgJiYgd2Fsa2VyLm1hdGNoKC9cXC5cXC5cXC5cXHMqL2cpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3ByZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLmV4cHIgPSByZWFkVGVydGlhcnlFeHByKHdhbGtlcik7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmdvVW50aWwoNDQpOyAvLyAsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQVJSQVksXG4gICAgICAgICAgICAgICAgaXRlbXM6IGFyckl0ZW1zXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIG9iamVjdCBsaXRlcmFsXG4gICAgICAgIGNhc2UgMTIzOiAvLyB7XG4gICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICB2YXIgb2JqSXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgd2hpbGUgKCF3YWxrZXIuZ29VbnRpbCgxMjUpKSB7IC8vIH1cbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHt9O1xuICAgICAgICAgICAgICAgIG9iakl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDQ2ICYmIHdhbGtlci5tYXRjaCgvXFwuXFwuXFwuXFxzKi9nKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnNwcmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZXhwciA9IHJlYWRUZXJ0aWFyeUV4cHIod2Fsa2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciB3YWxrZXJJbmRleEJlZm9yZU5hbWUgPSB3YWxrZXIuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubmFtZSA9IHJlYWRVbmFyeUV4cHIod2Fsa2VyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lLnR5cGUgPiA0KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRkFUQUxdIHVuZXhwZWN0IG9iamVjdCBuYW1lOiAnICsgd2Fsa2VyLmN1dCh3YWxrZXJJbmRleEJlZm9yZU5hbWUsIHdhbGtlci5pbmRleCkpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrZXIuZ29VbnRpbCg1OCkpIHsgLy8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5leHByID0gcmVhZFRlcnRpYXJ5RXhwcih3YWxrZXIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmV4cHIgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lLnR5cGUgPT09IEV4cHJUeXBlLkFDQ0VTU09SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm5hbWUgPSBpdGVtLm5hbWUucGF0aHNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3YWxrZXIuZ29VbnRpbCg0NCk7IC8vICxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5PQkpFQ1QsXG4gICAgICAgICAgICAgICAgaXRlbXM6IG9iakl0ZW1zXG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiByZWFkQWNjZXNzb3Iod2Fsa2VyKTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZFVuYXJ5RXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluS5mOazleihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciByZWFkVW5hcnlFeHByID0gcmVxdWlyZSgnLi9yZWFkLXVuYXJ5LWV4cHInKTtcblxuLyoqXG4gKiDor7vlj5bkuZjms5Xooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkTXVsdGlwbGljYXRpdmVFeHByKHdhbGtlcikge1xuICAgIHZhciBleHByID0gcmVhZFVuYXJ5RXhwcih3YWxrZXIpO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgICAgd2Fsa2VyLmdvVW50aWwoKTtcblxuICAgICAgICB2YXIgY29kZSA9IHdhbGtlci5jdXJyZW50Q29kZSgpO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMzc6IC8vICVcbiAgICAgICAgICAgIGNhc2UgNDI6IC8vICpcbiAgICAgICAgICAgIGNhc2UgNDc6IC8vIC9cbiAgICAgICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQklOQVJZLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgc2VnczogW2V4cHIsIHJlYWRVbmFyeUV4cHIod2Fsa2VyKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZE11bHRpcGxpY2F0aXZlRXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluWKoOazleihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciByZWFkTXVsdGlwbGljYXRpdmVFeHByID0gcmVxdWlyZSgnLi9yZWFkLW11bHRpcGxpY2F0aXZlLWV4cHInKTtcblxuXG4vKipcbiAqIOivu+WPluWKoOazleihqOi+vuW8j1xuICpcbiAqIEBwYXJhbSB7V2Fsa2VyfSB3YWxrZXIg5rqQ56CB6K+75Y+W5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlYWRBZGRpdGl2ZUV4cHIod2Fsa2VyKSB7XG4gICAgdmFyIGV4cHIgPSByZWFkTXVsdGlwbGljYXRpdmVFeHByKHdhbGtlcik7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgICB3YWxrZXIuZ29VbnRpbCgpO1xuICAgICAgICB2YXIgY29kZSA9IHdhbGtlci5jdXJyZW50Q29kZSgpO1xuXG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSA0MzogLy8gK1xuICAgICAgICAgICAgY2FzZSA0NTogLy8gLVxuICAgICAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5CSU5BUlksXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICBzZWdzOiBbZXhwciwgcmVhZE11bHRpcGxpY2F0aXZlRXhwcih3YWxrZXIpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZEFkZGl0aXZlRXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluWFs+ezu+WIpOaWreihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciByZWFkQWRkaXRpdmVFeHByID0gcmVxdWlyZSgnLi9yZWFkLWFkZGl0aXZlLWV4cHInKTtcblxuLyoqXG4gKiDor7vlj5blhbPns7vliKTmlq3ooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkUmVsYXRpb25hbEV4cHIod2Fsa2VyKSB7XG4gICAgdmFyIGV4cHIgPSByZWFkQWRkaXRpdmVFeHByKHdhbGtlcik7XG4gICAgd2Fsa2VyLmdvVW50aWwoKTtcblxuICAgIHZhciBjb2RlID0gd2Fsa2VyLmN1cnJlbnRDb2RlKCk7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgNjA6IC8vIDxcbiAgICAgICAgY2FzZSA2MjogLy8gPlxuICAgICAgICAgICAgaWYgKHdhbGtlci5uZXh0Q29kZSgpID09PSA2MSkge1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gNjE7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLkJJTkFSWSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogY29kZSxcbiAgICAgICAgICAgICAgICBzZWdzOiBbZXhwciwgcmVhZEFkZGl0aXZlRXhwcih3YWxrZXIpXVxuICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZFJlbGF0aW9uYWxFeHByO1xuXG5cbi8qKlxuICogQGZpbGUg6K+75Y+W55u4562J5q+U5a+56KGo6L6+5byPXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIHJlYWRSZWxhdGlvbmFsRXhwciA9IHJlcXVpcmUoJy4vcmVhZC1yZWxhdGlvbmFsLWV4cHInKTtcblxuLyoqXG4gKiDor7vlj5bnm7jnrYnmr5Tlr7nooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkRXF1YWxpdHlFeHByKHdhbGtlcikge1xuICAgIHZhciBleHByID0gcmVhZFJlbGF0aW9uYWxFeHByKHdhbGtlcik7XG4gICAgd2Fsa2VyLmdvVW50aWwoKTtcblxuICAgIHZhciBjb2RlID0gd2Fsa2VyLmN1cnJlbnRDb2RlKCk7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgNjE6IC8vID1cbiAgICAgICAgY2FzZSAzMzogLy8gIVxuICAgICAgICAgICAgaWYgKHdhbGtlci5uZXh0Q29kZSgpID09PSA2MSkge1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gNjE7XG4gICAgICAgICAgICAgICAgaWYgKHdhbGtlci5uZXh0Q29kZSgpID09PSA2MSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlICs9IDYxO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQklOQVJZLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgc2VnczogW2V4cHIsIHJlYWRSZWxhdGlvbmFsRXhwcih3YWxrZXIpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdhbGtlci5nbygtMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRFcXVhbGl0eUV4cHI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bpgLvovpHkuI7ooajovr7lvI9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZEVxdWFsaXR5RXhwciA9IHJlcXVpcmUoJy4vcmVhZC1lcXVhbGl0eS1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W6YC76L6R5LiO6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZExvZ2ljYWxBTkRFeHByKHdhbGtlcikge1xuICAgIHZhciBleHByID0gcmVhZEVxdWFsaXR5RXhwcih3YWxrZXIpO1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDM4KSB7IC8vICZcbiAgICAgICAgaWYgKHdhbGtlci5uZXh0Q29kZSgpID09PSAzOCkge1xuICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5CSU5BUlksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IDc2LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtleHByLCByZWFkTG9naWNhbEFOREV4cHIod2Fsa2VyKV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB3YWxrZXIuZ28oLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBleHByO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZWFkTG9naWNhbEFOREV4cHI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bpgLvovpHmiJbooajovr7lvI9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZExvZ2ljYWxBTkRFeHByID0gcmVxdWlyZSgnLi9yZWFkLWxvZ2ljYWwtYW5kLWV4cHInKTtcblxuLyoqXG4gKiDor7vlj5bpgLvovpHmiJbooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkTG9naWNhbE9SRXhwcih3YWxrZXIpIHtcbiAgICB2YXIgZXhwciA9IHJlYWRMb2dpY2FsQU5ERXhwcih3YWxrZXIpO1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDEyNCkgeyAvLyB8XG4gICAgICAgIGlmICh3YWxrZXIubmV4dENvZGUoKSA9PT0gMTI0KSB7XG4gICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLkJJTkFSWSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogMjQ4LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtleHByLCByZWFkTG9naWNhbE9SRXhwcih3YWxrZXIpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhbGtlci5nbygtMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRMb2dpY2FsT1JFeHByO1xuXG5cbi8qKlxuICogQGZpbGUg6Kej5p6Q6KGo6L6+5byPXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgV2Fsa2VyID0gcmVxdWlyZSgnLi93YWxrZXInKTtcbi8vIHZhciByZWFkVGVydGlhcnlFeHByID0gcmVxdWlyZSgnLi9yZWFkLXRlcnRpYXJ5LWV4cHInKTtcblxuLyoqXG4gKiDop6PmnpDooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOa6kOeggVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZUV4cHIoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmIHNvdXJjZS50eXBlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgdmFyIGV4cHIgPSByZWFkVGVydGlhcnlFeHByKG5ldyBXYWxrZXIoc291cmNlKSk7XG4gICAgZXhwci5yYXcgPSBzb3VyY2U7XG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlRXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluiwg+eUqFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciByZWFkQWNjZXNzb3IgPSByZXF1aXJlKCcuL3JlYWQtYWNjZXNzb3InKTtcbi8vIHZhciByZWFkVGVydGlhcnlFeHByID0gcmVxdWlyZSgnLi9yZWFkLXRlcnRpYXJ5LWV4cHInKTtcblxuLyoqXG4gKiDor7vlj5bosIPnlKhcbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHBhcmFtIHtBcnJheT19IGRlZmF1bHRBcmdzIOm7mOiupOWPguaVsFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkQ2FsbCh3YWxrZXIsIGRlZmF1bHRBcmdzKSB7XG4gICAgd2Fsa2VyLmdvVW50aWwoKTtcbiAgICB2YXIgaWRlbnQgPSByZWFkQWNjZXNzb3Iod2Fsa2VyKTtcbiAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgaWYgKHdhbGtlci5nb1VudGlsKDQwKSkgeyAvLyAoXG4gICAgICAgIHdoaWxlICghd2Fsa2VyLmdvVW50aWwoNDEpKSB7IC8vIClcbiAgICAgICAgICAgIGFyZ3MucHVzaChyZWFkVGVydGlhcnlFeHByKHdhbGtlcikpO1xuICAgICAgICAgICAgd2Fsa2VyLmdvVW50aWwoNDQpOyAvLyAsXG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmYXVsdEFyZ3MpIHtcbiAgICAgICAgYXJncyA9IGRlZmF1bHRBcmdzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IEV4cHJUeXBlLkNBTEwsXG4gICAgICAgIG5hbWU6IGlkZW50LFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZENhbGw7XG5cblxuLyoqXG4gKiBAZmlsZSDop6PmnpDosIPnlKhcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIFdhbGtlciA9IHJlcXVpcmUoJy4vd2Fsa2VyJyk7XG4vLyB2YXIgcmVhZENhbGwgPSByZXF1aXJlKCcuL3JlYWQtY2FsbCcpO1xuXG4vKipcbiAqIOino+aekOiwg+eUqFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug5rqQ56CBXG4gKiBAcGFyYW0ge0FycmF5PX0gZGVmYXVsdEFyZ3Mg6buY6K6k5Y+C5pWwXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FsbChzb3VyY2UsIGRlZmF1bHRBcmdzKSB7XG4gICAgdmFyIGV4cHIgPSByZWFkQ2FsbChuZXcgV2Fsa2VyKHNvdXJjZSksIGRlZmF1bHRBcmdzKTtcbiAgICBleHByLnJhdyA9IHNvdXJjZTtcbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcGFyc2VDYWxsO1xuXG5cbi8qKlxuICogQGZpbGUg6Kej5p6Q5o+S5YC85pu/5o2iXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgV2Fsa2VyID0gcmVxdWlyZSgnLi93YWxrZXInKTtcbi8vIHZhciByZWFkVGVydGlhcnlFeHByID0gcmVxdWlyZSgnLi9yZWFkLXRlcnRpYXJ5LWV4cHInKTtcbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZENhbGwgPSByZXF1aXJlKCcuL3JlYWQtY2FsbCcpO1xuXG4vKipcbiAqIOino+aekOaPkuWAvOabv+aNolxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug5rqQ56CBXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50ZXJwKHNvdXJjZSkge1xuICAgIHZhciB3YWxrZXIgPSBuZXcgV2Fsa2VyKHNvdXJjZSk7XG5cbiAgICB2YXIgaW50ZXJwID0ge1xuICAgICAgICB0eXBlOiBFeHByVHlwZS5JTlRFUlAsXG4gICAgICAgIGV4cHI6IHJlYWRUZXJ0aWFyeUV4cHIod2Fsa2VyKSxcbiAgICAgICAgZmlsdGVyczogW10sXG4gICAgICAgIHJhdzogc291cmNlXG4gICAgfTtcblxuICAgIHdoaWxlICh3YWxrZXIuZ29VbnRpbCgxMjQpKSB7IC8vIHxcbiAgICAgICAgdmFyIGNhbGxFeHByID0gcmVhZENhbGwod2Fsa2VyKTtcbiAgICAgICAgc3dpdGNoIChjYWxsRXhwci5uYW1lLnBhdGhzWzBdLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICAgICAgaW50ZXJwLm9yaWdpbmFsID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW50ZXJwLmZpbHRlcnMucHVzaChjYWxsRXhwcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJwO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBwYXJzZUludGVycDtcblxuXG4vKipcbiAqIEBmaWxlIOino+eggSBIVE1MIOWtl+espuWunuS9k1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxudmFyIEVOVElUWV9ERUNPREVfTUFQID0ge1xuICAgIGx0OiAnPCcsXG4gICAgZ3Q6ICc+JyxcbiAgICBuYnNwOiAnICcsXG4gICAgcXVvdDogJ1xcXCInLFxuICAgIGVtc3A6ICdcXHUyMDAzJyxcbiAgICBlbnNwOiAnXFx1MjAwMicsXG4gICAgdGhpbnNwOiAnXFx1MjAwOScsXG4gICAgY29weTogJ1xceGE5JyxcbiAgICByZWc6ICdcXHhhZScsXG4gICAgenduajogJ1xcdTIwMGMnLFxuICAgIHp3ajogJ1xcdTIwMGQnLFxuICAgIGFtcDogJyYnXG59O1xuXG4vKipcbiAqIOino+eggSBIVE1MIOWtl+espuWunuS9k1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug6KaB6Kej56CB55qE5a2X56ym5LiyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZUhUTUxFbnRpdHkoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZVxuICAgICAgICAucmVwbGFjZSgvJiMoWzAtOV0rKTsvZywgZnVuY3Rpb24gKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgrY29kZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKC8mI3goWzAtOWEtZl0rKTsvaWcsIGZ1bmN0aW9uIChtYXRjaCwgY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY29kZSwgMTYpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlcGxhY2UoLyYoW2Etel0rKTsvaWcsIGZ1bmN0aW9uIChtYXRjaCwgY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIEVOVElUWV9ERUNPREVfTUFQW2NvZGVdIHx8IG1hdGNoO1xuICAgICAgICB9KTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVjb2RlSFRNTEVudGl0eTtcblxuXG4vKipcbiAqIEBmaWxlIOino+aekOaWh+acrFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIFdhbGtlciA9IHJlcXVpcmUoJy4vd2Fsa2VyJyk7XG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIHBhcnNlSW50ZXJwID0gcmVxdWlyZSgnLi9wYXJzZS1pbnRlcnAnKTtcbi8vIHZhciBkZWNvZGVIVE1MRW50aXR5ID0gcmVxdWlyZSgnLi4vdXRpbC9kZWNvZGUtaHRtbC1lbnRpdHknKTtcblxuLyoqXG4gKiDlr7nlrZfnrKbkuLLov5vooYzlj6/nlKjkuo5uZXcgUmVnRXhw55qE5a2X6Z2i5YyWXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOmcgOimgeWtl+mdouWMlueahOWtl+espuS4slxuICogQHJldHVybiB7c3RyaW5nfSDlrZfnrKbkuLLlrZfpnaLljJbnu5PmnpxcbiAqL1xuZnVuY3Rpb24gcmVnZXhwTGl0ZXJhbChzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoL1tcXF5cXFtcXF1cXCRcXChcXClcXHtcXH1cXD9cXCpcXC5cXCtcXFxcXS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgYztcbiAgICB9KTtcbn1cblxuLyoqXG4gKiDop6PmnpDmlofmnKxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOa6kOeggVxuICogQHBhcmFtIHtBcnJheT99IGRlbGltaXRlcnMg5YiG6ZqU56ym44CC6buY6K6k5Li6IFsne3snLCAnfX0nXVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZVRleHQoc291cmNlLCBkZWxpbWl0ZXJzKSB7XG4gICAgZGVsaW1pdGVycyA9IGRlbGltaXRlcnMgfHwgWyd7eycsICd9fSddO1xuICAgIHZhciBleHByU3RhcnRSZWcgPSBuZXcgUmVnRXhwKFxuICAgICAgICByZWdleHBMaXRlcmFsKGRlbGltaXRlcnNbMF0pICsgJ1xcXFxzKihbXFxcXHNcXFxcU10rPylcXFxccyonICsgcmVnZXhwTGl0ZXJhbChkZWxpbWl0ZXJzWzFdKSxcbiAgICAgICAgJ2lnJ1xuICAgICk7XG5cbiAgICB2YXIgZXhwck1hdGNoO1xuXG4gICAgdmFyIHdhbGtlciA9IG5ldyBXYWxrZXIoc291cmNlKTtcbiAgICB2YXIgYmVmb3JlSW5kZXggPSAwO1xuXG4gICAgdmFyIGV4cHIgPSB7XG4gICAgICAgIHR5cGU6IEV4cHJUeXBlLlRFWFQsXG4gICAgICAgIHNlZ3M6IFtdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHB1c2hTdHJpbmdUb1NlZyh0ZXh0KSB7XG4gICAgICAgIHRleHQgJiYgZXhwci5zZWdzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuU1RSSU5HLFxuICAgICAgICAgICAgbGl0ZXJhbDogdGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVIVE1MRW50aXR5KHRleHQpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWxpbUVuZExlbiA9IGRlbGltaXRlcnNbMV0ubGVuZ3RoO1xuICAgIHdoaWxlICgoZXhwck1hdGNoID0gd2Fsa2VyLm1hdGNoKGV4cHJTdGFydFJlZykpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGludGVycFNvdXJjZSA9IGV4cHJNYXRjaFsxXTtcbiAgICAgICAgdmFyIGludGVycExlbiA9IGV4cHJNYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGlmICh3YWxrZXIuY3V0KHdhbGtlci5pbmRleCArIDEgLSBkZWxpbUVuZExlbiwgd2Fsa2VyLmluZGV4ICsgMSkgPT09IGRlbGltaXRlcnNbMV0pIHtcbiAgICAgICAgICAgIGludGVycFNvdXJjZSArPSB3YWxrZXIuY3V0KHdhbGtlci5pbmRleCwgd2Fsa2VyLmluZGV4ICsgMSk7XG4gICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICBpbnRlcnBMZW4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2hTdHJpbmdUb1NlZyh3YWxrZXIuY3V0KFxuICAgICAgICAgICAgYmVmb3JlSW5kZXgsXG4gICAgICAgICAgICB3YWxrZXIuaW5kZXggLSBpbnRlcnBMZW5cbiAgICAgICAgKSk7XG5cbiAgICAgICAgdmFyIGludGVycCA9IHBhcnNlSW50ZXJwKGludGVycFNvdXJjZSk7XG4gICAgICAgIGV4cHIub3JpZ2luYWwgPSBleHByLm9yaWdpbmFsIHx8IGludGVycC5vcmlnaW5hbDtcbiAgICAgICAgZXhwci5zZWdzLnB1c2goaW50ZXJwKTtcblxuICAgICAgICBiZWZvcmVJbmRleCA9IHdhbGtlci5pbmRleDtcbiAgICB9XG5cbiAgICBwdXNoU3RyaW5nVG9TZWcod2Fsa2VyLmN1dChiZWZvcmVJbmRleCkpO1xuXG5cblxuICAgIGlmIChleHByLnNlZ3MubGVuZ3RoID09PSAxICYmIGV4cHIuc2Vnc1swXS50eXBlID09PSBFeHByVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgZXhwci52YWx1ZSA9IGV4cHIuc2Vnc1swXS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcGFyc2VUZXh0O1xuXG5cbi8qKlxuICogQGZpbGUg6Kej5p6Q5oyH5LukXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBXYWxrZXIgPSByZXF1aXJlKCcuL3dhbGtlcicpO1xuLy8gdmFyIHBhcnNlRXhwciA9IHJlcXVpcmUoJy4vcGFyc2UtZXhwcicpO1xuLy8gdmFyIHBhcnNlQ2FsbCA9IHJlcXVpcmUoJy4vcGFyc2UtY2FsbCcpO1xuLy8gdmFyIHBhcnNlVGV4dCA9IHJlcXVpcmUoJy4vcGFyc2UtdGV4dCcpO1xuLy8gdmFyIHJlYWRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vcmVhZC1hY2Nlc3NvcicpO1xuLy8gdmFyIHJlYWRVbmFyeUV4cHIgPSByZXF1aXJlKCcuL3JlYWQtdW5hcnktZXhwcicpO1xuXG4vKipcbiAqIOaMh+S7pOino+aekOWZqFxuICpcbiAqIEBpbm5lclxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGRpcmVjdGl2ZVBhcnNlcnMgPSB7XG4gICAgJ2Zvcic6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgd2Fsa2VyID0gbmV3IFdhbGtlcih2YWx1ZSk7XG4gICAgICAgIHZhciBtYXRjaCA9IHdhbGtlci5tYXRjaCgvXlxccyooW1xcJDAtOWEtel9dKykoXFxzKixcXHMqKFtcXCQwLTlhLXpfXSspKT9cXHMraW5cXHMrL2lnLCAxKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSB7XG4gICAgICAgICAgICAgICAgaXRlbTogcGFyc2VFeHByKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyc2VFeHByKG1hdGNoWzNdIHx8ICckaW5kZXgnKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVhZFVuYXJ5RXhwcih3YWxrZXIpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAod2Fsa2VyLm1hdGNoKC9cXHMrdHJhY2tieVxccysvaWcsIDEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gd2Fsa2VyLmluZGV4O1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS50cmFja0J5ID0gcmVhZEFjY2Vzc29yKHdhbGtlcik7XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLnRyYWNrQnkucmF3ID0gd2Fsa2VyLmN1dChzdGFydCwgd2Fsa2VyLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXJlY3RpdmU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRkFUQUxdIGZvciBzeW50YXggZXJyb3I6ICcgKyB2YWx1ZSk7XG4gICAgICAgIC8vICNbZW5kXVxuICAgIH0sXG5cbiAgICAncmVmJzogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VUZXh0KHZhbHVlLCBvcHRpb25zLmRlbGltaXRlcnMpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgICdpZic6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlRXhwcih2YWx1ZS5yZXBsYWNlKC8oXlxce1xce3xcXH1cXH0kKS9nLCAnJykpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgICdlbGlmJzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VFeHByKHZhbHVlLnJlcGxhY2UoLyheXFx7XFx7fFxcfVxcfSQpL2csICcnKSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgJ2Vsc2UnOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAnYmluZCc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlRXhwcih2YWx1ZS5yZXBsYWNlKC8oXlxce1xce3xcXH1cXH0kKS9nLCAnJykpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgICdodG1sJzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VFeHByKHZhbHVlLnJlcGxhY2UoLyheXFx7XFx7fFxcfVxcfSQpL2csICcnKSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgJ3RyYW5zaXRpb24nOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUNhbGwodmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiDop6PmnpDmjIfku6RcbiAqXG4gKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDmir3osaHoioLngrlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOaMh+S7pOWQjeensFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIOaMh+S7pOWAvFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg6Kej5p6Q5Y+C5pWwXG4gKiBAcGFyYW0ge0FycmF5P30gb3B0aW9ucy5kZWxpbWl0ZXJzIOaPkuWAvOWIhumalOespuWIl+ihqFxuICovXG5mdW5jdGlvbiBwYXJzZURpcmVjdGl2ZShhTm9kZSwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2Vsc2UtaWYnKSB7XG4gICAgICAgIG5hbWUgPSAnZWxpZic7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IGRpcmVjdGl2ZVBhcnNlcnNbbmFtZV07XG4gICAgaWYgKHBhcnNlcikge1xuICAgICAgICAoYU5vZGUuZGlyZWN0aXZlc1tuYW1lXSA9IHBhcnNlcih2YWx1ZSwgb3B0aW9ucykpLnJhdyA9IHZhbHVlO1xuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcGFyc2VEaXJlY3RpdmU7XG5cblxuLyoqXG4gKiBAZmlsZSDlr7nlsZ7mgKfkv6Hmga/ov5vooYzlpITnkIZcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9leHByLXR5cGUnKTtcblxuLyoqXG4gKiDlr7nlsZ7mgKfkv6Hmga/ov5vooYzlpITnkIZcbiAqIOWvuee7hOS7tueahCBiaW5kcyDmiJbogIXnibnmrornmoTlsZ7mgKfvvIjmr5TlpoIgaW5wdXQg55qEIGNoZWNrZWTvvInpnIDopoHlpITnkIZcbiAqXG4gKiDmiYHlubPljJbvvJpcbiAqIOW9kyB0ZXh0IOino+aekOWPquacieS4gOmhueaXtu+8jOimgeS5iOWwseaYryBzdHJpbmfvvIzopoHkuYjlsLHmmK8gaW50ZXJwXG4gKiBpbnRlcnAg5pyJ5Y+v6IO95piv57uR5a6a5Yiw57uE5Lu25bGe5oCn55qE6KGo6L6+5byP77yM5LiN5biM5pyb6KKrIGV2YWwgdGV4dCDmiJAgc3RyaW5nXG4gKiDmiYDku6Xov5nph4zlgZrkuKrlpITnkIbvvIzlj6rmnInkuIDpobnml7bnm7TmjqXmir3lh7rmnaVcbiAqXG4gKiBib29s5bGe5oCn77yaXG4gKiDlvZPnu5HlrprpobnmsqHmnInlgLzml7bvvIzpu5jorqTkuLp0cnVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3Ag5bGe5oCn5a+56LGhXG4gKi9cbmZ1bmN0aW9uIHBvc3RQcm9wKHByb3ApIHtcbiAgICB2YXIgZXhwciA9IHByb3AuZXhwcjtcblxuICAgIGlmIChleHByLnR5cGUgPT09IEV4cHJUeXBlLlRFWFQpIHtcbiAgICAgICAgc3dpdGNoIChleHByLnNlZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcHJvcC5leHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5CT09MLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBleHByID0gcHJvcC5leHByID0gZXhwci5zZWdzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IEV4cHJUeXBlLklOVEVSUCAmJiBleHByLmZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AuZXhwciA9IGV4cHIuZXhwcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHBvc3RQcm9wO1xuXG5cbi8qKlxuICogQGZpbGUg6Kej5p6Q5oq96LGh6IqC54K55bGe5oCnXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGtlYmFiMmNhbWVsID0gcmVxdWlyZSgnLi4vdXRpbC9rZWJhYjJjYW1lbCcpO1xuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciBjcmVhdGVBY2Nlc3NvciA9IHJlcXVpcmUoJy4vY3JlYXRlLWFjY2Vzc29yJyk7XG4vLyB2YXIgcGFyc2VFeHByID0gcmVxdWlyZSgnLi9wYXJzZS1leHByJyk7XG4vLyB2YXIgcGFyc2VDYWxsID0gcmVxdWlyZSgnLi9wYXJzZS1jYWxsJyk7XG4vLyB2YXIgcGFyc2VUZXh0ID0gcmVxdWlyZSgnLi9wYXJzZS10ZXh0Jyk7XG4vLyB2YXIgcGFyc2VEaXJlY3RpdmUgPSByZXF1aXJlKCcuL3BhcnNlLWRpcmVjdGl2ZScpO1xuLy8gdmFyIHBvc3RQcm9wID0gcmVxdWlyZSgnLi9wb3N0LXByb3AnKTtcblxuXG4vKipcbiAqIOino+aekOaKveixoeiKgueCueWxnuaAp1xuICpcbiAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg5bGe5oCn5ZCN56ewXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUg5bGe5oCn5YC8XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDop6PmnpDlj4LmlbBcbiAqIEBwYXJhbSB7QXJyYXk/fSBvcHRpb25zLmRlbGltaXRlcnMg5o+S5YC85YiG6ZqU56ym5YiX6KGoXG4gKi9cbmZ1bmN0aW9uIGludGVncmF0ZUF0dHIoYU5vZGUsIG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIHByZWZpeEluZGV4ID0gbmFtZS5pbmRleE9mKCctJyk7XG4gICAgdmFyIHJlYWxOYW1lO1xuICAgIHZhciBwcmVmaXg7XG5cbiAgICBpZiAocHJlZml4SW5kZXggPiAwKSB7XG4gICAgICAgIHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgcHJlZml4SW5kZXgpO1xuICAgICAgICByZWFsTmFtZSA9IG5hbWUuc2xpY2UocHJlZml4SW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHByZWZpeCkge1xuICAgICAgICBjYXNlICdvbic6XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogcmVhbE5hbWUsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYU5vZGUuZXZlbnRzLnB1c2goZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgY29sb25JbmRleDtcbiAgICAgICAgICAgIHdoaWxlICgoY29sb25JbmRleCA9IHZhbHVlLmluZGV4T2YoJzonKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyID0gdmFsdWUuc2xpY2UoMCwgY29sb25JbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBldmVudEhhbmRsZXIoXCJkZDphYVwiKSDov5nnp43mg4XlhrXkuI3og73nrpdtb2RpZmllcu+8jOmcgOimgei+qOivhlxuICAgICAgICAgICAgICAgIGlmICghL15bYS16XSskL2kudGVzdChtb2RpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXZlbnQubW9kaWZpZXJbbW9kaWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKGNvbG9uSW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQuZXhwciA9IHBhcnNlQ2FsbCh2YWx1ZSwgW1xuICAgICAgICAgICAgICAgIGNyZWF0ZUFjY2Vzc29yKFtcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBFeHByVHlwZS5TVFJJTkcsIHZhbHVlOiAnJGV2ZW50JyB9XG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2FuJzpcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBwYXJzZURpcmVjdGl2ZShhTm9kZSwgcmVhbE5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Byb3AnOlxuICAgICAgICAgICAgaW50ZWdyYXRlUHJvcChhTm9kZSwgcmVhbE5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICBpZiAoIWFOb2RlLnZhcnMpIHtcbiAgICAgICAgICAgICAgICBhTm9kZS52YXJzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlYWxOYW1lID0ga2ViYWIyY2FtZWwocmVhbE5hbWUpO1xuICAgICAgICAgICAgYU5vZGUudmFycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiByZWFsTmFtZSxcbiAgICAgICAgICAgICAgICBleHByOiBwYXJzZUV4cHIodmFsdWUucmVwbGFjZSgvKF5cXHtcXHt8XFx9XFx9JCkvZywgJycpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW50ZWdyYXRlUHJvcChhTm9kZSwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiDop6PmnpDmir3osaHoioLngrnnu5HlrprlsZ7mgKdcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg5bGe5oCn5ZCN56ewXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUg5bGe5oCn5YC8XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDop6PmnpDlj4LmlbBcbiAqIEBwYXJhbSB7QXJyYXk/fSBvcHRpb25zLmRlbGltaXRlcnMg5o+S5YC85YiG6ZqU56ym5YiX6KGoXG4gKi9cbmZ1bmN0aW9uIGludGVncmF0ZVByb3AoYU5vZGUsIG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgLy8gcGFyc2UgdHdvIHdheSBiaW5kaW5nLCBlLmcuIHZhbHVlPVwiez1pZGVudD19XCJcbiAgICB2YXIgeE1hdGNoID0gdmFsdWUubWF0Y2goL15cXHs9XFxzKiguKj8pXFxzKj1cXH0kLyk7XG5cbiAgICBpZiAoeE1hdGNoKSB7XG4gICAgICAgIGFOb2RlLnByb3BzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGV4cHI6IHBhcnNlRXhwcih4TWF0Y2hbMV0pLFxuICAgICAgICAgICAgeDogMSxcbiAgICAgICAgICAgIHJhdzogdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIG5vcm1hbCBwcm9wXG4gICAgdmFyIHByb3AgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGV4cHI6IHBhcnNlVGV4dCh2YWx1ZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKSxcbiAgICAgICAgcmF3OiB2YWx1ZVxuICAgIH07XG5cbiAgICAvLyDov5nph4zkuI3og73miorlj6rmnInkuIDkuKrmj5LlgLznmoTlsZ7mgKfmir3lj5ZcbiAgICAvLyDlm6DkuLrmj5LlgLzph4znmoTlgLzlj6/og73mmK9odG1s54mH5q6177yM5a655piT6KKr5rOo5YWlXG4gICAgLy8g57uE5Lu255qE5pWw5o2u57uR5a6a5Zyo57uE5Lu2aW5pdOaXtuWBmuaKveWPllxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgIGVhY2gocHJvcC5leHByLnNlZ3MsIGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VnLnR5cGUgPT09IEV4cHJUeXBlLklOVEVSUCkge1xuICAgICAgICAgICAgICAgICAgICBzZWcuZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLkNBTEwsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjcmVhdGVBY2Nlc3NvcihbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5TVFJJTkcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnXycgKyBwcm9wLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgICBpZiAoYU5vZGUudGFnTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgIHBvc3RQcm9wKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYU5vZGUucHJvcHMucHVzaChwcm9wKTtcbn1cblxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlZ3JhdGVBdHRyO1xuXG5cbi8qKlxuICogQGZpbGUg6Kej5p6Q5qih5p2/XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBjcmVhdGVBTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLWEtbm9kZScpO1xuLy8gdmFyIFdhbGtlciA9IHJlcXVpcmUoJy4vd2Fsa2VyJyk7XG4vLyB2YXIgaW50ZWdyYXRlQXR0ciA9IHJlcXVpcmUoJy4vaW50ZWdyYXRlLWF0dHInKTtcbi8vIHZhciBwYXJzZVRleHQgPSByZXF1aXJlKCcuL3BhcnNlLXRleHQnKTtcbi8vIHZhciBhdXRvQ2xvc2VUYWdzID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9hdXRvLWNsb3NlLXRhZ3MnKTtcblxuLy8gI1tiZWdpbl0gZXJyb3Jcbi8vIGZ1bmN0aW9uIGdldFhQYXRoKHN0YWNrLCBjdXJyZW50VGFnTmFtZSkge1xuLy8gICAgIHZhciBwYXRoID0gWydST09UJ107XG4vLyAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHN0YWNrLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4vLyAgICAgICAgIHBhdGgucHVzaChzdGFja1tpXS50YWdOYW1lKTtcbi8vICAgICB9XG4vLyAgICAgaWYgKGN1cnJlbnRUYWdOYW1lKSB7XG4vLyAgICAgICAgIHBhdGgucHVzaChjdXJyZW50VGFnTmFtZSk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBwYXRoLmpvaW4oJz4nKTtcbi8vIH1cbi8vICNbZW5kXVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBmZWNzLW1heC1zdGF0ZW1lbnRzICovXG5cbi8qKlxuICog6Kej5p6QIHRlbXBsYXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSB0ZW1wbGF0Zea6kOeggVxuICogQHBhcmFtIHtPYmplY3Q/fSBvcHRpb25zIOino+aekOWPguaVsFxuICogQHBhcmFtIHtzdHJpbmc/fSBvcHRpb25zLnRyaW1XaGl0ZXNwYWNlIOepuueZveaWh+acrOeahOWkhOeQhuetlueVpeOAgm5vbmV8Ymxhbmt8YWxsXG4gKiBAcGFyYW0ge0FycmF5P30gb3B0aW9ucy5kZWxpbWl0ZXJzIOaPkuWAvOWIhumalOespuWIl+ihqFxuICogQHJldHVybiB7QU5vZGV9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUoc291cmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy50cmltV2hpdGVzcGFjZSA9IG9wdGlvbnMudHJpbVdoaXRlc3BhY2UgfHwgJ25vbmUnO1xuXG4gICAgdmFyIHJvb3ROb2RlID0gY3JlYXRlQU5vZGUoKTtcblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgfVxuXG4gICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vbWcsICcnKS5yZXBsYWNlKC8oXlxccyt8XFxzKyQpL2csICcnKTtcbiAgICB2YXIgd2Fsa2VyID0gbmV3IFdhbGtlcihzb3VyY2UpO1xuXG4gICAgdmFyIHRhZ1JlZyA9IC88KFxcLyk/KFthLXowLTktXSspXFxzKi9pZztcbiAgICB2YXIgYXR0clJlZyA9IC8oWy06MC05YS16XFwoXFwpXFxbXFxdXSspKFxccyo9XFxzKihbJ1wiXSkoW15cXDNdKj8pXFwzKT9cXHMqL2lnO1xuXG4gICAgdmFyIHRhZ01hdGNoO1xuICAgIHZhciBjdXJyZW50Tm9kZSA9IHJvb3ROb2RlO1xuICAgIHZhciBzdGFjayA9IFtyb290Tm9kZV07XG4gICAgdmFyIHN0YWNrSW5kZXggPSAwO1xuICAgIHZhciBiZWZvcmVMYXN0SW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKCh0YWdNYXRjaCA9IHdhbGtlci5tYXRjaCh0YWdSZWcpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciB0YWdFbmQgPSB0YWdNYXRjaFsxXTtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0YWdNYXRjaFsyXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHB1c2hUZXh0Tm9kZShzb3VyY2Uuc2xpY2UoXG4gICAgICAgICAgICBiZWZvcmVMYXN0SW5kZXgsXG4gICAgICAgICAgICB3YWxrZXIuaW5kZXggLSB0YWdNYXRjaFswXS5sZW5ndGhcbiAgICAgICAgKSk7XG5cbiAgICAgICAgLy8gNjI6ID5cbiAgICAgICAgLy8gNDc6IC9cbiAgICAgICAgLy8g5aSE55CGIDwveHh4eCA+XG4gICAgICAgIGlmICh0YWdFbmQgJiYgd2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDYyKSB7XG4gICAgICAgICAgICAvLyDmu6HotrPlhbPpl63moIfnrb7nmoTmnaHku7bml7bvvIzlhbPpl63moIfnrb5cbiAgICAgICAgICAgIC8vIOWQkeS4iuafpeaJvuWIsOWvueW6lOagh+etvu+8jOaJvuS4jeWIsOaXtuW/veeVpeWFs+mXrVxuICAgICAgICAgICAgdmFyIGNsb3NlSW5kZXggPSBzdGFja0luZGV4O1xuXG4gICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgICAgICAgICAgLy8g5aaC5p6c5q2j5Zyo6Zet5ZCI5LiA5Liq6Ieq6Zet5ZCI55qE5qCH562+77yM5L6L5aaCIDwvaW5wdXQ+77yM5oql6ZSZXG4vLyAgICAgICAgICAgICBpZiAoYXV0b0Nsb3NlVGFnc1t0YWdOYW1lXSkge1xuLy8gICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignJ1xuLy8gICAgICAgICAgICAgICAgICAgICArICdbU0FOIEVSUk9SXSAnICsgZ2V0WFBhdGgoc3RhY2ssIHRhZ05hbWUpICsgJyBpcyBhIGBhdXRvIGNsb3NlZGAgdGFnLCAnXG4vLyAgICAgICAgICAgICAgICAgICAgICsgJ3NvIGl0IGNhbm5vdCBiZSBjbG9zZWQgd2l0aCA8LycgKyB0YWdOYW1lICsgJz4nXG4vLyAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgLy8g5aaC5p6c5YWz6Zet55qEIHRhZyDlkozlvZPliY3miZPlvIDnmoTkuI3kuIDoh7TvvIzmiqXplJlcbi8vICAgICAgICAgICAgIGlmIChcbi8vICAgICAgICAgICAgICAgICBzdGFja1tjbG9zZUluZGV4XS50YWdOYW1lICE9PSB0YWdOYW1lXG4vLyAgICAgICAgICAgICAgICAgLy8g6L+Z6YeM6KaB5oqKIHRhYmxlIOiHquWKqOa3u+WKoCB0Ym9keSDnmoTmg4XlhrXnu5nljrvmjolcbi8vICAgICAgICAgICAgICAgICAmJiAhKHRhZ05hbWUgPT09ICd0YWJsZScgJiYgc3RhY2tbY2xvc2VJbmRleF0udGFnTmFtZSA9PT0gJ3Rib2R5Jylcbi8vICAgICAgICAgICAgICkge1xuLy8gICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJyArIGdldFhQYXRoKHN0YWNrKSArICcgaXMgY2xvc2VkIHdpdGggJyArIHRhZ05hbWUpO1xuLy8gICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gI1tlbmRdXG5cbiAgICAgICAgICAgIHdoaWxlIChjbG9zZUluZGV4ID4gMCAmJiBzdGFja1tjbG9zZUluZGV4XS50YWdOYW1lICE9PSB0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VJbmRleC0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2xvc2VJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFja0luZGV4ID0gY2xvc2VJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBzdGFja1tzdGFja0luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgICAgIC8vIOWkhOeQhiA8L3h4eCDpnZ7mraPluLjpl63lkIjmoIfnrb5cbi8vICAgICAgICAgZWxzZSBpZiAodGFnRW5kKSB7XG4vLyBcbi8vICAgICAgICAgICAgIC8vIOWmguaenOmXreWQiOagh+etvuaXtu+8jOWMuemFjeWQjueahOS4i+S4gOS4quWtl+espuaYryA877yM5Y2z5LiL5LiA5Liq5qCH562+55qE5byA5aeL77yM6YKj5LmI5b2T5YmN6Zet5ZCI5qCH562+5pyq6Zet5ZCIXG4vLyAgICAgICAgICAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDYwKSB7XG4vLyAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcnXG4vLyAgICAgICAgICAgICAgICAgICAgICsgJ1tTQU4gRVJST1JdICcgKyBnZXRYUGF0aChzdGFjaylcbi8vICAgICAgICAgICAgICAgICAgICAgKyAnXFwncyBjbG9zZSB0YWcgbm90IGNsb3NlZCdcbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAvLyDpl63lkIjmoIfnrb7mnInlsZ7mgKdcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignJ1xuLy8gICAgICAgICAgICAgICAgICsgJ1tTQU4gRVJST1JdICcgKyBnZXRYUGF0aChzdGFjaylcbi8vICAgICAgICAgICAgICAgICArICdcXCdzIGNsb3NlIHRhZyBoYXMgYXR0cmlidXRlcydcbi8vICAgICAgICAgICAgICk7XG4vLyBcbi8vICAgICAgICAgfVxuICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICBlbHNlIGlmICghdGFnRW5kKSB7XG4gICAgICAgICAgICB2YXIgYUVsZW1lbnQgPSBjcmVhdGVBTm9kZSh7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdGFnQ2xvc2UgPSBhdXRvQ2xvc2VUYWdzW3RhZ05hbWVdO1xuXG4gICAgICAgICAgICAvLyDop6PmnpAgYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zdGFudC1jb25kaXRpb24gKi9cbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyQ29kZSA9IHdhbGtlci5jdXJyZW50Q29kZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8g5qCH562+57uT5p2f5pe26Lez5Ye6IGF0dHJpYnV0ZXMg6K+75Y+WXG4gICAgICAgICAgICAgICAgLy8g5qCH562+5Y+v6IO955u05o6l57uT5p2f5oiW6Zet5ZCI57uT5p2fXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyQ29kZSA9PT0gNjIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g6YGH5YiwIC8+IOaMiemXreWQiOWkhOeQhlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHRDaGFyQ29kZSA9PT0gNDdcbiAgICAgICAgICAgICAgICAgICAgJiYgd2Fsa2VyLmNoYXJDb2RlKHdhbGtlci5pbmRleCArIDEpID09PSA2MlxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuZ28oMik7XG4gICAgICAgICAgICAgICAgICAgIHRhZ0Nsb3NlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICAgICAgICAgICAgICAvLyDlnKjlpITnkIbkuIDkuKogb3BlbiDmoIfnrb7ml7bvvIzlpoLmnpzpgYfliLDkuoYgPO+8jCDljbPkuIvkuIDkuKrmoIfnrb7nmoTlvIDlp4vvvIzliJnlvZPliY3moIfnrb7mnKrog73mraPluLjpl63lkIjvvIzmiqXplJlcbi8vICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXJDb2RlID09PSA2MCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICcgKyBnZXRYUGF0aChzdGFjaywgdGFnTmFtZSkgKyAnIGlzIG5vdCBjbG9zZWQnKTtcbi8vICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gI1tlbmRdXG5cbiAgICAgICAgICAgICAgICAvLyDor7vlj5YgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJNYXRjaCA9IHdhbGtlci5tYXRjaChhdHRyUmVnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ck1hdGNoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5bGe5oCn5pyJID3vvIzkvYbmsqHlj5bliLAgdmFsdWXvvIzmiqXplJlcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmNoYXJDb2RlKGF0dHJNYXRjaC5pbmRleCArIGF0dHJNYXRjaFsxXS5sZW5ndGgpID09PSA2MVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWF0dHJNYXRjaFsyXVxuLy8gICAgICAgICAgICAgICAgICAgICApIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ1tTQU4gRVJST1JdICcgKyBnZXRYUGF0aChzdGFjaywgdGFnTmFtZSkgKyAnIGF0dHJpYnV0ZSBgJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYXR0ck1hdGNoWzFdICsgJ2AgaXMgbm90IHdyYXBwZWQgd2l0aCBcIlwiJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdGVBdHRyKFxuICAgICAgICAgICAgICAgICAgICAgICAgYUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyTWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyTWF0Y2hbMl0gPyBhdHRyTWF0Y2hbNF0gOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWF0Y2ggaWYgZGlyZWN0aXZlIGZvciBlbHNlL2VsaWYgZGlyZWN0aXZlXG4gICAgICAgICAgICB2YXIgZWxzZURpcmVjdGl2ZSA9IGFFbGVtZW50LmRpcmVjdGl2ZXNbJ2Vsc2UnXSB8fCBhRWxlbWVudC5kaXJlY3RpdmVzLmVsaWY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgICAgICBpZiAoZWxzZURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDaGlsZHJlbkxlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnRDaGlsZHJlbkxlbi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDaGlsZCA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW3BhcmVudENoaWxkcmVuTGVuXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudENoaWxkLnRleHRFeHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5zcGxpY2UocGFyZW50Q2hpbGRyZW5MZW4sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudENoaWxkLmRpcmVjdGl2ZXNbJ2lmJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBGQVRFTF0gZWxzZSBub3QgbWF0Y2ggaWYuJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gI1tlbmRdXG5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2hpbGQuZWxzZXMgPSBwYXJlbnRDaGlsZC5lbHNlcyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2hpbGQuZWxzZXMucHVzaChhRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGFFbGVtZW50LnRhZ05hbWUgPT09ICd0cicgJiYgY3VycmVudE5vZGUudGFnTmFtZSA9PT0gJ3RhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGJvZHlOb2RlID0gY3JlYXRlQU5vZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogJ3Rib2R5J1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaCh0Ym9keU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRib2R5Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tbKytzdGFja0luZGV4XSA9IHRib2R5Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKGFFbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YWdDbG9zZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gYUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgc3RhY2tbKytzdGFja0luZGV4XSA9IGFFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmVmb3JlTGFzdEluZGV4ID0gd2Fsa2VyLmluZGV4O1xuICAgIH1cblxuICAgIHB1c2hUZXh0Tm9kZSh3YWxrZXIuY3V0KGJlZm9yZUxhc3RJbmRleCkpO1xuXG4gICAgcmV0dXJuIHJvb3ROb2RlO1xuXG4gICAgLyoqXG4gICAgICog5Zyo6K+75Y+W5qCI5Lit5re75Yqg5paH5pys6IqC54K5XG4gICAgICpcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCDmlofmnKzlhoXlrrlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdXNoVGV4dE5vZGUodGV4dCkge1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMudHJpbVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgICAgICBpZiAoL15cXHMrJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChjcmVhdGVBTm9kZSh7XG4gICAgICAgICAgICAgICAgdGV4dEV4cHI6IHBhcnNlVGV4dCh0ZXh0LCBvcHRpb25zLmRlbGltaXRlcnMpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qIGVzbGludC1lbmFibGUgZmVjcy1tYXgtc3RhdGVtZW50cyAqL1xuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBwYXJzZVRlbXBsYXRlO1xuXG5cbi8qKlxuICogQGZpbGUg6buY6K6kZmlsdGVyXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIGZlY3MtY2FtZWxjYXNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cblxuLyoqXG4gKiDpu5jorqRmaWx0ZXJcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBERUZBVUxUX0ZJTFRFUlMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBVUkznvJbnoIFmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug5rqQ5LiyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSDmm7/mjaLnu5PmnpzkuLJcbiAgICAgKi9cbiAgICB1cmw6IGVuY29kZVVSSUNvbXBvbmVudCxcblxuICAgIF9jbGFzczogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9LFxuXG4gICAgX3N0eWxlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBrZXkgKyAnOicgKyBzb3VyY2Vba2V5XSArICc7JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSxcblxuICAgIF9zZXA6IGZ1bmN0aW9uIChzb3VyY2UsIHNlcCkge1xuICAgICAgICByZXR1cm4gc291cmNlID8gc2VwICsgc291cmNlIDogc291cmNlO1xuICAgIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlIGZlY3MtY2FtZWxjYXNlICovXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERFRkFVTFRfRklMVEVSUztcblxuXG4vKipcbiAqIEBmaWxlIOihqOi+vuW8j+iuoeeul1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gdmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXh0ZW5kJyk7XG4vLyB2YXIgREVGQVVMVF9GSUxURVJTID0gcmVxdWlyZSgnLi9kZWZhdWx0LWZpbHRlcnMnKTtcbi8vIHZhciBldmFsQXJncyA9IHJlcXVpcmUoJy4vZXZhbC1hcmdzJyk7XG4vLyB2YXIgZGF0YUNhY2hlID0gcmVxdWlyZSgnLi9kYXRhLWNhY2hlJyk7XG5cbi8qKlxuICog6K6h566X6KGo6L6+5byP55qE5YC8XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV4cHIg6KGo6L6+5byP5a+56LGhXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg5pWw5o2u5a655Zmo5a+56LGhXG4gKiBAcGFyYW0ge0NvbXBvbmVudD19IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHJldHVybiB7Kn1cbiAqL1xuZnVuY3Rpb24gZXZhbEV4cHIoZXhwciwgZGF0YSwgb3duZXIpIHtcbiAgICBpZiAoZXhwci52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBleHByLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGRhdGFDYWNoZS5nZXQoZGF0YSwgZXhwcik7XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5VTkFSWTpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICFldmFsRXhwcihleHByLmV4cHIsIGRhdGEsIG93bmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5CSU5BUlk6XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRWYWx1ZSA9IGV2YWxFeHByKGV4cHIuc2Vnc1swXSwgZGF0YSwgb3duZXIpO1xuICAgICAgICAgICAgICAgIHZhciByaWdodFZhbHVlID0gZXZhbEV4cHIoZXhwci5zZWdzWzFdLCBkYXRhLCBvd25lcik7XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlICUgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgKyByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSAtIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlICogcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgLyByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSA8IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlID4gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgJiYgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgIT0gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlIDw9IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSA9PSByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgPj0gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1NTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlICE9PSByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTgzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgPT09IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDg6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSB8fCByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuVEVSVElBUlk6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBldmFsRXhwcihcbiAgICAgICAgICAgICAgICAgICAgZXhwci5zZWdzW2V2YWxFeHByKGV4cHIuc2Vnc1swXSwgZGF0YSwgb3duZXIpID8gMSA6IDJdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBvd25lclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuQVJSQVk6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV4cHIuaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZXhwci5pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1WYWx1ZSA9IGV2YWxFeHByKGl0ZW0uZXhwciwgZGF0YSwgb3duZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnNwcmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVZhbHVlICYmICh2YWx1ZSA9IHZhbHVlLmNvbmNhdChpdGVtVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goaXRlbVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5PQkpFQ1Q6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV4cHIuaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZXhwci5pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1WYWx1ZSA9IGV2YWxFeHByKGl0ZW0uZXhwciwgZGF0YSwgb3duZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnNwcmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVZhbHVlICYmIGV4dGVuZCh2YWx1ZSwgaXRlbVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2V2YWxFeHByKGl0ZW0ubmFtZSwgZGF0YSwgb3duZXIpXSA9IGl0ZW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5BQ0NFU1NPUjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGEuZ2V0KGV4cHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEV4cHJUeXBlLklOVEVSUDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGV2YWxFeHByKGV4cHIuZXhwciwgZGF0YSwgb3duZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXhwci5maWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IGV4cHIuZmlsdGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJOYW1lID0gZmlsdGVyLm5hbWUucGF0aHNbMF0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lci5maWx0ZXJzW2ZpbHRlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvd25lci5maWx0ZXJzW2ZpbHRlck5hbWVdLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXS5jb25jYXQoZXZhbEFyZ3MoZmlsdGVyLmFyZ3MsIGRhdGEsIG93bmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoREVGQVVMVF9GSUxURVJTW2ZpbHRlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBERUZBVUxUX0ZJTFRFUlNbZmlsdGVyTmFtZV0oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuYXJnc1swXSA/IGZpbHRlci5hcmdzWzBdLnZhbHVlIDogJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG4gICAgICAgICAgICBjYXNlIEV4cHJUeXBlLlRFWFQ6XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZiA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXhwci5zZWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnID0gZXhwci5zZWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBidWYgKz0gc2VnLnZhbHVlIHx8IGV2YWxFeHByKHNlZywgZGF0YSwgb3duZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YUNhY2hlLnNldChkYXRhLCBleHByLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBldmFsRXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOS4uuWHveaVsOiwg+eUqOiuoeeul+WPguaVsOaVsOe7hOeahOWAvFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuL2V2YWwtZXhwcicpO1xuXG4vKipcbiAqIOS4uuWHveaVsOiwg+eUqOiuoeeul+WPguaVsOaVsOe7hOeahOWAvFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3Mg5Y+C5pWw6KGo6L6+5byP5YiX6KGoXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg5pWw5o2u546v5aKDXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg57uE5Lu2546v5aKDXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZXZhbEFyZ3MoYXJncywgZGF0YSwgb3duZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGV2YWxFeHByKGFyZ3NbaV0sIGRhdGEsIG93bmVyKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZXZhbEFyZ3M7XG5cblxuLyoqXG4gKiBAZmlsZSDmlbDmja7nvJPlrZjnrqHnkIblmahcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuXG52YXIgZGF0YUNhY2hlU291cmNlID0ge307XG52YXIgZGF0YUNhY2hlQ2xlYXJseSA9IDE7XG5cbi8qKlxuICog5pWw5o2u57yT5a2Y566h55CG5ZmoXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgZGF0YUNhY2hlID0ge1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZGF0YUNhY2hlQ2xlYXJseSkge1xuICAgICAgICAgICAgZGF0YUNhY2hlQ2xlYXJseSA9IDE7XG4gICAgICAgICAgICBkYXRhQ2FjaGVTb3VyY2UgPSB7fTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRhLCBleHByLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXhwci5yYXcpIHtcbiAgICAgICAgICAgIGRhdGFDYWNoZUNsZWFybHkgPSAwO1xuICAgICAgICAgICAgKGRhdGFDYWNoZVNvdXJjZVtkYXRhLmlkXSA9IGRhdGFDYWNoZVNvdXJjZVtkYXRhLmlkXSB8fCB7fSlbZXhwci5yYXddID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiAoZGF0YSwgZXhwcikge1xuICAgICAgICBpZiAoZXhwci5yYXcgJiYgZGF0YUNhY2hlU291cmNlW2RhdGEuaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUNhY2hlU291cmNlW2RhdGEuaWRdW2V4cHIucmF3XTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGF0YUNhY2hlO1xuXG5cbi8qKlxuICogQGZpbGUg5q+U6L6D5Y+Y5pu06KGo6L6+5byP5LiO55uu5qCH6KGo6L6+5byP5LmL6Ze055qE5YWz57O7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvZXhwci10eXBlJyk7XG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuL2V2YWwtZXhwcicpO1xuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcblxuLyoqXG4gKiDliKTmlq3lj5jmm7Tooajovr7lvI/kuI7lpJrkuKrooajovr7lvI/kuYvpl7TnmoTlhbPns7vvvIww5Li65a6M5YWo5rKh5YWz57O777yMMeS4uuacieWFs+ezu1xuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZUV4cHIg55uu5qCH6KGo6L6+5byPXG4gKiBAcGFyYW0ge0FycmF5fSBleHBycyDlpJrkuKrmupDooajovr7lvI9cbiAqIEBwYXJhbSB7RGF0YX0gZGF0YSDooajovr7lvI/miYDlsZ7mlbDmja7njq/looNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2hhbmdlRXhwckNvbXBhcmVFeHBycyhjaGFuZ2VFeHByLCBleHBycywgZGF0YSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXhwcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VFeHByLCBleHByc1tpXSwgZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICog5q+U6L6D5Y+Y5pu06KGo6L6+5byP5LiO55uu5qCH6KGo6L6+5byP5LmL6Ze055qE5YWz57O777yM55So5LqO6KeG5Zu+5pu05paw5Yik5patXG4gKiDop4blm77mm7TmlrDpnIDopoHmoLnmja7lhbblhbPns7vvvIzlgZrlh7rnm7jlupTnmoTmm7TmlrDooYzkuLpcbiAqXG4gKiAwOiDlrozlhajmsqHlhbPns7tcbiAqIDE6IOWPmOabtOihqOi+vuW8j+aYr+ebruagh+ihqOi+vuW8j+eahOavjemhuSjlpoJh5LiOYS5iKSDmiJYg6KGo56S66ZyA6KaB5a6M5YWo5Y+Y5YyWXG4gKiAyOiDlj5jmm7Tooajovr7lvI/mmK/nm67moIfooajovr7lvI/nm7jnrYlcbiAqID4yOiDlj5jmm7Tooajovr7lvI/mmK/nm67moIfooajovr7lvI/nmoTlrZDpobnvvIzlpoJhLmIuY+S4jmEuYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VFeHByIOWPmOabtOihqOi+vuW8j1xuICogQHBhcmFtIHtPYmplY3R9IGV4cHIg6KaB5q+U6L6D55qE55uu5qCH6KGo6L6+5byPXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg6KGo6L6+5byP5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZUV4cHIsIGV4cHIsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICBjYXNlIEV4cHJUeXBlLkFDQ0VTU09SOlxuICAgICAgICAgICAgdmFyIHBhdGhzID0gZXhwci5wYXRocztcbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY2hhbmdlUGF0aHMgPSBjaGFuZ2VFeHByLnBhdGhzO1xuICAgICAgICAgICAgdmFyIGNoYW5nZUxlbiA9IGNoYW5nZVBhdGhzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhFeHByID0gcGF0aHNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAocGF0aEV4cHIudHlwZSA9PT0gRXhwclR5cGUuQUNDRVNTT1JcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlRXhwciwgcGF0aEV4cHIsIGRhdGEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgaSA8IGNoYW5nZUxlblxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgICAgICAgICAgICAgICAgJiYgKHBhdGhFeHByLnZhbHVlIHx8IGV2YWxFeHByKHBhdGhFeHByLCBkYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICE9IChjaGFuZ2VQYXRoc1tpXS52YWx1ZSB8fCBldmFsRXhwcihjaGFuZ2VQYXRoc1tpXSwgZGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTWF0aC5tYXgoMSwgY2hhbmdlTGVuIC0gbGVuICsgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2UgRXhwclR5cGUuVU5BUlk6XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlRXhwciwgZXhwci5leHByLCBkYXRhKSA/IDEgOiAwO1xuXG5cbiAgICAgICAgY2FzZSBFeHByVHlwZS5URVhUOlxuICAgICAgICBjYXNlIEV4cHJUeXBlLkJJTkFSWTpcbiAgICAgICAgY2FzZSBFeHByVHlwZS5URVJUSUFSWTpcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VFeHByQ29tcGFyZUV4cHJzKGNoYW5nZUV4cHIsIGV4cHIuc2VncywgZGF0YSk7XG5cbiAgICAgICAgY2FzZSBFeHByVHlwZS5BUlJBWTpcbiAgICAgICAgY2FzZSBFeHByVHlwZS5PQkpFQ1Q6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV4cHIuaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZUV4cHIsIGV4cHIuaXRlbXNbaV0uZXhwciwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBjYXNlIEV4cHJUeXBlLklOVEVSUDpcbiAgICAgICAgICAgIGlmICghY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlRXhwciwgZXhwci5leHByLCBkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgZWFjaChleHByLmZpbHRlcnMsIGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUmVzdWx0ID0gY2hhbmdlRXhwckNvbXBhcmVFeHBycyhjaGFuZ2VFeHByLCBmaWx0ZXIuYXJncywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsdGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclJlc3VsdCA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY2hhbmdlRXhwckNvbXBhcmU7XG5cblxuLyoqXG4gKiBAZmlsZSDmlbDmja7lj5jmm7TnsbvlnovmnprkuL5cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5pWw5o2u5Y+Y5pu057G75Z6L5p6a5Li+XG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRGF0YUNoYW5nZVR5cGUgPSB7XG4gICAgU0VUOiAxLFxuICAgIFNQTElDRTogMlxufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRGF0YUNoYW5nZVR5cGU7XG5cblxuLyoqXG4gKiBAZmlsZSDnlJ/lkb3lkajmnJ/nsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbmZ1bmN0aW9uIGxpZmVDeWNsZU93bklzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1tuYW1lXTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgZmVjcy12YWxpZC12YXItanNkb2MgKi9cbi8qKlxuICog6IqC54K555Sf5ZG95ZGo5pyf5L+h5oGvXG4gKlxuICogQGlubmVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgTGlmZUN5Y2xlID0ge1xuICAgIHN0YXJ0OiB7fSxcblxuICAgIGNvbXBpbGVkOiB7XG4gICAgICAgIGlzOiBsaWZlQ3ljbGVPd25JcyxcbiAgICAgICAgY29tcGlsZWQ6IHRydWVcbiAgICB9LFxuXG4gICAgaW5pdGVkOiB7XG4gICAgICAgIGlzOiBsaWZlQ3ljbGVPd25JcyxcbiAgICAgICAgY29tcGlsZWQ6IHRydWUsXG4gICAgICAgIGluaXRlZDogdHJ1ZVxuICAgIH0sXG5cbiAgICBjcmVhdGVkOiB7XG4gICAgICAgIGlzOiBsaWZlQ3ljbGVPd25JcyxcbiAgICAgICAgY29tcGlsZWQ6IHRydWUsXG4gICAgICAgIGluaXRlZDogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZDogdHJ1ZVxuICAgIH0sXG5cbiAgICBhdHRhY2hlZDoge1xuICAgICAgICBpczogbGlmZUN5Y2xlT3duSXMsXG4gICAgICAgIGNvbXBpbGVkOiB0cnVlLFxuICAgICAgICBpbml0ZWQ6IHRydWUsXG4gICAgICAgIGNyZWF0ZWQ6IHRydWUsXG4gICAgICAgIGF0dGFjaGVkOiB0cnVlXG4gICAgfSxcblxuICAgIGxlYXZpbmc6IHtcbiAgICAgICAgaXM6IGxpZmVDeWNsZU93bklzLFxuICAgICAgICBjb21waWxlZDogdHJ1ZSxcbiAgICAgICAgaW5pdGVkOiB0cnVlLFxuICAgICAgICBjcmVhdGVkOiB0cnVlLFxuICAgICAgICBhdHRhY2hlZDogdHJ1ZSxcbiAgICAgICAgbGVhdmluZzogdHJ1ZVxuICAgIH0sXG5cbiAgICBkZXRhY2hlZDoge1xuICAgICAgICBpczogbGlmZUN5Y2xlT3duSXMsXG4gICAgICAgIGNvbXBpbGVkOiB0cnVlLFxuICAgICAgICBpbml0ZWQ6IHRydWUsXG4gICAgICAgIGNyZWF0ZWQ6IHRydWUsXG4gICAgICAgIGRldGFjaGVkOiB0cnVlXG4gICAgfSxcblxuICAgIGRpc3Bvc2VkOiB7XG4gICAgICAgIGlzOiBsaWZlQ3ljbGVPd25JcyxcbiAgICAgICAgZGlzcG9zZWQ6IHRydWVcbiAgICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSBmZWNzLXZhbGlkLXZhci1qc2RvYyAqL1xuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpZmVDeWNsZTtcblxuXG4vKipcbiAqIEBmaWxlIOiKgueCueexu+Wei1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDoioLngrnnsbvlnotcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBOb2RlVHlwZSA9IHtcbiAgICBURVhUOiAxLFxuICAgIElGOiAyLFxuICAgIEZPUjogMyxcbiAgICBFTEVNOiA0LFxuICAgIENNUFQ6IDUsXG4gICAgU0xPVDogNixcbiAgICBUUEw6IDdcbn07XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE5vZGVUeXBlO1xuXG5cbi8qKlxuICogQGZpbGUg6I635Y+WIEFOb2RlIHByb3BzIOaVsOe7hOS4reebuOW6lCBuYW1lIOeahOmhuVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDojrflj5YgQU5vZGUgcHJvcHMg5pWw57uE5Lit55u45bqUIG5hbWUg55qE6aG5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFOb2RlIEFOb2Rl5a+56LGhXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1l5bGe5oCn5Yy56YWN5LiyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldEFOb2RlUHJvcChhTm9kZSwgbmFtZSkge1xuICAgIHZhciBpbmRleCA9IGFOb2RlLmhvdHNwb3QucHJvcHNbbmFtZV07XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFOb2RlLnByb3BzW2luZGV4XTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdldEFOb2RlUHJvcDtcblxuXG4vKipcbiAqIEBmaWxlIOiOt+WPluWxnuaAp+WkhOeQhuWvueixoVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGNvbnRhaW5zID0gcmVxdWlyZSgnLi4vdXRpbC9jb250YWlucycpO1xuLy8gdmFyIGVtcHR5ID0gcmVxdWlyZSgnLi4vdXRpbC9lbXB0eScpO1xuLy8gdmFyIHN2Z1RhZ3MgPSByZXF1aXJlKCcuLi9icm93c2VyL3N2Zy10YWdzJyk7XG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuLy8gdmFyIGdldEFOb2RlUHJvcCA9IHJlcXVpcmUoJy4vZ2V0LWEtbm9kZS1wcm9wJyk7XG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuXG5cbi8qKlxuICogSFRNTCDlsZ7mgKflkowgRE9NIOaTjeS9nOWxnuaAp+eahOWvueeFp+ihqFxuICpcbiAqIEBpbm5lclxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgSFRNTF9BVFRSX1BST1BfTUFQID0ge1xuICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgJ2NlbGxwYWRkaW5nJzogJ2NlbGxQYWRkaW5nJyxcbiAgICAnY2VsbHNwYWNpbmcnOiAnY2VsbFNwYWNpbmcnLFxuICAgICdjb2xzcGFuJzogJ2NvbFNwYW4nLFxuICAgICdyb3dzcGFuJzogJ3Jvd1NwYW4nLFxuICAgICd2YWxpZ24nOiAndkFsaWduJyxcbiAgICAndXNlbWFwJzogJ3VzZU1hcCcsXG4gICAgJ2ZyYW1lYm9yZGVyJzogJ2ZyYW1lQm9yZGVyJyxcbiAgICAnZm9yJzogJ2h0bWxGb3InXG59O1xuXG4vKipcbiAqIOm7mOiupOeahOWFg+e0oOeahOWxnuaAp+iuvue9rueahOWPmOaNouaWueazlVxuICpcbiAqIEBpbm5lclxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGRlZmF1bHRFbGVtZW50UHJvcEhhbmRsZXIgPSB7XG4gICAgcHJvcDogZnVuY3Rpb24gKGVsLCB2YWx1ZSwgbmFtZSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBIVE1MX0FUVFJfUFJPUF9NQVBbbmFtZV0gfHwgbmFtZTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZVxuXG4gICAgICAgIC8vIGlucHV0IOeahCB0eXBlIOaYr+S4queJueauiuWxnuaAp++8jOWFtuWunuS5n+W6lOivpeeUqCBzZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8g5L2G5pivIHR5cGUg5LiN5bqU6K+l6L+Q6KGM5pe25Yqo5oCB5pS55Y+Y77yM5ZCm5YiZ5Lya5pyJ5YW85a655oCn6Zeu6aKYXG4gICAgICAgIC8vIOaJgOS7pei/memHjOebtOaOpeWwseS4jeeuoeS6hlxuICAgICAgICBpZiAocHJvcE5hbWUgaW4gZWwpIHtcbiAgICAgICAgICAgIGVsW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF0dHJpYnV0ZSDnu5HlrprnmoTmmK8gdGV4dO+8jOaJgOS7peS4jeS8muWHuueOsCBudWxsIOeahOaDheWGte+8jOi/memHjOaXoOmcgOWkhOeQhlxuICAgICAgICAvLyDmjaLlj6Xor53mnaXor7TvvIxzYW4g5piv5YGa5LiN5YiwIGF0dHJpYnV0ZSDml7bmnInml7bml6DnmoRcbiAgICAgICAgLy8gaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgLy8gfVxuICAgIH0sXG5cbiAgICBvdXRwdXQ6IGZ1bmN0aW9uIChlbGVtZW50LCBiaW5kSW5mbywgZGF0YSkge1xuICAgICAgICBkYXRhLnNldChiaW5kSW5mby5leHByLCBlbGVtZW50LmVsW2JpbmRJbmZvLm5hbWVdLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICBpZDogZWxlbWVudC5pZCxcbiAgICAgICAgICAgICAgICBwcm9wOiBiaW5kSW5mby5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbnZhciBzdmdQcm9wSGFuZGxlciA9IHtcbiAgICBwcm9wOiBmdW5jdGlvbiAoZWwsIHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxufTtcblxudmFyIGJvb2xQcm9wSGFuZGxlciA9IHtcbiAgICBwcm9wOiBmdW5jdGlvbiAoZWwsIHZhbHVlLCBuYW1lLCBlbGVtZW50LCBwcm9wKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IEhUTUxfQVRUUl9QUk9QX01BUFtuYW1lXSB8fCBuYW1lO1xuICAgICAgICBlbFtwcm9wTmFtZV0gPSAhIShwcm9wICYmIHByb3AucmF3ID09PSAnJ1xuICAgICAgICAgICAgfHwgdmFsdWUgJiYgdmFsdWUgIT09ICdmYWxzZScgJiYgdmFsdWUgIT09ICcwJyk7XG4gICAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgZmVjcy1wcm9wZXJ0aWVzLXF1b3RlICovXG4vKipcbiAqIOm7mOiupOeahOWxnuaAp+iuvue9ruWPmOaNouaWueazlVxuICpcbiAqIEBpbm5lclxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGRlZmF1bHRFbGVtZW50UHJvcEhhbmRsZXJzID0ge1xuICAgIHN0eWxlOiB7XG4gICAgICAgIHByb3A6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnY2xhc3MnOiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcHJvcDogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2xvdDoge1xuICAgICAgICBwcm9wOiBlbXB0eVxuICAgIH0sXG5cbiAgICByZWFkb25seTogYm9vbFByb3BIYW5kbGVyLFxuICAgIGRpc2FibGVkOiBib29sUHJvcEhhbmRsZXIsXG4gICAgYXV0b2ZvY3VzOiBib29sUHJvcEhhbmRsZXIsXG4gICAgcmVxdWlyZWQ6IGJvb2xQcm9wSGFuZGxlcixcbiAgICBkcmFnZ2FibGU6IGJvb2xQcm9wSGFuZGxlclxufTtcbi8qIGVzbGludC1lbmFibGUgZmVjcy1wcm9wZXJ0aWVzLXF1b3RlICovXG5cbnZhciBhbmFsSW5wdXRDaGVja2VyID0ge1xuICAgIGNoZWNrYm94OiBjb250YWlucyxcbiAgICByYWRpbzogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYW5hbElucHV0Q2hlY2tlZFN0YXRlKGVsZW1lbnQsIHZhbHVlLCBvcGVyKSB7XG4gICAgdmFyIGJpbmRWYWx1ZSA9IGdldEFOb2RlUHJvcChlbGVtZW50LmFOb2RlLCAndmFsdWUnKTtcbiAgICB2YXIgYmluZFR5cGUgPSBnZXRBTm9kZVByb3AoZWxlbWVudC5hTm9kZSwgJ3R5cGUnKTtcblxuICAgIGlmIChiaW5kVmFsdWUgJiYgYmluZFR5cGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBldmFsRXhwcihiaW5kVHlwZS5leHByLCBlbGVtZW50LnNjb3BlLCBlbGVtZW50Lm93bmVyKTtcblxuICAgICAgICBpZiAoYW5hbElucHV0Q2hlY2tlclt0eXBlXSkge1xuICAgICAgICAgICAgdmFyIGJpbmRDaGVja2VkID0gZ2V0QU5vZGVQcm9wKGVsZW1lbnQuYU5vZGUsICdjaGVja2VkJyk7XG4gICAgICAgICAgICBpZiAoIWJpbmRDaGVja2VkLmhpbnRFeHByKSB7XG4gICAgICAgICAgICAgICAgYmluZENoZWNrZWQuaGludEV4cHIgPSBiaW5kVmFsdWUuZXhwcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICEhYW5hbElucHV0Q2hlY2tlclt0eXBlXShcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBldmFsRXhwcihiaW5kVmFsdWUuZXhwciwgZWxlbWVudC5zY29wZSwgZWxlbWVudC5vd25lcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBlbGVtZW50UHJvcEhhbmRsZXJzID0ge1xuICAgIGlucHV0OiB7XG4gICAgICAgIG11bHRpcGxlOiBib29sUHJvcEhhbmRsZXIsXG4gICAgICAgIGNoZWNrZWQ6IHtcbiAgICAgICAgICAgIHByb3A6IGZ1bmN0aW9uIChlbCwgdmFsdWUsIG5hbWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBhbmFsSW5wdXRDaGVja2VkU3RhdGUoZWxlbWVudCwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgYm9vbFByb3BIYW5kbGVyLnByb3AoXG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSAhPSBudWxsID8gc3RhdGUgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2NoZWNrZWQnLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG91dHB1dDogZnVuY3Rpb24gKGVsZW1lbnQsIGJpbmRJbmZvLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudC5lbDtcbiAgICAgICAgICAgICAgICB2YXIgYmluZFZhbHVlID0gZ2V0QU5vZGVQcm9wKGVsZW1lbnQuYU5vZGUsICd2YWx1ZScpO1xuICAgICAgICAgICAgICAgIHZhciBiaW5kVHlwZSA9IGdldEFOb2RlUHJvcChlbGVtZW50LmFOb2RlLCAndHlwZScpIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJpbmRWYWx1ZSAmJiBiaW5kVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJpbmRUeXBlLnJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZWwuY2hlY2tlZCA/ICdwdXNoJyA6ICdyZW1vdmUnXShiaW5kSW5mby5leHByLCBlbC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2hlY2tlZCAmJiBkYXRhLnNldChiaW5kSW5mby5leHByLCBlbC52YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBlbGVtZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogYmluZEluZm8ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVmYXVsdEVsZW1lbnRQcm9wSGFuZGxlci5vdXRwdXQoZWxlbWVudCwgYmluZEluZm8sIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9wdGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgcHJvcDogZnVuY3Rpb24gKGVsLCB2YWx1ZSwgbmFtZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRFbGVtZW50UHJvcEhhbmRsZXIucHJvcChlbCwgdmFsdWUsIG5hbWUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uU2VsZWN0ZWQoZWxlbWVudCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0OiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBwcm9wOiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWwudmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG91dHB1dDogZGVmYXVsdEVsZW1lbnRQcm9wSGFuZGxlci5vdXRwdXRcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGlzT3B0aW9uU2VsZWN0ZWQoZWxlbWVudCwgdmFsdWUpIHtcbiAgICB2YXIgcGFyZW50U2VsZWN0ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudFNlbGVjdCkge1xuICAgICAgICBpZiAocGFyZW50U2VsZWN0LnRhZ05hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudFNlbGVjdCA9IHBhcmVudFNlbGVjdC5wYXJlbnQ7XG4gICAgfVxuXG5cbiAgICBpZiAocGFyZW50U2VsZWN0KSB7XG4gICAgICAgIHZhciBzZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIHZhciBwcm9wO1xuICAgICAgICB2YXIgZXhwcjtcblxuICAgICAgICBpZiAoKHByb3AgPSBnZXRBTm9kZVByb3AocGFyZW50U2VsZWN0LmFOb2RlLCAndmFsdWUnKSlcbiAgICAgICAgICAgICYmIChleHByID0gcHJvcC5leHByKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHNlbGVjdFZhbHVlID0gcGFyZW50U2VsZWN0Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgICAgICAgICAgPyBldmFsRXhwcihleHByLCBwYXJlbnRTZWxlY3QuZGF0YSwgcGFyZW50U2VsZWN0KVxuICAgICAgICAgICAgICAgIDogZXZhbEV4cHIoZXhwciwgcGFyZW50U2VsZWN0LnNjb3BlLCBwYXJlbnRTZWxlY3Qub3duZXIpXG4gICAgICAgICAgICAgICAgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0VmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIOiOt+WPluWxnuaAp+WkhOeQhuWvueixoVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIOWFg+e0oHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJOYW1lIOWxnuaAp+WQjVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRQcm9wSGFuZGxlcih0YWdOYW1lLCBhdHRyTmFtZSkge1xuICAgIGlmIChzdmdUYWdzW3RhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBzdmdQcm9wSGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgdGFnUHJvcEhhbmRsZXJzID0gZWxlbWVudFByb3BIYW5kbGVyc1t0YWdOYW1lXTtcbiAgICBpZiAoIXRhZ1Byb3BIYW5kbGVycykge1xuICAgICAgICB0YWdQcm9wSGFuZGxlcnMgPSBlbGVtZW50UHJvcEhhbmRsZXJzW3RhZ05hbWVdID0ge307XG4gICAgfVxuXG4gICAgdmFyIHByb3BIYW5kbGVyID0gdGFnUHJvcEhhbmRsZXJzW2F0dHJOYW1lXTtcbiAgICBpZiAoIXByb3BIYW5kbGVyKSB7XG4gICAgICAgIHByb3BIYW5kbGVyID0gZGVmYXVsdEVsZW1lbnRQcm9wSGFuZGxlcnNbYXR0ck5hbWVdIHx8IGRlZmF1bHRFbGVtZW50UHJvcEhhbmRsZXI7XG4gICAgICAgIHRhZ1Byb3BIYW5kbGVyc1thdHRyTmFtZV0gPSBwcm9wSGFuZGxlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcEhhbmRsZXI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdldFByb3BIYW5kbGVyO1xuXG5cbi8qKlxuICogQGZpbGUg5Yik5pat5Y+Y5pu05piv5ZCm5p2l5rqQ5LqO5YWD57SgXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOWIpOaWreWPmOabtOaYr+WQpuadpea6kOS6juWFg+e0oO+8jOadpea6kOS6juWFg+e0oOaXtu+8jOinhuWbvuabtOaWsOmcgOimgemYu+aWrVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2Ug5Y+Y5pu05a+56LGhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQg5YWD57SgXG4gKiBAcGFyYW0ge3N0cmluZz99IHByb3BOYW1lIOWxnuaAp+WQje+8jOWPr+mAieOAgumcgOimgeeyvuehruWIpOaWreaYr+WQpuadpea6kOS6juatpOWxnuaAp+aXtuS8oOWFpVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEYXRhQ2hhbmdlQnlFbGVtZW50KGNoYW5nZSwgZWxlbWVudCwgcHJvcE5hbWUpIHtcbiAgICB2YXIgY2hhbmdlVGFyZ2V0ID0gY2hhbmdlLm9wdGlvbi50YXJnZXQ7XG4gICAgcmV0dXJuIGNoYW5nZVRhcmdldCAmJiBjaGFuZ2VUYXJnZXQuaWQgPT09IGVsZW1lbnQuaWRcbiAgICAgICAgJiYgKCFwcm9wTmFtZSB8fCBjaGFuZ2VUYXJnZXQucHJvcCA9PT0gcHJvcE5hbWUpO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpc0RhdGFDaGFuZ2VCeUVsZW1lbnQ7XG5cblxuLyoqXG4gKiBAZmlsZSDlnKjlr7nosaHkuIrkvb/nlKhhY2Nlc3NvcuihqOi+vuW8j+afpeaJvuaWueazlVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcblxuLyoqXG4gKiDlnKjlr7nosaHkuIrkvb/nlKhhY2Nlc3NvcuihqOi+vuW8j+afpeaJvuaWueazlVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2Ug5rqQ5a+56LGhXG4gKiBAcGFyYW0ge09iamVjdH0gbmFtZUV4cHIg6KGo6L6+5byPXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZmluZE1ldGhvZChzb3VyY2UsIG5hbWVFeHByLCBkYXRhKSB7XG4gICAgdmFyIG1ldGhvZCA9IHNvdXJjZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBtZXRob2QgIT0gbnVsbCAmJiBpIDwgbmFtZUV4cHIucGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kW2V2YWxFeHByKG5hbWVFeHByLnBhdGhzW2ldLCBkYXRhKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZmluZE1ldGhvZDtcblxuXG4vKipcbiAqIEBmaWxlIOaVsOaNruexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi9ldmFsLWV4cHInKTtcbi8vIHZhciBEYXRhQ2hhbmdlVHlwZSA9IHJlcXVpcmUoJy4vZGF0YS1jaGFuZ2UtdHlwZScpO1xuLy8gdmFyIGNyZWF0ZUFjY2Vzc29yID0gcmVxdWlyZSgnLi4vcGFyc2VyL2NyZWF0ZS1hY2Nlc3NvcicpO1xuLy8gdmFyIHBhcnNlRXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlci9wYXJzZS1leHByJyk7XG4vLyB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4uL3V0aWwvZ3VpZCcpO1xuLy8gdmFyIGRhdGFDYWNoZSA9IHJlcXVpcmUoJy4vZGF0YS1jYWNoZScpO1xuXG4vKipcbiAqIOaVsOaNruexu1xuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3Q/fSBkYXRhIOWIneWni+aVsOaNrlxuICogQHBhcmFtIHtNb2RlbD99IHBhcmVudCDniLbnuqfmlbDmja7lrrnlmahcbiAqL1xuZnVuY3Rpb24gRGF0YShkYXRhLCBwYXJlbnQpIHtcbiAgICB0aGlzLmlkID0gZ3VpZCgpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucmF3ID0gZGF0YSB8fCB7fTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG4vLyAjW2JlZ2luXSBlcnJvclxuLy8gLy8g5Lul5LiL5Lik5Liq5Ye95pWw5Y+q5Zyo5byA5Y+R5qih5byP5LiL5Y+v55So77yM5Zyo55Sf5Lqn5qih5byP5LiL5LiN5a2Y5ZyoXG4vLyAvKipcbi8vICAqIERhdGFUeXBlcyDmo4DmtYtcbi8vICAqL1xuLy8gRGF0YS5wcm90b3R5cGUuY2hlY2tEYXRhVHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4vLyAgICAgaWYgKHRoaXMudHlwZUNoZWNrZXIpIHtcbi8vICAgICAgICAgdGhpcy50eXBlQ2hlY2tlcih0aGlzLnJhdyk7XG4vLyAgICAgfVxuLy8gfTtcbi8vIFxuLy8gLyoqXG4vLyAgKiDorr7nva4gdHlwZSBjaGVja2VyXG4vLyAgKlxuLy8gICogQHBhcmFtICB7RnVuY3Rpb259IHR5cGVDaGVja2VyIOexu+Wei+agoemqjOWZqFxuLy8gICovXG4vLyBEYXRhLnByb3RvdHlwZS5zZXRUeXBlQ2hlY2tlciA9IGZ1bmN0aW9uICh0eXBlQ2hlY2tlcikge1xuLy8gICAgIHRoaXMudHlwZUNoZWNrZXIgPSB0eXBlQ2hlY2tlcjtcbi8vIH07XG4vLyBcbi8vICNbZW5kXVxuXG4vKipcbiAqIOa3u+WKoOaVsOaNruWPmOabtOeahOS6i+S7tuebkeWQrOWZqFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIOebkeWQrOWHveaVsFxuICovXG5EYXRhLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICog56e76Zmk5pWw5o2u5Y+Y5pu055qE5LqL5Lu255uR5ZCs5ZmoXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5Ye95pWwXG4gKi9cbkRhdGEucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgaWYgKCFsaXN0ZW5lciB8fCB0aGlzLmxpc3RlbmVyc1tsZW5dID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGxlbiwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIOinpuWPkeaVsOaNruWPmOabtFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2Ug5Y+Y5pu05L+h5oGv5a+56LGhXG4gKi9cbkRhdGEucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS5vcHRpb24uc2lsZW50IHx8IGNoYW5nZS5vcHRpb24uc2lsZW5jZSB8fCBjaGFuZ2Uub3B0aW9uLnF1aWV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2ldLmNhbGwodGhpcywgY2hhbmdlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOiOt+WPluaVsOaNrumhuVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdD99IGV4cHIg5pWw5o2u6aG56Lev5b6EXG4gKiBAcGFyYW0ge0RhdGE/fSBjYWxsZWUg5b2T5YmN5pWw5o2u6I635Y+W55qE6LCD55So546v5aKDXG4gKiBAcmV0dXJuIHsqfVxuICovXG5EYXRhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZXhwciwgY2FsbGVlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5yYXc7XG4gICAgaWYgKCFleHByKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBleHByID0gcGFyc2VFeHByKGV4cHIpO1xuXG4gICAgdmFyIHBhdGhzID0gZXhwci5wYXRocztcbiAgICBjYWxsZWUgPSBjYWxsZWUgfHwgdGhpcztcblxuICAgIHZhbHVlID0gdmFsdWVbcGF0aHNbMF0udmFsdWVdO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnBhcmVudC5nZXQoZXhwciwgY2FsbGVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcGF0aHMubGVuZ3RoOyB2YWx1ZSAhPSBudWxsICYmIGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcGF0aHNbaV0udmFsdWUgfHwgZXZhbEV4cHIocGF0aHNbaV0sIGNhbGxlZSldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKipcbiAqIOaVsOaNruWvueixoeWPmOabtOaTjeS9nFxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHNvdXJjZSDopoHlj5jmm7TnmoTmupDmlbDmja5cbiAqIEBwYXJhbSB7QXJyYXl9IGV4cHJQYXRocyDlsZ7mgKfot6/lvoRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUg5Y+Y5pu05bGe5oCn5YC8XG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg5a+55bqU55qERGF0YeWvueixoVxuICogQHJldHVybiB7Kn0g5Y+Y5pu05ZCO55qE5paw5pWw5o2uXG4gKi9cbmZ1bmN0aW9uIGltbXV0YWJsZVNldChzb3VyY2UsIGV4cHJQYXRocywgdmFsdWUsIGRhdGEpIHtcbiAgICBpZiAoZXhwclBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3AgPSBldmFsRXhwcihleHByUGF0aHNbMF0sIGRhdGEpO1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gK3Byb3A7XG5cbiAgICAgICAgcmVzdWx0ID0gc291cmNlLnNsaWNlKDApO1xuICAgICAgICByZXN1bHRbaXNOYU4oaW5kZXgpID8gcHJvcCA6IGluZGV4XSA9IGltbXV0YWJsZVNldChzb3VyY2VbaW5kZXhdLCBleHByUGF0aHMuc2xpY2UoMSksIHZhbHVlLCBkYXRhKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBwcm9wKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IGltbXV0YWJsZVNldChzb3VyY2VbcHJvcF0gfHwge30sIGV4cHJQYXRocy5zbGljZSgxKSwgdmFsdWUsIGRhdGEpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cblxuLyoqXG4gKiDorr7nva7mlbDmja7poblcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV4cHIg5pWw5o2u6aG56Lev5b6EXG4gKiBAcGFyYW0geyp9IHZhbHVlIOaVsOaNruWAvFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb24g6K6+572u5Y+C5pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbi5zaWxlbnQg6Z2Z6buY6K6+572u77yM5LiN6Kem5Y+R5Y+Y5pu05LqL5Lu2XG4gKi9cbkRhdGEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChleHByLCB2YWx1ZSwgb3B0aW9uKSB7XG4gICAgb3B0aW9uID0gb3B0aW9uIHx8IHt9O1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICB2YXIgZXhwclJhdyA9IGV4cHI7XG4gICAgLy8gI1tlbmRdXG5cbiAgICBleHByID0gcGFyc2VFeHByKGV4cHIpO1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICBpZiAoZXhwci50eXBlICE9PSBFeHByVHlwZS5BQ0NFU1NPUikge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdIEludmFsaWQgRXhwcmVzc2lvbiBpbiBEYXRhIHNldDogJyArIGV4cHJSYXcpO1xuLy8gICAgIH1cbiAgICAvLyAjW2VuZF1cblxuICAgIGlmICh0aGlzLmdldChleHByKSA9PT0gdmFsdWUgJiYgIW9wdGlvbi5mb3JjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5yYXcgPSBpbW11dGFibGVTZXQodGhpcy5yYXcsIGV4cHIucGF0aHMsIHZhbHVlLCB0aGlzKTtcbiAgICB0aGlzLmZpcmUoe1xuICAgICAgICB0eXBlOiBEYXRhQ2hhbmdlVHlwZS5TRVQsXG4gICAgICAgIGV4cHI6IGV4cHIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgb3B0aW9uOiBvcHRpb25cbiAgICB9KTtcblxuICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgdGhpcy5jaGVja0RhdGFUeXBlcygpO1xuICAgIC8vICNbZW5kXVxuXG59O1xuXG4vKipcbiAqIOWQiOW5tuabtOaWsOaVsOaNrumhuVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXhwciDmlbDmja7pobnot6/lvoRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2Ug5b6F5ZCI5bm255qE5pWw5o2u5YC8XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqL1xuRGF0YS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoZXhwciwgc291cmNlLCBvcHRpb24pIHtcbiAgICBvcHRpb24gPSBvcHRpb24gfHwge307XG5cbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgIHZhciBleHByUmF3ID0gZXhwcjtcbiAgICAvLyAjW2VuZF1cblxuICAgIGV4cHIgPSBwYXJzZUV4cHIoZXhwcik7XG5cbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgIGlmIChleHByLnR5cGUgIT09IEV4cHJUeXBlLkFDQ0VTU09SKSB7XG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gSW52YWxpZCBFeHByZXNzaW9uIGluIERhdGEgbWVyZ2U6ICcgKyBleHByUmF3KTtcbi8vICAgICB9XG4vLyBcbi8vICAgICBpZiAodHlwZW9mIHRoaXMuZ2V0KGV4cHIpICE9PSAnb2JqZWN0Jykge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdIE1lcmdlIEV4cGVjdHMgYSBUYXJnZXQgb2YgVHlwZSBcXCdvYmplY3RcXCc7IGdvdCAnICsgdHlwZW9mIG9sZFZhbHVlKTtcbi8vICAgICB9XG4vLyBcbi8vICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbi8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSBNZXJnZSBFeHBlY3RzIGEgU291cmNlIG9mIFR5cGUgXFwnb2JqZWN0XFwnOyBnb3QgJyArIHR5cGVvZiBzb3VyY2UpO1xuLy8gICAgIH1cbiAgICAvLyAjW2VuZF1cblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB0aGlzLnNldChcbiAgICAgICAgICAgIGNyZWF0ZUFjY2Vzc29yKFxuICAgICAgICAgICAgICAgIGV4cHIucGF0aHMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuU1RSSU5HLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgIG9wdGlvblxuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8qKlxuICog5Z+65LqO5pu05paw5Ye95pWw5pu05paw5pWw5o2u6aG5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4g5pWw5o2u5aSE55CG5Ye95pWwXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqL1xuRGF0YS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoZXhwciwgZm4sIG9wdGlvbikge1xuICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgdmFyIGV4cHJSYXcgPSBleHByO1xuICAgIC8vICNbZW5kXVxuXG4gICAgZXhwciA9IHBhcnNlRXhwcihleHByKTtcblxuICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgaWYgKGV4cHIudHlwZSAhPT0gRXhwclR5cGUuQUNDRVNTT1IpIHtcbi8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSBJbnZhbGlkIEV4cHJlc3Npb24gaW4gRGF0YSBhcHBseTogJyArIGV4cHJSYXcpO1xuLy8gICAgIH1cbiAgICAvLyAjW2VuZF1cblxuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0KGV4cHIpO1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbi8vICAgICAgICAgICAgICdbU0FOIEVSUk9SXSBJbnZhbGlkIEFyZ3VtZW50XFwncyBUeXBlIGluIERhdGEgYXBwbHk6ICdcbi8vICAgICAgICAgICAgICsgJ0V4cGVjdGVkIEZ1bmN0aW9uIGJ1dCBnb3QgJyArIHR5cGVvZiBmblxuLy8gICAgICAgICApO1xuLy8gICAgIH1cbiAgICAvLyAjW2VuZF1cblxuICAgIHRoaXMuc2V0KGV4cHIsIGZuKG9sZFZhbHVlKSwgb3B0aW9uKTtcbn07XG5cbi8qKlxuICog5pWw57uE5pWw5o2u6aG5c3BsaWNl5pON5L2cXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBzcGxpY2Ug5o6l5Y+X55qE5Y+C5pWw5YiX6KGo77yM5pWw57uE6aG55LiOQXJyYXkucHJvdG90eXBlLnNwbGljZeeahOWPguaVsOS4gOiHtFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb24g6K6+572u5Y+C5pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbi5zaWxlbnQg6Z2Z6buY6K6+572u77yM5LiN6Kem5Y+R5Y+Y5pu05LqL5Lu2XG4gKiBAcmV0dXJuIHtBcnJheX0g5paw5pWw57uEXG4gKi9cbkRhdGEucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChleHByLCBhcmdzLCBvcHRpb24pIHtcbiAgICBvcHRpb24gPSBvcHRpb24gfHwge307XG4gICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICB2YXIgZXhwclJhdyA9IGV4cHI7XG4gICAgLy8gI1tlbmRdXG5cbiAgICBleHByID0gcGFyc2VFeHByKGV4cHIpO1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICBpZiAoZXhwci50eXBlICE9PSBFeHByVHlwZS5BQ0NFU1NPUikge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdIEludmFsaWQgRXhwcmVzc2lvbiBpbiBEYXRhIHNwbGljZTogJyArIGV4cHJSYXcpO1xuLy8gICAgIH1cbiAgICAvLyAjW2VuZF1cblxuICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldChleHByKTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBbXTtcblxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgaW5kZXggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgbGVuID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4ID4gbGVuKSB7XG4gICAgICAgICAgICBpbmRleCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gbGVuICsgaW5kZXg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0FycmF5ID0gdGFyZ2V0LnNsaWNlKDApO1xuICAgICAgICByZXR1cm5WYWx1ZSA9IG5ld0FycmF5LnNwbGljZS5hcHBseShuZXdBcnJheSwgYXJncyk7XG4gICAgICAgIGRhdGFDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnJhdyA9IGltbXV0YWJsZVNldCh0aGlzLnJhdywgZXhwci5wYXRocywgbmV3QXJyYXksIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICBleHByOiBleHByLFxuICAgICAgICAgICAgdHlwZTogRGF0YUNoYW5nZVR5cGUuU1BMSUNFLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZGVsZXRlQ291bnQ6IHJldHVyblZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIHZhbHVlOiByZXR1cm5WYWx1ZSxcbiAgICAgICAgICAgIGluc2VydGlvbnM6IGFyZ3Muc2xpY2UoMiksXG4gICAgICAgICAgICBvcHRpb246IG9wdGlvblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgIHRoaXMuY2hlY2tEYXRhVHlwZXMoKTtcbiAgICAvLyAjW2VuZF1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbi8qKlxuICog5pWw57uE5pWw5o2u6aG5cHVzaOaTjeS9nFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXhwciDmlbDmja7pobnot6/lvoRcbiAqIEBwYXJhbSB7Kn0gaXRlbSDopoFwdXNo55qE5YC8XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqIEByZXR1cm4ge251bWJlcn0g5paw5pWw57uE55qEbGVuZ3Ro5bGe5oCnXG4gKi9cbkRhdGEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZXhwciwgaXRlbSwgb3B0aW9uKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0KGV4cHIpO1xuXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGV4cHIsIFt0YXJnZXQubGVuZ3RoLCAwLCBpdGVtXSwgb3B0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggKyAxO1xuICAgIH1cbn07XG5cbi8qKlxuICog5pWw57uE5pWw5o2u6aG5cG9w5pON5L2cXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb24g6K6+572u5Y+C5pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbi5zaWxlbnQg6Z2Z6buY6K6+572u77yM5LiN6Kem5Y+R5Y+Y5pu05LqL5Lu2XG4gKiBAcmV0dXJuIHsqfVxuICovXG5EYXRhLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoZXhwciwgb3B0aW9uKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0KGV4cHIpO1xuXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhciBsZW4gPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoZXhwciwgW2xlbiAtIDEsIDFdLCBvcHRpb24pWzBdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiDmlbDnu4TmlbDmja7poblzaGlmdOaTjeS9nFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXhwciDmlbDmja7pobnot6/lvoRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uIOiuvue9ruWPguaVsFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb24uc2lsZW50IOmdmem7mOiuvue9ru+8jOS4jeinpuWPkeWPmOabtOS6i+S7tlxuICogQHJldHVybiB7Kn1cbiAqL1xuRGF0YS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoZXhwciwgb3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGV4cHIsIFswLCAxXSwgb3B0aW9uKVswXTtcbn07XG5cbi8qKlxuICog5pWw57uE5pWw5o2u6aG5dW5zaGlmdOaTjeS9nFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXhwciDmlbDmja7pobnot6/lvoRcbiAqIEBwYXJhbSB7Kn0gaXRlbSDopoF1bnNoaWZ055qE5YC8XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqIEByZXR1cm4ge251bWJlcn0g5paw5pWw57uE55qEbGVuZ3Ro5bGe5oCnXG4gKi9cbkRhdGEucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoZXhwciwgaXRlbSwgb3B0aW9uKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0KGV4cHIpO1xuXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGV4cHIsIFswLCAwLCBpdGVtXSwgb3B0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggKyAxO1xuICAgIH1cbn07XG5cbi8qKlxuICog5pWw57uE5pWw5o2u6aG556e76Zmk5pON5L2cXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOimgeenu+mZpOmhueeahOe0ouW8lVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb24g6K6+572u5Y+C5pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbi5zaWxlbnQg6Z2Z6buY6K6+572u77yM5LiN6Kem5Y+R5Y+Y5pu05LqL5Lu2XG4gKi9cbkRhdGEucHJvdG90eXBlLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGV4cHIsIGluZGV4LCBvcHRpb24pIHtcbiAgICB0aGlzLnNwbGljZShleHByLCBbaW5kZXgsIDFdLCBvcHRpb24pO1xufTtcblxuLyoqXG4gKiDmlbDnu4TmlbDmja7pobnnp7vpmaTmk43kvZxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV4cHIg5pWw5o2u6aG56Lev5b6EXG4gKiBAcGFyYW0geyp9IHZhbHVlIOimgeenu+mZpOeahOmhuVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb24g6K6+572u5Y+C5pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbi5zaWxlbnQg6Z2Z6buY6K6+572u77yM5LiN6Kem5Y+R5Y+Y5pu05LqL5Lu2XG4gKi9cbkRhdGEucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChleHByLCB2YWx1ZSwgb3B0aW9uKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0KGV4cHIpO1xuXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhciBsZW4gPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRbbGVuXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGljZShleHByLCBbbGVuLCAxXSwgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERhdGE7XG5cblxuLyoqXG4gKiBAZmlsZSDlo7DmmI7lvI/kuovku7bnmoTnm5HlkKzlh73mlbBcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGV2YWxBcmdzID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWFyZ3MnKTtcbi8vIHZhciBmaW5kTWV0aG9kID0gcmVxdWlyZSgnLi4vcnVudGltZS9maW5kLW1ldGhvZCcpO1xuLy8gdmFyIERhdGEgPSByZXF1aXJlKCcuLi9ydW50aW1lL2RhdGEnKTtcblxuLyoqXG4gKiDlo7DmmI7lvI/kuovku7bnmoTnm5HlkKzlh73mlbBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRCaW5kIOe7keWumuS/oeaBr+WvueixoVxuICogQHBhcmFtIHtib29sZWFufSBpc0NvbXBvbmVudEV2ZW50IOaYr+WQpue7hOS7tuiHquWumuS5ieS6i+S7tlxuICogQHBhcmFtIHtEYXRhfSBkYXRhIOaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtFdmVudH0gZSDkuovku7blr7nosaFcbiAqL1xuZnVuY3Rpb24gZXZlbnREZWNsYXJhdGlvbkxpc3RlbmVyKGV2ZW50QmluZCwgaXNDb21wb25lbnRFdmVudCwgZGF0YSwgZSkge1xuICAgIHZhciBtZXRob2QgPSBmaW5kTWV0aG9kKHRoaXMsIGV2ZW50QmluZC5leHByLm5hbWUsIGRhdGEpO1xuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gbmV3IERhdGEoXG4gICAgICAgICAgICB7JGV2ZW50OiBpc0NvbXBvbmVudEV2ZW50ID8gZSA6IGUgfHwgd2luZG93LmV2ZW50fSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgKTtcbiAgICAgICAgbWV0aG9kLmFwcGx5KHRoaXMsIGV2YWxBcmdzKGV2ZW50QmluZC5leHByLmFyZ3MsIHNjb3BlLCB0aGlzKSk7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBldmVudERlY2xhcmF0aW9uTGlzdGVuZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDmmK/lkKbmtY/op4jlmajnjq/looNcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaXNCcm93c2VyO1xuXG5cbi8qKlxuICogQGZpbGUgaW5zZXJ0QmVmb3JlIOaWueazleeahOWFvOWuueaAp+WwgeijhVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBpbnNlcnRCZWZvcmUg5pa55rOV55qE5YW85a655oCn5bCB6KOFXG4gKlxuICogQHBhcmFtIHtIVE1MTm9kZX0gdGFyZ2V0RWwg6KaB5o+S5YWl55qE6IqC54K5XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRFbCDniLblhYPntKBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQ/fSBiZWZvcmVFbCDlnKjmraTlhYPntKDkuYvliY3mj5LlhaVcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHRhcmdldEVsLCBwYXJlbnRFbCwgYmVmb3JlRWwpIHtcbiAgICBpZiAocGFyZW50RWwpIHtcbiAgICAgICAgaWYgKGJlZm9yZUVsKSB7XG4gICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUodGFyZ2V0RWwsIGJlZm9yZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRhcmdldEVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QmVmb3JlO1xuXG5cbi8qKlxuICogQGZpbGUg5Yik5pat5YWD57Sg5piv5ZCm5LiN5YWB6K646K6+572uSFRNTFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gc29tZSBodG1sIGVsZW1lbnRzIGNhbm5vdCBzZXQgaW5uZXJIVE1MIGluIG9sZCBpZVxuLy8gc2VlOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMzODk3KFZTLjg1KS5hc3B4XG5cbi8qKlxuICog5Yik5pat5YWD57Sg5piv5ZCm5LiN5YWB6K646K6+572uSFRNTFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOimgeWIpOaWreeahOWFg+e0oFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbm9TZXRIVE1MKGVsKSB7XG4gICAgcmV0dXJuIC9eKGNvbHxjb2xncm91cHxmcmFtZXNldHxzdHlsZXx0YWJsZXx0Ym9keXx0Zm9vdHx0aGVhZHx0cnxzZWxlY3QpJC9pLnRlc3QoZWwudGFnTmFtZSk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5vU2V0SFRNTDtcblxuXG4vKipcbiAqIEBmaWxlICDojrflj5boioLngrkgc3R1bXAg55qEIGNvbW1lbnRcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBub1NldEhUTUwgPSByZXF1aXJlKCcuLi9icm93c2VyL25vLXNldC1odG1sJyk7XG5cbi8vICNbYmVnaW5dIGVycm9yXG4vLyAvKipcbi8vICAqIOiOt+WPluiKgueCuSBzdHVtcCDnmoQgY29tbWVudFxuLy8gICpcbi8vICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEhUTUzlhYPntKBcbi8vICAqL1xuLy8gZnVuY3Rpb24gd2FyblNldEhUTUwoZWwpIHtcbi8vICAgICAvLyBkb250IHdhcm4gaWYgbm90IGluIGJyb3dzZXIgcnVudGltZVxuLy8gICAgIGlmICghKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCkpIHtcbi8vICAgICAgICAgcmV0dXJuO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIC8vIHNvbWUgaHRtbCBlbGVtZW50cyBjYW5ub3Qgc2V0IGlubmVySFRNTCBpbiBvbGQgaWVcbi8vICAgICAvLyBzZWU6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzM4OTcoVlMuODUpLmFzcHhcbi8vICAgICBpZiAobm9TZXRIVE1MKGVsKSkge1xuLy8gICAgICAgICB2YXIgbWVzc2FnZSA9ICdbU0FOIFdBUk5JTkddIHNldCBodG1sIGZvciBlbGVtZW50IFwiJyArIGVsLnRhZ05hbWVcbi8vICAgICAgICAgICAgICsgJ1wiIG1heSBjYXVzZSBhbiBlcnJvciBpbiBvbGQgSUUnO1xuLy8gICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4vLyAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4vLyAgICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4vLyAgICAgfVxuLy8gfVxuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHdhcm5TZXRIVE1MO1xuXG5cbi8qKlxuICogQGZpbGUg5Yik5pat5piv5ZCm57uT5p2f5qGpXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyAjW2JlZ2luXSByZXZlcnNlXG4vKipcbiAqIOWIpOaWreaYr+WQpue7k+adn+ahqVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTENvbW1lbnR9IHRhcmdldCDopoHliKTmlq3nmoTlhYPntKBcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOahqeexu+Wei1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbmRTdHVtcCh0YXJnZXQsIHR5cGUpIHtcbiAgICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSA4ICYmIHRhcmdldC5kYXRhID09PSAnL3MtJyArIHR5cGU7XG59XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaXNFbmRTdHVtcDtcblxuXG4vKipcbiAqIEBmaWxlIOiOt+WPluiKgueCueWcqOe7hOS7tuagkeS4reeahOi3r+W+hFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuXG4vLyAjW2JlZ2luXSByZXZlcnNlXG4vKipcbiAqIOiOt+WPluiKgueCueWcqOe7hOS7tuagkeS4reeahOi3r+W+hFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSDoioLngrnlr7nosaFcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXROb2RlUGF0aChub2RlKSB7XG4gICAgdmFyIG5vZGVQYXRocyA9IFtdO1xuICAgIHZhciBub2RlUGFyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAobm9kZVBhcmVudCkge1xuICAgICAgICBzd2l0Y2ggKG5vZGVQYXJlbnQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuRUxFTTpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdChub2RlUGFyZW50LnRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLklGOlxuICAgICAgICAgICAgICAgIG5vZGVQYXRocy51bnNoaWZ0KCdpZicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLkZPUjpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgnZm9yWycgKyBub2RlUGFyZW50LmFub2RlLmRpcmVjdGl2ZXNbJ2ZvciddLnJhdyArICddJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuU0xPVDpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgnc2xvdFsnICsgKG5vZGVQYXJlbnQubmFtZSB8fCAnZGVmYXVsdCcpICsgJ10nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5UUEw6XG4gICAgICAgICAgICAgICAgbm9kZVBhdGhzLnVuc2hpZnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuQ01QVDpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgnY29tcG9uZW50WycgKyAobm9kZVBhcmVudC5zdWJUYWcgfHwgJ3Jvb3QnKSArICddJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuVEVYVDpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgndGV4dCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZVBhcmVudCA9IG5vZGVQYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBub2RlUGF0aHM7XG59XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZVBhdGg7XG5cblxuLyoqXG4gKiBAZmlsZSB0ZXh0IOiKgueCueexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGlzQnJvd3NlciA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaXMtYnJvd3NlcicpO1xuLy8gdmFyIHJlbW92ZUVsID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9yZW1vdmUtZWwnKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcbi8vIHZhciBjaGFuZ2VFeHByQ29tcGFyZSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY2hhbmdlLWV4cHItY29tcGFyZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgd2FyblNldEhUTUwgPSByZXF1aXJlKCcuL3dhcm4tc2V0LWh0bWwnKTtcbi8vIHZhciBpc0VuZFN0dW1wID0gcmVxdWlyZSgnLi9pcy1lbmQtc3R1bXAnKTtcbi8vIHZhciBnZXROb2RlUGF0aCA9IHJlcXVpcmUoJy4vZ2V0LW5vZGUtcGF0aCcpO1xuXG5cbi8qKlxuICogdGV4dCDoioLngrnnsbtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYU5vZGUg5oq96LGh6IqC54K5XG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu2546v5aKDXG4gKiBAcGFyYW0ge01vZGVsPX0gc2NvcGUg5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCDniLbkurLoioLngrlcbiAqIEBwYXJhbSB7RE9NQ2hpbGRyZW5XYWxrZXI/fSByZXZlcnNlV2Fsa2VyIOWtkOWFg+e0oOmBjeWOhuWvueixoVxuICovXG5mdW5jdGlvbiBUZXh0Tm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB0aGlzLmFOb2RlID0gYU5vZGU7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSByZXZlcnNlV2Fsa2VyLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Tm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmRhdGEgPT09ICdzLXRleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuZGF0YSA9IHRoaXMuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLmdvTmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSByZXZlcnNlV2Fsa2VyLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gUkVWRVJTRSBFUlJPUl0gVGV4dCBlbmQgZmxhZyBub3QgZm91bmQuIFxcblBhdGhzOiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGdldE5vZGVQYXRoKHRoaXMpLmpvaW4oJyA+ICcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbmRTdHVtcChjdXJyZW50Tm9kZSwgJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VXYWxrZXIuZ29OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmRhdGEgPSB0aGlzLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLmdvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLmdvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcmV2ZXJzZVdhbGtlci50YXJnZXQsIHJldmVyc2VXYWxrZXIuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cblRleHROb2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5vZGVUeXBlLlRFWFQ7XG5cbi8qKlxuICog5bCGdGV4dCBhdHRhY2jliLDpobXpnaJcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRFbCDopoHmt7vliqDliLDnmoTniLblhYPntKBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnTvvJ19IGJlZm9yZUVsIOimgea3u+WKoOWIsOWTquS4quWFg+e0oOS5i+WJjVxuICovXG5UZXh0Tm9kZS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBhcmVudEVsLCBiZWZvcmVFbCkge1xuICAgIHRoaXMuY29udGVudCA9IGV2YWxFeHByKHRoaXMuYU5vZGUudGV4dEV4cHIsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpO1xuXG4gICAgaWYgKHRoaXMuYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbiAgICAgICAgdGhpcy5zZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xuICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5zZWwsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG5cbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy5pZCk7XG4gICAgICAgIGluc2VydEJlZm9yZSh0aGlzLmVsLCBwYXJlbnRFbCwgYmVmb3JlRWwpO1xuXG4gICAgICAgIHZhciB0ZW1wRmxhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUodGVtcEZsYWcsIHRoaXMuZWwpO1xuICAgICAgICB0ZW1wRmxhZy5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWJlZ2luJywgdGhpcy5jb250ZW50KTtcbiAgICAgICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEZsYWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCk7XG4gICAgICAgIGluc2VydEJlZm9yZSh0aGlzLmVsLCBwYXJlbnRFbCwgYmVmb3JlRWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICog6ZSA5q+BIHRleHQg6IqC54K5XG4gKi9cblRleHROb2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIHRoaXMuc2VsID0gbnVsbDtcbn07XG5cbnZhciB0ZXh0VXBkYXRlUHJvcCA9IGlzQnJvd3NlclxuICAgICYmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpLnRleHRDb250ZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICA/ICd0ZXh0Q29udGVudCdcbiAgICAgICAgOiAnZGF0YScpO1xuXG4vKipcbiAqIOabtOaWsCB0ZXh0IOiKgueCueeahOinhuWbvlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMg5pWw5o2u5Y+Y5YyW5L+h5oGvXG4gKi9cblRleHROb2RlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBpZiAodGhpcy5hTm9kZS50ZXh0RXhwci52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGNoYW5nZXMgPyBjaGFuZ2VzLmxlbmd0aCA6IDA7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGlmIChjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VzW2xlbl0uZXhwciwgdGhpcy5hTm9kZS50ZXh0RXhwciwgdGhpcy5zY29wZSkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZXZhbEV4cHIodGhpcy5hTm9kZS50ZXh0RXhwciwgdGhpcy5zY29wZSwgdGhpcy5vd25lcik7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0ICE9PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSB0ZXh0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVtb3ZlRWwgPSB0aGlzLnNlbC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5lbC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydFJlbW92ZUVsICE9PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlVGFyZ2V0ID0gc3RhcnRSZW1vdmVFbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UmVtb3ZlRWwgPSBzdGFydFJlbW92ZUVsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWwocmVtb3ZlVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgICAgICAgICAgICAgICAgIHdhcm5TZXRIVE1MKHBhcmVudEVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gI1tlbmRdXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBGbGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZSh0ZW1wRmxhZywgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBGbGFnLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEZsYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbFt0ZXh0VXBkYXRlUHJvcF0gPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVGV4dE5vZGU7XG5cblxuLyoqXG4gKiBAZmlsZSDorqHnrpfkuKTkuKrlr7nosaEga2V5IOeahOW5tumbhlxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDorqHnrpfkuKTkuKrlr7nosaEga2V5IOeahOW5tumbhlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIOebruagh+WvueixoVxuICogQHBhcmFtIHtPYmplY3R9IG9iajIg5rqQ5a+56LGhXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gdW5pb25LZXlzKG9iajEsIG9iajIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMSkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBvYmoyKSB7XG4gICAgICAgICFvYmoxW2tleV0gJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB1bmlvbktleXM7XG5cblxuLyoqXG4gKiBAZmlsZSDliKTmlq3lj5jmm7TmlbDnu4TmmK/lkKblvbHlk43liLDmlbDmja7lvJXnlKjmkZjopoFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLyoqXG4gKiDliKTmlq3lj5jmm7TmlbDnu4TmmK/lkKblvbHlk43liLDmlbDmja7lvJXnlKjmkZjopoFcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VzIOWPmOabtOaVsOe7hFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFSZWYg5pWw5o2u5byV55So5pGY6KaBXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjaGFuZ2VzSXNJbkRhdGFSZWYoY2hhbmdlcywgZGF0YVJlZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcblxuICAgICAgICBpZiAoIWNoYW5nZS5vdmVydmlldykge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gY2hhbmdlLmV4cHIucGF0aHM7XG4gICAgICAgICAgICBjaGFuZ2Uub3ZlcnZpZXcgPSBwYXRoc1swXS52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UuZXh0T3ZlcnZpZXcgPSBwYXRoc1swXS52YWx1ZSArICcuJyArIHBhdGhzWzFdLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZS53aWxkT3ZlcnZpZXcgPSBwYXRoc1swXS52YWx1ZSArICcuKic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVJlZltjaGFuZ2Uub3ZlcnZpZXddXG4gICAgICAgICAgICB8fCBjaGFuZ2Uud2lsZE92ZXJ2aWV3ICYmIGRhdGFSZWZbY2hhbmdlLndpbGRPdmVydmlld11cbiAgICAgICAgICAgIHx8IGNoYW5nZS5leHRPdmVydmlldyAmJiBkYXRhUmVmW2NoYW5nZS5leHRPdmVydmlld11cbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY2hhbmdlc0lzSW5EYXRhUmVmO1xuXG5cbi8qKlxuICogQGZpbGUg5YWD57Sg5a2Q6IqC54K56YGN5Y6G5pON5L2c57G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgcmVtb3ZlRWwgPSByZXF1aXJlKCcuLi9icm93c2VyL3JlbW92ZS1lbCcpO1xuXG4vLyAjW2JlZ2luXSByZXZlcnNlXG4vKipcbiAqIOWFg+e0oOWtkOiKgueCuemBjeWOhuaTjeS9nOexu1xuICpcbiAqIEBpbm5lclxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDopoHpgY3ljobnmoTlhYPntKBcbiAqL1xuZnVuY3Rpb24gRE9NQ2hpbGRyZW5XYWxrZXIoZWwpIHtcbiAgICB0aGlzLnJhdyA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMudGFyZ2V0ID0gZWw7XG5cbiAgICB2YXIgY2hpbGQgPSBlbC5maXJzdENoaWxkO1xuICAgIHZhciBuZXh0O1xuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgc3dpdGNoIChjaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICgvXlxccyokLy50ZXN0KGNoaWxkLmRhdGEgfHwgY2hpbGQudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmF3LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHRoaXMucmF3LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucmF3W3RoaXMuaW5kZXhdO1xuICAgIHRoaXMubmV4dCA9IHRoaXMucmF3W3RoaXMuaW5kZXggKyAxXTtcbn1cblxuLyoqXG4gKiDlvoDkuIvotbDkuIDkuKrlhYPntKBcbiAqL1xuRE9NQ2hpbGRyZW5XYWxrZXIucHJvdG90eXBlLmdvTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJhd1srK3RoaXMuaW5kZXhdO1xuICAgIHRoaXMubmV4dCA9IHRoaXMucmF3W3RoaXMuaW5kZXggKyAxXTtcbn07XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5XYWxrZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDlhYPntKDoioLngrnnsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcbi8vIHZhciBndWlkID0gcmVxdWlyZSgnLi4vdXRpbC9ndWlkJyk7XG4vLyB2YXIgdW5pb25LZXlzID0gcmVxdWlyZSgnLi4vdXRpbC91bmlvbi1rZXlzJyk7XG4vLyB2YXIgcmVtb3ZlRWwgPSByZXF1aXJlKCcuLi9icm93c2VyL3JlbW92ZS1lbCcpO1xuLy8gdmFyIGNoYW5nZUV4cHJDb21wYXJlID0gcmVxdWlyZSgnLi4vcnVudGltZS9jaGFuZ2UtZXhwci1jb21wYXJlJyk7XG4vLyB2YXIgY2hhbmdlc0lzSW5EYXRhUmVmID0gcmVxdWlyZSgnLi4vcnVudGltZS9jaGFuZ2VzLWlzLWluLWRhdGEtcmVmJyk7XG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuLy8gdmFyIExpZmVDeWNsZSA9IHJlcXVpcmUoJy4vbGlmZS1jeWNsZScpO1xuLy8gdmFyIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9ub2RlLXR5cGUnKTtcbi8vIHZhciByZXZlcnNlRWxlbWVudENoaWxkcmVuID0gcmVxdWlyZSgnLi9yZXZlcnNlLWVsZW1lbnQtY2hpbGRyZW4nKTtcbi8vIHZhciBpc0RhdGFDaGFuZ2VCeUVsZW1lbnQgPSByZXF1aXJlKCcuL2lzLWRhdGEtY2hhbmdlLWJ5LWVsZW1lbnQnKTtcbi8vIHZhciBlbGVtZW50VXBkYXRlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtdXBkYXRlLWNoaWxkcmVuJyk7XG4vLyB2YXIgZWxlbWVudE93bkNyZWF0ZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tY3JlYXRlJyk7XG4vLyB2YXIgZWxlbWVudE93bkF0dGFjaCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tYXR0YWNoJyk7XG4vLyB2YXIgZWxlbWVudE93bkRldGFjaCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tZGV0YWNoJyk7XG4vLyB2YXIgZWxlbWVudE93bkRpc3Bvc2UgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWRpc3Bvc2UnKTtcbi8vIHZhciBlbGVtZW50T3duT25FbCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tb24tZWwnKTtcbi8vIHZhciBlbGVtZW50T3duVG9QaGFzZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tdG8tcGhhc2UnKTtcbi8vIHZhciBlbGVtZW50T3duQXR0YWNoZWQgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWF0dGFjaGVkJyk7XG4vLyB2YXIgZWxlbWVudERpc3Bvc2UgPSByZXF1aXJlKCcuL2VsZW1lbnQtZGlzcG9zZScpO1xuLy8gdmFyIGVsZW1lbnRJbml0VGFnTmFtZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1pbml0LXRhZy1uYW1lJyk7XG4vLyB2YXIgbm9kZVNCaW5kSW5pdCA9IHJlcXVpcmUoJy4vbm9kZS1zLWJpbmQtaW5pdCcpO1xuLy8gdmFyIG5vZGVTQmluZFVwZGF0ZSA9IHJlcXVpcmUoJy4vbm9kZS1zLWJpbmQtdXBkYXRlJyk7XG4vLyB2YXIgaGFuZGxlUHJvcCA9IHJlcXVpcmUoJy4vaGFuZGxlLXByb3AnKTtcbi8vIHZhciB3YXJuU2V0SFRNTCA9IHJlcXVpcmUoJy4vd2Fybi1zZXQtaHRtbCcpO1xuLy8gdmFyIGdldE5vZGVQYXRoID0gcmVxdWlyZSgnLi9nZXQtbm9kZS1wYXRoJyk7XG5cbi8qKlxuICog5YWD57Sg6IqC54K557G7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHBhcmFtIHtNb2RlbD19IHNjb3BlIOaJgOWxnuaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge0RPTUNoaWxkcmVuV2Fsa2VyP30gcmV2ZXJzZVdhbGtlciDlrZDlhYPntKDpgY3ljoblr7nosaFcbiAqL1xuZnVuY3Rpb24gRWxlbWVudChhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB0aGlzLmFOb2RlID0gYU5vZGU7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIHRoaXMubGlmZUN5Y2xlID0gTGlmZUN5Y2xlLnN0YXJ0O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl9lbEZucyA9IFtdO1xuICAgIHRoaXMucGFyZW50Q29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgID8gcGFyZW50XG4gICAgICAgIDogcGFyZW50LnBhcmVudENvbXBvbmVudDtcblxuICAgIHRoaXMuaWQgPSBndWlkKCk7XG5cbiAgICBlbGVtZW50SW5pdFRhZ05hbWUodGhpcyk7XG5cbiAgICBub2RlU0JpbmRJbml0KHRoaXMsIGFOb2RlLmRpcmVjdGl2ZXMuYmluZCk7XG5cbiAgICB0aGlzLl90b1BoYXNlKCdpbml0ZWQnKTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSByZXZlcnNlV2Fsa2VyLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIFJFVkVSU0UgRVJST1JdIEVsZW1lbnQgbm90IGZvdW5kLiBcXG5QYXRoczogJ1xuICAgICAgICAgICAgICAgICsgZ2V0Tm9kZVBhdGgodGhpcykuam9pbignID4gJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gUkVWRVJTRSBFUlJPUl0gRWxlbWVudCB0eXBlIG5vdCBtYXRjaCwgZXhwZWN0IDEgYnV0ICdcbiAgICAgICAgICAgICAgICArIGN1cnJlbnROb2RlLm5vZGVUeXBlICsgJy5cXG5QYXRoczogJ1xuICAgICAgICAgICAgICAgICsgZ2V0Tm9kZVBhdGgodGhpcykuam9pbignID4gJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGhpcy50YWdOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gUkVWRVJTRSBFUlJPUl0gRWxlbWVudCB0YWdOYW1lIG5vdCBtYXRjaCwgZXhwZWN0ICdcbiAgICAgICAgICAgICAgICArIHRoaXMudGFnTmFtZSArICcgYnV0IG1lYXQgJyArIGN1cnJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICcuXFxuUGF0aHM6ICdcbiAgICAgICAgICAgICAgICArIGdldE5vZGVQYXRoKHRoaXMpLmpvaW4oJyA+ICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWwgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgcmV2ZXJzZVdhbGtlci5nb05leHQoKTtcblxuICAgICAgICByZXZlcnNlRWxlbWVudENoaWxkcmVuKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkKCk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG5cblxuRWxlbWVudC5wcm90b3R5cGUubm9kZVR5cGUgPSBOb2RlVHlwZS5FTEVNO1xuXG5cbkVsZW1lbnQucHJvdG90eXBlLmF0dGFjaCA9IGVsZW1lbnRPd25BdHRhY2g7XG5FbGVtZW50LnByb3RvdHlwZS5kZXRhY2ggPSBlbGVtZW50T3duRGV0YWNoO1xuRWxlbWVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGVsZW1lbnRPd25EaXNwb3NlO1xuRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZSA9IGVsZW1lbnRPd25DcmVhdGU7XG5FbGVtZW50LnByb3RvdHlwZS5fdG9QaGFzZSA9IGVsZW1lbnRPd25Ub1BoYXNlO1xuRWxlbWVudC5wcm90b3R5cGUuX29uRWwgPSBlbGVtZW50T3duT25FbDtcblxuRWxlbWVudC5wcm90b3R5cGUuX2RvbmVMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sZWF2ZURpc3Bvc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpZmVDeWNsZS5kaXNwb3NlZCkge1xuICAgICAgICAgICAgZWxlbWVudERpc3Bvc2UoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VOb0RldGFjaCxcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VOb1RyYW5zaXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5saWZlQ3ljbGUuYXR0YWNoZWQpIHtcbiAgICAgICAgcmVtb3ZlRWwodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuX3RvUGhhc2UoJ2RldGFjaGVkJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDop4blm77mm7TmlrBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VzIOaVsOaNruWPmOWMluS/oeaBr1xuICovXG5FbGVtZW50LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBpZiAoIWNoYW5nZXNJc0luRGF0YVJlZihjaGFuZ2VzLCB0aGlzLmFOb2RlLmhvdHNwb3QuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBzLWJpbmRcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG5vZGVTQmluZFVwZGF0ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5hTm9kZS5kaXJlY3RpdmVzLmJpbmQsXG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gbWUuYU5vZGUuaG90c3BvdC5wcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UHJvcEhhbmRsZXIobWUudGFnTmFtZSwgbmFtZSkucHJvcChtZS5lbCwgdmFsdWUsIG5hbWUsIG1lKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyB1cGRhdGUgcHJvcFxuICAgIHZhciBkeW5hbWljUHJvcHMgPSB0aGlzLmFOb2RlLmhvdHNwb3QuZHluYW1pY1Byb3BzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZHluYW1pY1Byb3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IGR5bmFtaWNQcm9wc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgY2hhbmdlTGVuID0gY2hhbmdlcy5sZW5ndGg7IGogPCBjaGFuZ2VMZW47IGorKykge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal07XG5cbiAgICAgICAgICAgIGlmICghaXNEYXRhQ2hhbmdlQnlFbGVtZW50KGNoYW5nZSwgdGhpcywgcHJvcC5uYW1lKVxuICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlLmV4cHIsIHByb3AuZXhwciwgdGhpcy5zY29wZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgcHJvcC5oaW50RXhwciAmJiBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2UuZXhwciwgcHJvcC5oaW50RXhwciwgdGhpcy5zY29wZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVQcm9wKHRoaXMsIGV2YWxFeHByKHByb3AuZXhwciwgdGhpcy5zY29wZSwgdGhpcy5vd25lciksIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICB2YXIgaHRtbERpcmVjdGl2ZSA9IHRoaXMuYU5vZGUuZGlyZWN0aXZlcy5odG1sO1xuICAgIGlmIChodG1sRGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaGFuZ2VzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlc1tsZW5dLmV4cHIsIGh0bWxEaXJlY3RpdmUudmFsdWUsIHRoaXMuc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICAgICAgICAgICAgICB3YXJuU2V0SFRNTCh0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gZXZhbEV4cHIoaHRtbERpcmVjdGl2ZS52YWx1ZSwgdGhpcy5zY29wZSwgdGhpcy5vd25lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbGVtZW50VXBkYXRlQ2hpbGRyZW4odGhpcywgY2hhbmdlcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDmiafooYzlrozmiJBhdHRhY2hlZOeKtuaAgeeahOihjOS4ulxuICovXG5FbGVtZW50LnByb3RvdHlwZS5fYXR0YWNoZWQgPSBlbGVtZW50T3duQXR0YWNoZWQ7XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG5cblxuLyoqXG4gKiBAZmlsZSDplIDmr4HoioLngrnvvIzmuIXnqbroioLngrnkuIrnmoTml6DnlKjmiJDlkZhcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLyoqXG4gKiDplIDmr4HoioLngrlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSDoioLngrnlr7nosaFcbiAqL1xuZnVuY3Rpb24gbm9kZURpc3Bvc2Uobm9kZSkge1xuICAgIG5vZGUuZWwgPSBudWxsO1xuICAgIG5vZGUuc2VsID0gbnVsbDtcbiAgICBub2RlLm93bmVyID0gbnVsbDtcbiAgICBub2RlLnNjb3BlID0gbnVsbDtcbiAgICBub2RlLmFOb2RlID0gbnVsbDtcbiAgICBub2RlLnBhcmVudCA9IG51bGw7XG4gICAgbm9kZS5wYXJlbnRDb21wb25lbnQgPSBudWxsO1xuICAgIG5vZGUuY2hpbGRyZW4gPSBudWxsO1xuXG4gICAgaWYgKG5vZGUuX3RvUGhhc2UpIHtcbiAgICAgICAgbm9kZS5fdG9QaGFzZSgnZGlzcG9zZWQnKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5fb25kaXNwb3NlZCkge1xuICAgICAgICBub2RlLl9vbmRpc3Bvc2VkKCk7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBub2RlRGlzcG9zZTtcblxuXG4vKipcbiAqIEBmaWxlIOWIneWni+WMluiKgueCueeahCBzLWJpbmQg5pWw5o2uXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBldmFsRXhwciA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZXZhbC1leHByJyk7XG5cbi8qKlxuICog5Yid5aeL5YyW6IqC54K555qEIHMtYmluZCDmlbDmja5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSDoioLngrnlr7nosaFcbiAqL1xuZnVuY3Rpb24gbm9kZVNCaW5kSW5pdChub2RlLCBzQmluZCkge1xuICAgIGlmIChzQmluZCAmJiBub2RlLnNjb3BlKSB7XG4gICAgICAgIG5vZGUuX3NiaW5kRGF0YSA9IGV2YWxFeHByKHNCaW5kLnZhbHVlLCBub2RlLnNjb3BlLCBub2RlLm93bmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBub2RlU0JpbmRJbml0O1xuXG5cbi8qKlxuICogQGZpbGUg5pu05paw6IqC54K555qEIHMtYmluZCDmlbDmja5cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciB1bmlvbktleXMgPSByZXF1aXJlKCcuLi91dGlsL3VuaW9uLWtleXMnKTtcbi8vIHZhciBldmFsRXhwciA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZXZhbC1leHByJyk7XG4vLyB2YXIgY2hhbmdlRXhwckNvbXBhcmUgPSByZXF1aXJlKCcuLi9ydW50aW1lL2NoYW5nZS1leHByLWNvbXBhcmUnKTtcblxuLyoqXG4gKiDliJ3lp4vljJboioLngrnnmoQgcy1iaW5kIOaVsOaNrlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOiKgueCueWvueixoVxuICovXG5mdW5jdGlvbiBub2RlU0JpbmRVcGRhdGUobm9kZSwgc0JpbmQsIGNoYW5nZXMsIHVwZGF0ZXIpIHtcbiAgICBpZiAoc0JpbmQpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoYW5nZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZXNbbGVuXS5leHByLCBzQmluZC52YWx1ZSwgbm9kZS5zY29wZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QmluZERhdGEgPSBldmFsRXhwcihzQmluZC52YWx1ZSwgbm9kZS5zY29wZSwgbm9kZS5vd25lcik7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB1bmlvbktleXMobmV3QmluZERhdGEsIG5vZGUuX3NiaW5kRGF0YSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdCaW5kRGF0YVtrZXldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZS5fc2JpbmREYXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLl9zYmluZERhdGEgPSBuZXdCaW5kRGF0YTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBub2RlU0JpbmRVcGRhdGU7XG5cblxuLyoqXG4gKiBAZmlsZSDpgJrov4fnu4Tku7blj43op6PliJvlu7roioLngrnnmoTlt6XljoLmlrnms5VcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgVGV4dE5vZGUgPSByZXF1aXJlKCcuL3RleHQtbm9kZScpO1xuLy8gdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbi8vIHZhciBTbG90Tm9kZSA9IHJlcXVpcmUoJy4vc2xvdC1ub2RlJyk7XG4vLyB2YXIgRm9yTm9kZSA9IHJlcXVpcmUoJy4vZm9yLW5vZGUnKTtcbi8vIHZhciBJZk5vZGUgPSByZXF1aXJlKCcuL2lmLW5vZGUnKTtcbi8vIHZhciBUZW1wbGF0ZU5vZGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlLW5vZGUnKTtcblxuLy8gI1tiZWdpbl0gcmV2ZXJzZVxuLyoqXG4gKiDpgJrov4fnu4Tku7blj43op6PliJvlu7roioLngrlcbiAqXG4gKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDmir3osaHoioLngrlcbiAqIEBwYXJhbSB7RE9NQ2hpbGRyZW5XYWxrZXJ9IHJldmVyc2VXYWxrZXIg5a2Q5YWD57Sg6YGN5Y6G5a+56LGhXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCDniLbkurLoioLngrlcbiAqIEBwYXJhbSB7TW9kZWw9fSBzY29wZSDmiYDlsZ7mlbDmja7njq/looNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJldmVyc2VOb2RlKGFOb2RlLCByZXZlcnNlV2Fsa2VyLCBwYXJlbnQsIHNjb3BlKSB7XG4gICAgdmFyIHBhcmVudElzQ29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUO1xuICAgIHZhciBvd25lciA9IHBhcmVudElzQ29tcG9uZW50ID8gcGFyZW50IDogKHBhcmVudC5jaGlsZE93bmVyIHx8IHBhcmVudC5vd25lcik7XG4gICAgc2NvcGUgPSBzY29wZSB8fCAocGFyZW50SXNDb21wb25lbnQgPyBwYXJlbnQuZGF0YSA6IChwYXJlbnQuY2hpbGRTY29wZSB8fCBwYXJlbnQuc2NvcGUpKTtcblxuICAgIGlmIChhTm9kZS50ZXh0RXhwcikge1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcik7XG4gICAgfVxuXG4gICAgaWYgKGFOb2RlLmRpcmVjdGl2ZXNbJ2lmJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBJZk5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50LCByZXZlcnNlV2Fsa2VyKTtcbiAgICB9XG5cbiAgICBpZiAoYU5vZGUuZGlyZWN0aXZlc1snZm9yJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBGb3JOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcik7XG4gICAgfVxuXG4gICAgc3dpdGNoIChhTm9kZS50YWdOYW1lKSB7XG4gICAgICAgIGNhc2UgJ3Nsb3QnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbG90Tm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpO1xuXG4gICAgICAgIGNhc2UgJ3RlbXBsYXRlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcik7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBDb21wb25lbnRUeXBlID0gb3duZXIuZ2V0Q29tcG9uZW50VHlwZVxuICAgICAgICAgICAgICAgID8gb3duZXIuZ2V0Q29tcG9uZW50VHlwZShhTm9kZSlcbiAgICAgICAgICAgICAgICA6IG93bmVyLmNvbXBvbmVudHNbYU5vZGUudGFnTmFtZV07XG5cbiAgICAgICAgICAgIGlmIChDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRUeXBlKHtcbiAgICAgICAgICAgICAgICAgICAgYU5vZGU6IGFOb2RlLFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN1YlRhZzogYU5vZGUudGFnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZVdhbGtlcjogcmV2ZXJzZVdhbGtlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRWxlbWVudChhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpO1xufVxuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJldmVyc2VOb2RlO1xuXG5cbi8qKlxuICogQGZpbGUg6ZSA5q+B6YeK5pS+5YWD57Sg55qE5a2Q5YWD57SgXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOmUgOavgemHiuaUvuWFg+e0oOeahOWtkOWFg+e0oFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IOWFg+e0oOiKgueCuVxuICogQHBhcmFtIHtib29sZWFuPX0gbm9EZXRhY2gg5piv5ZCm5LiN6KaB5oqK6IqC54K55LuOZG9t56e76ZmkXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub1RyYW5zaXRpb24g5piv5ZCm5LiN5pi+56S66L+H5rih5Yqo55S75pWI5p6cXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4oZWxlbWVudCwgbm9EZXRhY2gsIG5vVHJhbnNpdGlvbikge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgdmFyIGxlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgY2hpbGRyZW5bbGVuXS5kaXNwb3NlKG5vRGV0YWNoLCBub1RyYW5zaXRpb24pO1xuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudERpc3Bvc2VDaGlsZHJlbjtcblxuXG4vKipcbiAqIEBmaWxlIOabtOaWsOWFg+e0oOeahOWtkOWFg+e0oOinhuWbvlxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vKipcbiAqIOabtOaWsOWFg+e0oOeahOWtkOWFg+e0oOinhuWbvlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IOimgeabtOaWsOeahOWFg+e0oFxuICogQHBhcmFtIHtBcnJheX0gY2hhbmdlcyDmlbDmja7lj5jljJbkv6Hmga9cbiAqL1xuZnVuY3Rpb24gZWxlbWVudFVwZGF0ZUNoaWxkcmVuKGVsZW1lbnQsIGNoYW5nZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW5baV0uX3VwZGF0ZShjaGFuZ2VzKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRVcGRhdGVDaGlsZHJlbjtcblxuXG4vKipcbiAqIEBmaWxlIOS9v+WFg+e0oOiKgueCueWIsOi+vuebuOW6lOeahOeUn+WRveWRqOacn1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgTGlmZUN5Y2xlID0gcmVxdWlyZSgnLi9saWZlLWN5Y2xlJyk7XG5cbi8qKlxuICog5L2/5YWD57Sg6IqC54K55Yiw6L6+55u45bqU55qE55Sf5ZG95ZGo5pyfXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg55Sf5ZG95ZGo5pyf5ZCN56ewXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRPd25Ub1BoYXNlKG5hbWUpIHtcbiAgICB0aGlzLmxpZmVDeWNsZSA9IExpZmVDeWNsZVtuYW1lXSB8fCB0aGlzLmxpZmVDeWNsZTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudE93blRvUGhhc2U7XG5cblxuLyoqXG4gKiBAZmlsZSDliJvlu7roioLngrnnmoTlt6XljoLmlrnms5VcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgVGV4dE5vZGUgPSByZXF1aXJlKCcuL3RleHQtbm9kZScpO1xuLy8gdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbi8vIHZhciBTbG90Tm9kZSA9IHJlcXVpcmUoJy4vc2xvdC1ub2RlJyk7XG4vLyB2YXIgRm9yTm9kZSA9IHJlcXVpcmUoJy4vZm9yLW5vZGUnKTtcbi8vIHZhciBJZk5vZGUgPSByZXF1aXJlKCcuL2lmLW5vZGUnKTtcbi8vIHZhciBUZW1wbGF0ZU5vZGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlLW5vZGUnKTtcblxuXG4vKipcbiAqIOWIm+W7uuiKgueCuVxuICpcbiAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge01vZGVsPX0gc2NvcGUg5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGFOb2RlLCBwYXJlbnQsIHNjb3BlKSB7XG4gICAgdmFyIHBhcmVudElzQ29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUO1xuICAgIHZhciBvd25lciA9IHBhcmVudElzQ29tcG9uZW50ID8gcGFyZW50IDogKHBhcmVudC5jaGlsZE93bmVyIHx8IHBhcmVudC5vd25lcik7XG4gICAgc2NvcGUgPSBzY29wZSB8fCAocGFyZW50SXNDb21wb25lbnQgPyBwYXJlbnQuZGF0YSA6IChwYXJlbnQuY2hpbGRTY29wZSB8fCBwYXJlbnQuc2NvcGUpKTtcblxuXG4gICAgaWYgKGFOb2RlLnRleHRFeHByKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoYU5vZGUuZGlyZWN0aXZlc1snaWYnXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICByZXR1cm4gbmV3IElmTm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChhTm9kZS5kaXJlY3RpdmVzWydmb3InXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICByZXR1cm4gbmV3IEZvck5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGFOb2RlLnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnc2xvdCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNsb3ROb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCk7XG5cbiAgICAgICAgY2FzZSAndGVtcGxhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZU5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIENvbXBvbmVudFR5cGUgPSBvd25lci5nZXRDb21wb25lbnRUeXBlXG4gICAgICAgICAgICAgICAgPyBvd25lci5nZXRDb21wb25lbnRUeXBlKGFOb2RlKVxuICAgICAgICAgICAgICAgIDogb3duZXIuY29tcG9uZW50c1thTm9kZS50YWdOYW1lXTtcblxuICAgICAgICAgICAgaWYgKENvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudFR5cGUoe1xuICAgICAgICAgICAgICAgICAgICBhTm9kZTogYU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgc3ViVGFnOiBhTm9kZS50YWdOYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGU7XG5cblxuLyoqXG4gKiBAZmlsZSDnlJ/miJDlrZDlhYPntKBcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBjcmVhdGVOb2RlID0gcmVxdWlyZSgnLi9jcmVhdGUtbm9kZScpO1xuXG4vKipcbiAqIOeUn+aIkOWtkOWFg+e0oFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCDlhYPntKBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudEVsIOimgea3u+WKoOWIsOeahOeItuWFg+e0oFxuICogQHBhcmFtIHtIVE1MRWxlbWVudO+8nX0gYmVmb3JlRWwg6KaB5re75Yqg5Yiw5ZOq5Liq5YWD57Sg5LmL5YmNXG4gKi9cbmZ1bmN0aW9uIGdlbkVsZW1lbnRDaGlsZHJlbihlbGVtZW50LCBwYXJlbnRFbCwgYmVmb3JlRWwpIHtcbiAgICBwYXJlbnRFbCA9IHBhcmVudEVsIHx8IGVsZW1lbnQuZWw7XG5cbiAgICB2YXIgYU5vZGVDaGlsZHJlbiA9IGVsZW1lbnQuYU5vZGUuY2hpbGRyZW47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTm9kZUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNyZWF0ZU5vZGUoYU5vZGVDaGlsZHJlbltpXSwgZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkLmF0dGFjaChwYXJlbnRFbCwgYmVmb3JlRWwpO1xuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2VuRWxlbWVudENoaWxkcmVuO1xuXG5cbi8qKlxuICogQGZpbGUg5bCG5rKh5pyJIHJvb3Qg5Y+q5pyJIGNoaWxkcmVuIOeahOWFg+e0oCBhdHRhY2gg5Yiw6aG16Z2iXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcbi8vIHZhciBnZW5FbGVtZW50Q2hpbGRyZW4gPSByZXF1aXJlKCcuL2dlbi1lbGVtZW50LWNoaWxkcmVuJyk7XG5cblxuLyoqXG4gKiDlsIbmsqHmnIkgcm9vdCDlj6rmnIkgY2hpbGRyZW4g55qE5YWD57SgIGF0dGFjaCDliLDpobXpnaJcbiAqIOS4u+imgeeUqOS6jiBzbG90IOWSjCB0ZW1wbGF0ZVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudEVsIOimgea3u+WKoOWIsOeahOeItuWFg+e0oFxuICogQHBhcmFtIHtIVE1MRWxlbWVudO+8nX0gYmVmb3JlRWwg6KaB5re75Yqg5Yiw5ZOq5Liq5YWD57Sg5LmL5YmNXG4gKi9cbmZ1bmN0aW9uIG5vZGVPd25Pbmx5Q2hpbGRyZW5BdHRhY2gocGFyZW50RWwsIGJlZm9yZUVsKSB7XG4gICAgdGhpcy5zZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xuICAgIGluc2VydEJlZm9yZSh0aGlzLnNlbCwgcGFyZW50RWwsIGJlZm9yZUVsKTtcblxuICAgIGdlbkVsZW1lbnRDaGlsZHJlbih0aGlzLCBwYXJlbnRFbCwgYmVmb3JlRWwpO1xuXG4gICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy5pZCk7XG4gICAgaW5zZXJ0QmVmb3JlKHRoaXMuZWwsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG5cbiAgICB0aGlzLl90b1BoYXNlKCdhdHRhY2hlZCcpO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBub2RlT3duT25seUNoaWxkcmVuQXR0YWNoO1xuXG5cbi8qKlxuICogQGZpbGUgc2xvdCDoioLngrnnsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG4vLyB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4uL3V0aWwvZ3VpZCcpO1xuLy8gdmFyIGNyZWF0ZUFOb2RlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2NyZWF0ZS1hLW5vZGUnKTtcbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9leHByLXR5cGUnKTtcbi8vIHZhciBjcmVhdGVBY2Nlc3NvciA9IHJlcXVpcmUoJy4uL3BhcnNlci9jcmVhdGUtYWNjZXNzb3InKTtcbi8vIHZhciBldmFsRXhwciA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZXZhbC1leHByJyk7XG4vLyB2YXIgRGF0YSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZGF0YScpO1xuLy8gdmFyIERhdGFDaGFuZ2VUeXBlID0gcmVxdWlyZSgnLi4vcnVudGltZS9kYXRhLWNoYW5nZS10eXBlJyk7XG4vLyB2YXIgY2hhbmdlRXhwckNvbXBhcmUgPSByZXF1aXJlKCcuLi9ydW50aW1lL2NoYW5nZS1leHByLWNvbXBhcmUnKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgTGlmZUN5Y2xlID0gcmVxdWlyZSgnLi9saWZlLWN5Y2xlJyk7XG4vLyB2YXIgZ2V0QU5vZGVQcm9wID0gcmVxdWlyZSgnLi9nZXQtYS1ub2RlLXByb3AnKTtcbi8vIHZhciBub2RlRGlzcG9zZSA9IHJlcXVpcmUoJy4vbm9kZS1kaXNwb3NlJyk7XG4vLyB2YXIgbm9kZVNCaW5kSW5pdCA9IHJlcXVpcmUoJy4vbm9kZS1zLWJpbmQtaW5pdCcpO1xuLy8gdmFyIG5vZGVTQmluZFVwZGF0ZSA9IHJlcXVpcmUoJy4vbm9kZS1zLWJpbmQtdXBkYXRlJyk7XG4vLyB2YXIgY3JlYXRlUmV2ZXJzZU5vZGUgPSByZXF1aXJlKCcuL2NyZWF0ZS1yZXZlcnNlLW5vZGUnKTtcbi8vIHZhciBlbGVtZW50RGlzcG9zZUNoaWxkcmVuID0gcmVxdWlyZSgnLi9lbGVtZW50LWRpc3Bvc2UtY2hpbGRyZW4nKTtcbi8vIHZhciBlbGVtZW50VXBkYXRlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtdXBkYXRlLWNoaWxkcmVuJyk7XG4vLyB2YXIgZWxlbWVudE93blRvUGhhc2UgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLXRvLXBoYXNlJyk7XG4vLyB2YXIgbm9kZU93bk9ubHlDaGlsZHJlbkF0dGFjaCA9IHJlcXVpcmUoJy4vbm9kZS1vd24tb25seS1jaGlsZHJlbi1hdHRhY2gnKTtcblxuXG4vKipcbiAqIHNsb3Qg6IqC54K557G7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHBhcmFtIHtNb2RlbD19IHNjb3BlIOaJgOWxnuaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge0RPTUNoaWxkcmVuV2Fsa2VyP30gcmV2ZXJzZVdhbGtlciDlrZDlhYPntKDpgY3ljoblr7nosaFcbiAqL1xuZnVuY3Rpb24gU2xvdE5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50LCByZXZlcnNlV2Fsa2VyKSB7XG4gICAgdmFyIHJlYWxBTm9kZSA9IGNyZWF0ZUFOb2RlKCk7XG4gICAgdGhpcy5hTm9kZSA9IHJlYWxBTm9kZTtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucGFyZW50Q29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgID8gcGFyZW50XG4gICAgICAgIDogcGFyZW50LnBhcmVudENvbXBvbmVudDtcblxuICAgIHRoaXMuaWQgPSBndWlkKCk7XG5cbiAgICB0aGlzLmxpZmVDeWNsZSA9IExpZmVDeWNsZS5zdGFydDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICAvLyBjYWxjIHNsb3QgbmFtZVxuICAgIHRoaXMubmFtZUJpbmQgPSBnZXRBTm9kZVByb3AoYU5vZGUsICduYW1lJyk7XG4gICAgaWYgKHRoaXMubmFtZUJpbmQpIHtcbiAgICAgICAgdGhpcy5pc05hbWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXZhbEV4cHIodGhpcy5uYW1lQmluZC5leHByLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKTtcbiAgICB9XG5cbiAgICAvLyBjYWxjIGFOb2RlIGNoaWxkcmVuXG4gICAgdmFyIGdpdmVuU2xvdHMgPSBvd25lci5naXZlblNsb3RzO1xuICAgIHZhciBnaXZlbkNoaWxkcmVuO1xuICAgIGlmIChnaXZlblNsb3RzKSB7XG4gICAgICAgIGdpdmVuQ2hpbGRyZW4gPSB0aGlzLmlzTmFtZWQgPyBnaXZlblNsb3RzLm5hbWVkW3RoaXMubmFtZV0gOiBnaXZlblNsb3RzLm5vbmFtZTtcbiAgICB9XG5cbiAgICBpZiAoZ2l2ZW5DaGlsZHJlbikge1xuICAgICAgICB0aGlzLmlzSW5zZXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlYWxBTm9kZS5jaGlsZHJlbiA9IGdpdmVuQ2hpbGRyZW4gfHwgYU5vZGUuY2hpbGRyZW4uc2xpY2UoMCk7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgLy8gY2FsYyBzY29wZWQgc2xvdCB2YXJzXG4gICAgcmVhbEFOb2RlLnZhcnMgPSBhTm9kZS52YXJzO1xuICAgIHJlYWxBTm9kZS5kaXJlY3RpdmVzID0gYU5vZGUuZGlyZWN0aXZlcztcblxuICAgIHZhciBpbml0RGF0YTtcbiAgICBpZiAobm9kZVNCaW5kSW5pdCh0aGlzLCBhTm9kZS5kaXJlY3RpdmVzLmJpbmQpKSB7XG4gICAgICAgIGluaXREYXRhID0gZXh0ZW5kKHt9LCBtZS5fc2JpbmREYXRhKTtcbiAgICB9XG5cbiAgICBpZiAocmVhbEFOb2RlLnZhcnMpIHtcbiAgICAgICAgaW5pdERhdGEgPSBpbml0RGF0YSB8fCB7fTtcbiAgICAgICAgZWFjaChyZWFsQU5vZGUudmFycywgZnVuY3Rpb24gKHZhckl0ZW0pIHtcbiAgICAgICAgICAgIGluaXREYXRhW3Zhckl0ZW0ubmFtZV0gPSBldmFsRXhwcih2YXJJdGVtLmV4cHIsIHNjb3BlLCBvd25lcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNoaWxkIG93bmVyICYgY2hpbGQgc2NvcGVcbiAgICBpZiAodGhpcy5pc0luc2VydGVkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRPd25lciA9IG93bmVyLm93bmVyO1xuICAgICAgICB0aGlzLmNoaWxkU2NvcGUgPSBvd25lci5zY29wZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdERhdGEpIHtcbiAgICAgICAgdGhpcy5pc1Njb3BlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hpbGRTY29wZSA9IG5ldyBEYXRhKGluaXREYXRhLCB0aGlzLmNoaWxkU2NvcGUgfHwgdGhpcy5zY29wZSk7XG4gICAgfVxuXG5cbiAgICBvd25lci5zbG90Q2hpbGRyZW4ucHVzaCh0aGlzKTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuXG4gICAgICAgIHRoaXMuc2VsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLmlkKTtcbiAgICAgICAgaW5zZXJ0QmVmb3JlKHRoaXMuc2VsLCByZXZlcnNlV2Fsa2VyLnRhcmdldCwgcmV2ZXJzZVdhbGtlci5jdXJyZW50KTtcblxuICAgICAgICBlYWNoKHRoaXMuYU5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChhTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICBtZS5jaGlsZHJlbi5wdXNoKGNyZWF0ZVJldmVyc2VOb2RlKGFOb2RlQ2hpbGQsIHJldmVyc2VXYWxrZXIsIG1lKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xuICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcmV2ZXJzZVdhbGtlci50YXJnZXQsIHJldmVyc2VXYWxrZXIuY3VycmVudCk7XG5cbiAgICAgICAgdGhpcy5fdG9QaGFzZSgnYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cblNsb3ROb2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5vZGVUeXBlLlNMT1Q7XG5cbi8qKlxuICog6ZSA5q+B6YeK5pS+IHNsb3RcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub0RldGFjaCDmmK/lkKbkuI3opoHmioroioLngrnku45kb23np7vpmaRcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVHJhbnNpdGlvbiDmmK/lkKbkuI3mmL7npLrov4fmuKHliqjnlLvmlYjmnpxcbiAqL1xuU2xvdE5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAobm9EZXRhY2gsIG5vVHJhbnNpdGlvbikge1xuICAgIHRoaXMuY2hpbGRPd25lciA9IG51bGw7XG4gICAgdGhpcy5jaGlsZFNjb3BlID0gbnVsbDtcblxuICAgIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4odGhpcywgbm9EZXRhY2gsIG5vVHJhbnNpdGlvbik7XG4gICAgbm9kZURpc3Bvc2UodGhpcyk7XG59O1xuXG5TbG90Tm9kZS5wcm90b3R5cGUuYXR0YWNoID0gbm9kZU93bk9ubHlDaGlsZHJlbkF0dGFjaDtcblNsb3ROb2RlLnByb3RvdHlwZS5fdG9QaGFzZSA9IGVsZW1lbnRPd25Ub1BoYXNlO1xuXG4vKipcbiAqIOinhuWbvuabtOaWsOWHveaVsFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMg5pWw5o2u5Y+Y5YyW5L+h5oGvXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0Zyb21PdXRlciDlj5jljJbkv6Hmga/mmK/lkKbmnaXmupDkuo7niLbnu4Tku7bkuYvlpJbnmoTnu4Tku7ZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblNsb3ROb2RlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMsIGlzRnJvbU91dGVyKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGlmICh0aGlzLm5hbWVCaW5kICYmIGV2YWxFeHByKHRoaXMubmFtZUJpbmQuZXhwciwgdGhpcy5zY29wZSwgdGhpcy5vd25lcikgIT09IG1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5vd25lci5fbm90aWZ5TmVlZFJlbG9hZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRnJvbU91dGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRVcGRhdGVDaGlsZHJlbih0aGlzLCBjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTY29wZWQpIHtcbiAgICAgICAgICAgIHZhciB2YXJLZXlzID0ge307XG4gICAgICAgICAgICBlYWNoKHRoaXMuYU5vZGUudmFycywgZnVuY3Rpb24gKHZhckl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXJLZXlzW3Zhckl0ZW0ubmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkU2NvcGUuc2V0KHZhckl0ZW0ubmFtZSwgZXZhbEV4cHIodmFySXRlbS5leHByLCBtZS5zY29wZSwgbWUub3duZXIpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2NvcGVkQ2hhbmdlcyA9IFtdO1xuXG4gICAgICAgICAgICBub2RlU0JpbmRVcGRhdGUoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICB0aGlzLmFOb2RlLmRpcmVjdGl2ZXMuYmluZCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFyS2V5c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuY2hpbGRTY29wZS5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZWRDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRGF0YUNoYW5nZVR5cGUuU0VULFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcjogY3JlYXRlQWNjZXNzb3IoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogRXhwclR5cGUuU1RSSU5HLCB2YWx1ZTogbmFtZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbjoge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZWFjaChjaGFuZ2VzLCBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS5pc0luc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlZENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVhY2gobWUuYU5vZGUudmFycywgZnVuY3Rpb24gKHZhckl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB2YXJJdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZS5leHByLCB2YXJJdGVtLmV4cHIsIG1lLnNjb3BlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpb24gPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IERhdGFDaGFuZ2VUeXBlLlNQTElDRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVkQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRhQ2hhbmdlVHlwZS5TRVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcjogY3JlYXRlQWNjZXNzb3IoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogRXhwclR5cGUuU1RSSU5HLCB2YWx1ZTogbmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWUuY2hpbGRTY29wZS5nZXQobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBjaGFuZ2Uub3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWxhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVkQ2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByOiBjcmVhdGVBY2Nlc3NvcihbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiBFeHByVHlwZS5TVFJJTkcsIHZhbHVlOiBuYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNQTElDRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY2hhbmdlLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUNvdW50OiBjaGFuZ2UuZGVsZXRlQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25zOiBjaGFuZ2UuaW5zZXJ0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IGNoYW5nZS5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZWxlbWVudFVwZGF0ZUNoaWxkcmVuKHRoaXMsIHNjb3BlZENoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmlzSW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRVcGRhdGVDaGlsZHJlbih0aGlzLCBjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNsb3ROb2RlO1xuXG5cbi8qKlxuICogQGZpbGUg5aSN5Yi25oyH5Luk6ZuG5ZCI5a+56LGhXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOWkjeWItuaMh+S7pOmbhuWQiOWvueixoVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2Ug6KaB5aSN5Yi255qE5oyH5Luk6ZuG5ZCI5a+56LGhXG4gKiBAcGFyYW0ge09iamVjdD19IGV4Y2x1ZGVzIOmcgOimgeaOkumZpOeahGtleembhuWQiFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjbG9uZURpcmVjdGl2ZXMoc291cmNlLCBleGNsdWRlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBleGNsdWRlcyA9IGV4Y2x1ZGVzIHx8IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVzW2tleV0pIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjbG9uZURpcmVjdGl2ZXM7XG5cblxuLyoqXG4gKiBAZmlsZSDnroDljZXmiafooYzplIDmr4HoioLngrnnmoTooYzkuLpcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciByZW1vdmVFbCA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcmVtb3ZlLWVsJyk7XG4vLyB2YXIgbm9kZURpc3Bvc2UgPSByZXF1aXJlKCcuL25vZGUtZGlzcG9zZScpO1xuLy8gdmFyIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtZGlzcG9zZS1jaGlsZHJlbicpO1xuXG4vKipcbiAqIOeugOWNleaJp+ihjOmUgOavgeiKgueCueeahOihjOS4ulxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vRGV0YWNoIOaYr+WQpuS4jeimgeaKiuiKgueCueS7jmRvbeenu+mZpFxuICovXG5mdW5jdGlvbiBub2RlT3duU2ltcGxlRGlzcG9zZShub0RldGFjaCkge1xuICAgIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4odGhpcywgbm9EZXRhY2gsIDEpO1xuXG4gICAgaWYgKCFub0RldGFjaCkge1xuICAgICAgICByZW1vdmVFbCh0aGlzLmVsKTtcbiAgICB9XG5cbiAgICBub2RlRGlzcG9zZSh0aGlzKTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbm9kZU93blNpbXBsZURpc3Bvc2U7XG5cblxuLyoqXG4gKiBAZmlsZSDliJvlu7roioLngrnlr7nlupTnmoQgc3R1bXAgY29tbWVudCDlhYPntKBcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuXG4vKipcbiAqIOWIm+W7uuiKgueCueWvueW6lOeahCBzdHVtcCBjb21tZW50IOS4u+WFg+e0oFxuICovXG5mdW5jdGlvbiBub2RlT3duQ3JlYXRlU3R1bXAoKSB7XG4gICAgdGhpcy5lbCA9IHRoaXMuZWwgfHwgZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLmlkKTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbm9kZU93bkNyZWF0ZVN0dW1wO1xuXG5cbi8qKlxuICogQGZpbGUgZm9yIOaMh+S7pOiKgueCueexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcbi8vIHZhciBndWlkID0gcmVxdWlyZSgnLi4vdXRpbC9ndWlkJyk7XG4vLyB2YXIgY3JlYXRlQU5vZGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvY3JlYXRlLWEtbm9kZScpO1xuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gdmFyIHBhcnNlRXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlci9wYXJzZS1leHByJyk7XG4vLyB2YXIgY3JlYXRlQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9wYXJzZXIvY3JlYXRlLWFjY2Vzc29yJyk7XG4vLyB2YXIgY2xvbmVEaXJlY3RpdmVzID0gcmVxdWlyZSgnLi4vcGFyc2VyL2Nsb25lLWRpcmVjdGl2ZXMnKTtcbi8vIHZhciBEYXRhID0gcmVxdWlyZSgnLi4vcnVudGltZS9kYXRhJyk7XG4vLyB2YXIgRGF0YUNoYW5nZVR5cGUgPSByZXF1aXJlKCcuLi9ydW50aW1lL2RhdGEtY2hhbmdlLXR5cGUnKTtcbi8vIHZhciBjaGFuZ2VFeHByQ29tcGFyZSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY2hhbmdlLWV4cHItY29tcGFyZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBjaGFuZ2VzSXNJbkRhdGFSZWYgPSByZXF1aXJlKCcuLi9ydW50aW1lL2NoYW5nZXMtaXMtaW4tZGF0YS1yZWYnKTtcbi8vIHZhciByZW1vdmVFbCA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcmVtb3ZlLWVsJyk7XG4vLyB2YXIgaW5zZXJ0QmVmb3JlID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9pbnNlcnQtYmVmb3JlJyk7XG4vLyB2YXIgTGlmZUN5Y2xlID0gcmVxdWlyZSgnLi9saWZlLWN5Y2xlJyk7XG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuLy8gdmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuL2NyZWF0ZS1ub2RlJyk7XG4vLyB2YXIgY3JlYXRlUmV2ZXJzZU5vZGUgPSByZXF1aXJlKCcuL2NyZWF0ZS1yZXZlcnNlLW5vZGUnKTtcbi8vIHZhciBub2RlT3duU2ltcGxlRGlzcG9zZSA9IHJlcXVpcmUoJy4vbm9kZS1vd24tc2ltcGxlLWRpc3Bvc2UnKTtcbi8vIHZhciBub2RlT3duQ3JlYXRlU3R1bXAgPSByZXF1aXJlKCcuL25vZGUtb3duLWNyZWF0ZS1zdHVtcCcpO1xuLy8gdmFyIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtZGlzcG9zZS1jaGlsZHJlbicpO1xuLy8gdmFyIGRhdGFDYWNoZSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZGF0YS1jYWNoZScpO1xuXG5cbi8qKlxuICog5b6q546v6aG555qE5pWw5o2u5a655Zmo57G7XG4gKlxuICogQGlubmVyXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3JFbGVtZW50IGZvcuWFg+e0oOWvueixoVxuICogQHBhcmFtIHsqfSBpdGVtIOW9k+WJjemhueeahOaVsOaNrlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOW9k+WJjemhueeahOe0ouW8lVxuICovXG5mdW5jdGlvbiBGb3JJdGVtRGF0YShmb3JFbGVtZW50LCBpdGVtLCBpbmRleCkge1xuICAgIHRoaXMuaWQgPSBndWlkKCk7XG4gICAgdGhpcy5wYXJlbnQgPSBmb3JFbGVtZW50LnNjb3BlO1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcblxuICAgIHRoaXMuZGlyZWN0aXZlID0gZm9yRWxlbWVudC5hTm9kZS5kaXJlY3RpdmVzWydmb3InXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICB0aGlzLnJhd1t0aGlzLmRpcmVjdGl2ZS5pdGVtLnJhd10gPSBpdGVtO1xuICAgIHRoaXMucmF3W3RoaXMuZGlyZWN0aXZlLmluZGV4LnJhd10gPSBpbmRleDtcbn1cblxuLyoqXG4gKiDlsIbmlbDmja7mk43kvZznmoTooajovr7lvI/vvIzovazmjaLmiJDkuLrlr7lwYXJlbnTmlbDmja7mk43kvZznmoTooajovr7lvI9cbiAqIOS4u+imgeaYr+WvuWl0ZW3lkoxpbmRleOi/m+ihjOWkhOeQhlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHByIOihqOi+vuW8j1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Gb3JJdGVtRGF0YS5wcm90b3R5cGUuZXhwclJlc29sdmUgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgIHZhciBkaXJlY3RpdmUgPSB0aGlzLmRpcmVjdGl2ZTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUl0ZW0oZXhwcikge1xuICAgICAgICBpZiAoZXhwci50eXBlID09PSBFeHByVHlwZS5BQ0NFU1NPUlxuICAgICAgICAgICAgJiYgZXhwci5wYXRoc1swXS52YWx1ZSA9PT0gZGlyZWN0aXZlLml0ZW0ucGF0aHNbMF0udmFsdWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQWNjZXNzb3IoXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLnZhbHVlLnBhdGhzLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuTlVNQkVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lLmdldChkaXJlY3RpdmUuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4cHIucGF0aHMuc2xpY2UoMSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZXhwciA9IHJlc29sdmVJdGVtKGV4cHIpO1xuXG4gICAgdmFyIHJlc29sdmVkUGF0aHMgPSBbXTtcblxuICAgIGVhY2goZXhwci5wYXRocywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmVzb2x2ZWRQYXRocy5wdXNoKFxuICAgICAgICAgICAgaXRlbS50eXBlID09PSBFeHByVHlwZS5BQ0NFU1NPUlxuICAgICAgICAgICAgICAgICYmIGl0ZW0ucGF0aHNbMF0udmFsdWUgPT09IGRpcmVjdGl2ZS5pbmRleC5wYXRoc1swXS52YWx1ZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuTlVNQkVSLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5nZXQoZGlyZWN0aXZlLmluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiByZXNvbHZlSXRlbShpdGVtKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUFjY2Vzc29yKHJlc29sdmVkUGF0aHMpO1xufTtcblxuLy8g5Luj55CG5pWw5o2u5pON5L2c5pa55rOVXG5pbmhlcml0cyhGb3JJdGVtRGF0YSwgRGF0YSk7XG5lYWNoKFxuICAgIFsnc2V0JywgJ3JlbW92ZScsICd1bnNoaWZ0JywgJ3NoaWZ0JywgJ3B1c2gnLCAncG9wJywgJ3NwbGljZSddLFxuICAgIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgRm9ySXRlbURhdGEucHJvdG90eXBlWydfJyArIG1ldGhvZF0gPSBEYXRhLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICBGb3JJdGVtRGF0YS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICBleHByID0gdGhpcy5leHByUmVzb2x2ZShwYXJzZUV4cHIoZXhwcikpO1xuICAgICAgICAgICAgZGF0YUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFttZXRob2RdLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LFxuICAgICAgICAgICAgICAgIFtleHByXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuKTtcblxuLyoqXG4gKiDliJvlu7ogZm9yIOaMh+S7pOWFg+e0oOeahOWtkOWFg+e0oFxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtGb3JEaXJlY3RpdmV9IGZvckVsZW1lbnQgZm9yIOaMh+S7pOWFg+e0oOWvueixoVxuICogQHBhcmFtIHsqfSBpdGVtIOWtkOWFg+e0oOWvueW6lOaVsOaNrlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOWtkOWFg+e0oOWvueW6lOW6j+WPt1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm9yRGlyZWN0aXZlQ2hpbGQoZm9yRWxlbWVudCwgaXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgaXRlbVNjb3BlID0gbmV3IEZvckl0ZW1EYXRhKGZvckVsZW1lbnQsIGl0ZW0sIGluZGV4KTtcbiAgICByZXR1cm4gY3JlYXRlTm9kZShmb3JFbGVtZW50Lml0ZW1BTm9kZSwgZm9yRWxlbWVudCwgaXRlbVNjb3BlKTtcbn1cblxuLyoqXG4gKiBmb3Ig5oyH5Luk6IqC54K557G7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHBhcmFtIHtNb2RlbD19IHNjb3BlIOaJgOWxnuaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge0RPTUNoaWxkcmVuV2Fsa2VyP30gcmV2ZXJzZVdhbGtlciDlrZDlhYPntKDpgY3ljoblr7nosaFcbiAqL1xuZnVuY3Rpb24gRm9yTm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB0aGlzLmFOb2RlID0gYU5vZGU7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnBhcmVudENvbXBvbmVudCA9IHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ01QVFxuICAgICAgICA/IHBhcmVudFxuICAgICAgICA6IHBhcmVudC5wYXJlbnRDb21wb25lbnQ7XG5cbiAgICB0aGlzLmlkID0gZ3VpZCgpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuaXRlbUFOb2RlID0gY3JlYXRlQU5vZGUoe1xuICAgICAgICBjaGlsZHJlbjogYU5vZGUuY2hpbGRyZW4sXG4gICAgICAgIHByb3BzOiBhTm9kZS5wcm9wcyxcbiAgICAgICAgZXZlbnRzOiBhTm9kZS5ldmVudHMsXG4gICAgICAgIHRhZ05hbWU6IGFOb2RlLnRhZ05hbWUsXG4gICAgICAgIHZhcnM6IGFOb2RlLnZhcnMsXG4gICAgICAgIGhvdHNwb3Q6IGFOb2RlLmhvdHNwb3QsXG4gICAgICAgIGRpcmVjdGl2ZXM6IGNsb25lRGlyZWN0aXZlcyhhTm9kZS5kaXJlY3RpdmVzLCB7XG4gICAgICAgICAgICAnZm9yJzogMVxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJhbSA9IGFOb2RlLmRpcmVjdGl2ZXNbJ2ZvciddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuXG4gICAgLy8gI1tiZWdpbl0gcmV2ZXJzZVxuICAgIGlmIChyZXZlcnNlV2Fsa2VyKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHRoaXMubGlzdERhdGEgPSBldmFsRXhwcih0aGlzLnBhcmFtLnZhbHVlLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKSB8fCBbXTtcbiAgICAgICAgZWFjaChcbiAgICAgICAgICAgIHRoaXMubGlzdERhdGEsXG4gICAgICAgICAgICBmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtU2NvcGUgPSBuZXcgRm9ySXRlbURhdGEobWUsIGl0ZW0sIGkpO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNyZWF0ZVJldmVyc2VOb2RlKG1lLml0ZW1BTm9kZSwgcmV2ZXJzZVdhbGtlciwgbWUsIGl0ZW1TY29wZSk7XG4gICAgICAgICAgICAgICAgbWUuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgICAgIGluc2VydEJlZm9yZSh0aGlzLmVsLCByZXZlcnNlV2Fsa2VyLnRhcmdldCwgcmV2ZXJzZVdhbGtlci5jdXJyZW50KTtcbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cblxuRm9yTm9kZS5wcm90b3R5cGUubm9kZVR5cGUgPSBOb2RlVHlwZS5GT1I7XG5Gb3JOb2RlLnByb3RvdHlwZS5fY3JlYXRlID0gbm9kZU93bkNyZWF0ZVN0dW1wO1xuRm9yTm9kZS5wcm90b3R5cGUuZGlzcG9zZSA9IG5vZGVPd25TaW1wbGVEaXNwb3NlO1xuXG4vKipcbiAqIOWwhuWFg+e0oGF0dGFjaOWIsOmhtemdoueahOihjOS4ulxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudEVsIOimgea3u+WKoOWIsOeahOeItuWFg+e0oFxuICogQHBhcmFtIHtIVE1MRWxlbWVudO+8nX0gYmVmb3JlRWwg6KaB5re75Yqg5Yiw5ZOq5Liq5YWD57Sg5LmL5YmNXG4gKi9cbkZvck5vZGUucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChwYXJlbnRFbCwgYmVmb3JlRWwpIHtcbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcGFyZW50RWwsIGJlZm9yZUVsKTtcblxuICAgIC8vIHBhaW50IGxpc3RcbiAgICB2YXIgZWwgPSB0aGlzLmVsIHx8IHBhcmVudEVsLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxpc3REYXRhID0gZXZhbEV4cHIodGhpcy5wYXJhbS52YWx1ZSwgdGhpcy5zY29wZSwgdGhpcy5vd25lcikgfHwgW107XG4gICAgdmFyIGxlbiA9IGxpc3REYXRhLmxlbmd0aDtcblxuICAgIHRoaXMubGlzdERhdGEgPSBsaXN0RGF0YTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZvckRpcmVjdGl2ZUNoaWxkKHRoaXMsIGxpc3REYXRhW2ldLCBpKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgY2hpbGQuYXR0YWNoKHBhcmVudEVsLCBlbCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDlsIblhYPntKDku47pobXpnaLkuIrnp7vpmaTnmoTooYzkuLpcbiAqL1xuRm9yTm9kZS5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmxpZmVDeWNsZS5hdHRhY2hlZCkge1xuICAgICAgICBlbGVtZW50RGlzcG9zZUNoaWxkcmVuKHRoaXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHJlbW92ZUVsKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLmxpZmVDeWNsZSA9IExpZmVDeWNsZS5kZXRhY2hlZDtcbiAgICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmZWNzLW1heC1zdGF0ZW1lbnRzICovXG5cbi8qKlxuICog6KeG5Zu+5pu05paw5Ye95pWwXG4gKlxuICogQHBhcmFtIHtBcnJheX0gY2hhbmdlcyDmlbDmja7lj5jljJbkv6Hmga9cbiAqL1xuRm9yTm9kZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIC8vIOaOp+WItuWIl+ihqOabtOaWsOetlueVpeaYr+WQpuWOn+agt+abtOaWsOeahOWPmOmHj1xuICAgIHZhciBvcmlnaW5hbFVwZGF0ZSA9IHRoaXMuYU5vZGUuZGlyZWN0aXZlcy50cmFuc2l0aW9uO1xuXG5cbiAgICB2YXIgb2xkQ2hpbGRyZW5MZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgY2hpbGRyZW5DaGFuZ2VzID0gbmV3IEFycmF5KG9sZENoaWxkcmVuTGVuKTtcblxuICAgIGZ1bmN0aW9uIHB1c2hUb0NoaWxkcmVuQ2hhbmdlcyhjaGFuZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbkNoYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAoY2hpbGRyZW5DaGFuZ2VzW2ldID0gY2hpbGRyZW5DaGFuZ2VzW2ldIHx8IFtdKS5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlzcG9zZUNoaWxkcmVuID0gW107XG5cblxuICAgIC8vIOWIpOaWreWIl+ihqOaYr+WQpueItuWFg+e0oOS4i+WUr+S4gOeahOWFg+e0oFxuICAgIC8vIOWmguaenOaYr+eahOivne+8jOWPr+S7peWBmuS4gOS6m+abtOaWsOS8mOWMllxuICAgIHZhciBwYXJlbnRFbCA9IHRoaXMuZWwucGFyZW50Tm9kZTtcbiAgICB2YXIgcGFyZW50Rmlyc3RDaGlsZCA9IHBhcmVudEVsLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHBhcmVudExhc3RDaGlsZCA9IHBhcmVudEVsLmxhc3RDaGlsZDtcbiAgICB2YXIgaXNPbmx5UGFyZW50Q2hpbGQgPSBvbGRDaGlsZHJlbkxlbiA+IDAgLy8g5pyJ5a2p5a2Q5pe2XG4gICAgICAgICAgICAmJiBwYXJlbnRGaXJzdENoaWxkID09PSB0aGlzLmNoaWxkcmVuWzBdLmVsXG4gICAgICAgICAgICAmJiAocGFyZW50TGFzdENoaWxkID09PSB0aGlzLmVsIHx8IHBhcmVudExhc3RDaGlsZCA9PT0gdGhpcy5jaGlsZHJlbltvbGRDaGlsZHJlbkxlbiAtIDFdLmVsKVxuICAgICAgICB8fCBvbGRDaGlsZHJlbkxlbiA9PT0gMCAvLyDml6DlranlrZDml7ZcbiAgICAgICAgICAgICYmIHBhcmVudEZpcnN0Q2hpbGQgPT09IHRoaXMuZWxcbiAgICAgICAgICAgICYmIHBhcmVudExhc3RDaGlsZCA9PT0gdGhpcy5lbDtcblxuICAgIC8vIOaOp+WItuWIl+ihqOaYr+WQpuaVtOS9k+abtOaWsOeahOWPmOmHj1xuICAgIHZhciBpc0NoaWxkcmVuUmVidWlsZDtcblxuICAgIHZhciBuZXdMaXN0ID0gZXZhbEV4cHIodGhpcy5wYXJhbS52YWx1ZSwgdGhpcy5zY29wZSwgdGhpcy5vd25lcikgfHwgW107XG4gICAgdmFyIG5ld0xlbiA9IG5ld0xpc3QubGVuZ3RoO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG4gICAgZm9yICh2YXIgY0luZGV4ID0gMCwgY0xlbiA9IGNoYW5nZXMubGVuZ3RoOyBjSW5kZXggPCBjTGVuOyBjSW5kZXgrKykge1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tjSW5kZXhdO1xuICAgICAgICB2YXIgcmVsYXRpb24gPSBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2UuZXhwciwgdGhpcy5wYXJhbS52YWx1ZSwgdGhpcy5zY29wZSk7XG5cbiAgICAgICAgaWYgKCFyZWxhdGlvbikge1xuICAgICAgICAgICAgLy8g5peg5YWz5pe277yM55u05o6l5Lyg6YCS57uZ5a2Q5YWD57Sg5pu05paw77yM5YiX6KGo5pys6Lqr5LiN6ZyA6KaB5YqoXG4gICAgICAgICAgICBwdXNoVG9DaGlsZHJlbkNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWxhdGlvbiA+IDIpIHtcbiAgICAgICAgICAgIC8vIOWPmOabtOihqOi+vuW8j+aYr2xpc3Tnu5Hlrprooajovr7lvI/nmoTlrZDpoblcbiAgICAgICAgICAgIC8vIOWPqumcgOimgeWvueebuOW6lOeahOWtkOmhuei/m+ihjOabtOaWsFxuICAgICAgICAgICAgdmFyIGNoYW5nZVBhdGhzID0gY2hhbmdlLmV4cHIucGF0aHM7XG4gICAgICAgICAgICB2YXIgZm9yTGVuID0gdGhpcy5wYXJhbS52YWx1ZS5wYXRocy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY2hhbmdlSW5kZXggPSArZXZhbEV4cHIoY2hhbmdlUGF0aHNbZm9yTGVuXSwgdGhpcy5zY29wZSwgdGhpcy5vd25lcik7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihjaGFuZ2VJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBwdXNoVG9DaGlsZHJlbkNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbmdlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cHI6IGNyZWF0ZUFjY2Vzc29yKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbS5pdGVtLnBhdGhzLmNvbmNhdChjaGFuZ2VQYXRocy5zbGljZShmb3JMZW4gKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNoYW5nZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ291bnQ6IGNoYW5nZS5kZWxldGVDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0aW9uczogY2hhbmdlLmluc2VydGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbjogY2hhbmdlLm9wdGlvblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAoY2hpbGRyZW5DaGFuZ2VzW2NoYW5nZUluZGV4XSA9IGNoaWxkcmVuQ2hhbmdlc1tjaGFuZ2VJbmRleF0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5wdXNoKGNoYW5nZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltjaGFuZ2VJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBEYXRhQ2hhbmdlVHlwZS5TUExJQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bY2hhbmdlSW5kZXhdLnNjb3BlLl9zcGxpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW10uY29uY2F0KGNoYW5nZS5pbmRleCwgY2hhbmdlLmRlbGV0ZUNvdW50LCBjaGFuZ2UuaW5zZXJ0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzaWxlbnQ6IDEgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bY2hhbmdlSW5kZXhdLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc2lsZW50OiAxIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgIT09IERhdGFDaGFuZ2VUeXBlLlNQTElDRSkge1xuICAgICAgICAgICAgLy8g5Y+Y5pu06KGo6L6+5byP5pivbGlzdOe7keWumuihqOi+vuW8j+acrOi6q+aIluavjemhueeahOmHjeaWsOiuvuWAvFxuICAgICAgICAgICAgLy8g5q2k5pe26ZyA6KaB5pu05paw5pW05Liq5YiX6KGoXG5cbiAgICAgICAgICAgIHZhciBnZXRJdGVtS2V5ID0gdGhpcy5hTm9kZS5ob3RzcG90LmdldEZvcktleTtcbiAgICAgICAgICAgIGlmIChnZXRJdGVtS2V5ICYmIG5ld0xlbiAmJiBvbGRDaGlsZHJlbkxlbikge1xuICAgICAgICAgICAgICAgIHZhciBsY3NGbGFncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdMaXN0S2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBvbGRMaXN0S2V5cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZWFjaChuZXdMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdMaXN0S2V5cy5wdXNoKGdldEl0ZW1LZXkoaXRlbSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWFjaCh0aGlzLmxpc3REYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRMaXN0S2V5cy5wdXNoKGdldEl0ZW1LZXkoaXRlbSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3SW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEluZGV4O1xuICAgICAgICAgICAgICAgIGZvciAob2xkSW5kZXggPSAwOyBvbGRJbmRleCA8PSBvbGRDaGlsZHJlbkxlbjsgb2xkSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBsY3NGbGFncy5wdXNoKFtdKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKG5ld0luZGV4ID0gMDsgbmV3SW5kZXggPD0gbmV3TGVuOyBuZXdJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGNzRmxhZyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggJiYgb2xkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsY3NGbGFnID0gbmV3TGlzdEtleXNbbmV3SW5kZXggLSAxXSA9PT0gb2xkTGlzdEtleXNbb2xkSW5kZXggLSAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGxjc0ZsYWdzW29sZEluZGV4IC0gMV1bbmV3SW5kZXggLSAxXSArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChsY3NGbGFnc1tvbGRJbmRleCAtIDFdW25ld0luZGV4XSwgbGNzRmxhZ3Nbb2xkSW5kZXhdW25ld0luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsY3NGbGFnc1tvbGRJbmRleF0ucHVzaChsY3NGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld0luZGV4LS07XG4gICAgICAgICAgICAgICAgb2xkSW5kZXgtLTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkSW5kZXggJiYgbmV3SW5kZXggJiYgb2xkTGlzdEtleXNbb2xkSW5kZXggLSAxXSA9PT0gbmV3TGlzdEtleXNbbmV3SW5kZXggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEluZGV4LS07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOaVsOaNruacrOi6q+W8leeUqOWPkeeUn+WPmOWMlu+8jOiuvue9ruWPmOabtFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdERhdGFbb2xkSW5kZXhdICE9PSBuZXdMaXN0W25ld0luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZHJlbkNoYW5nZXNbb2xkSW5kZXhdID0gY2hpbGRyZW5DaGFuZ2VzW29sZEluZGV4XSB8fCBbXSkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNFVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBjaGFuZ2Uub3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByOiBjcmVhdGVBY2Nlc3Nvcih0aGlzLnBhcmFtLml0ZW0ucGF0aHMuc2xpY2UoMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3TGlzdFtuZXdJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5a+5bGlzdOabtOS4iue6p+aVsOaNrueahOebtOaOpeiuvue9rlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZHJlbkNoYW5nZXNbb2xkSW5kZXhdID0gY2hpbGRyZW5DaGFuZ2VzW29sZEluZGV4XSB8fCBbXSkucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld0luZGV4ICYmICghb2xkSW5kZXggfHwgbGNzRmxhZ3Nbb2xkSW5kZXhdW25ld0luZGV4IC0gMV0gPj0gbGNzRmxhZ3Nbb2xkSW5kZXggLSAxXVtuZXdJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzLnNwbGljZShvbGRJbmRleCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShvbGRJbmRleCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSW5kZXggJiYgKCFuZXdJbmRleCB8fCBsY3NGbGFnc1tvbGRJbmRleF1bbmV3SW5kZXggLSAxXSA8IGxjc0ZsYWdzW29sZEluZGV4IC0gMV1bbmV3SW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5bb2xkSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuQ2hhbmdlcy5zcGxpY2Uob2xkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2Uob2xkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyDogIHnmoTmr5TmlrDnmoTlpJrnmoTpg6jliIbvvIzmoIforrDpnIDopoFkaXNwb3NlXG4gICAgICAgICAgICAgICAgaWYgKG9sZENoaWxkcmVuTGVuID4gbmV3TGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VDaGlsZHJlbiA9IGRpc3Bvc2VDaGlsZHJlbi5jb25jYXQodGhpcy5jaGlsZHJlbi5zbGljZShuZXdMZW4pKTtcblxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkNoYW5nZXMgPSBjaGlsZHJlbkNoYW5nZXMuc2xpY2UoMCwgbmV3TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoMCwgbmV3TGVuKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDmlbTpobnlj5jmm7RcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIChjaGlsZHJlbkNoYW5nZXNbaV0gPSBjaGlsZHJlbkNoYW5nZXNbaV0gfHwgW10pLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRGF0YUNoYW5nZVR5cGUuU0VULFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBjaGFuZ2Uub3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcjogY3JlYXRlQWNjZXNzb3IodGhpcy5wYXJhbS5pdGVtLnBhdGhzLnNsaWNlKDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdMaXN0W2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIOWvuWxpc3Tmm7TkuIrnuqfmlbDmja7nmoTnm7TmjqXorr7nva5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzW2ldLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbS5pdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3RbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3NpbGVudDogMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNDaGlsZHJlblJlYnVpbGQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbGF0aW9uID09PSAyICYmIGNoYW5nZS50eXBlID09PSBEYXRhQ2hhbmdlVHlwZS5TUExJQ0UgJiYgIWlzQ2hpbGRyZW5SZWJ1aWxkKSB7XG4gICAgICAgICAgICAvLyDlj5jmm7Tooajovr7lvI/mmK9saXN057uR5a6a6KGo6L6+5byP5pys6Lqr5pWw57uE55qEc3BsaWNl5pON5L2cXG4gICAgICAgICAgICAvLyDmraTml7bpnIDopoHliKDpmaTpg6jliIbpobnvvIzliJvlu7rpg6jliIbpoblcbiAgICAgICAgICAgIHZhciBjaGFuZ2VTdGFydCA9IGNoYW5nZS5pbmRleDtcbiAgICAgICAgICAgIHZhciBkZWxldGVDb3VudCA9IGNoYW5nZS5kZWxldGVDb3VudDtcbiAgICAgICAgICAgIHZhciBpbnNlcnRpb25zTGVuID0gY2hhbmdlLmluc2VydGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG5ld0NvdW50ID0gaW5zZXJ0aW9uc0xlbiAtIGRlbGV0ZUNvdW50O1xuXG4gICAgICAgICAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhDaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNFVCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBjaGFuZ2Uub3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICBleHByOiB0aGlzLnBhcmFtLmluZGV4XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGFuZ2VTdGFydCArIGRlbGV0ZUNvdW50OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAoY2hpbGRyZW5DaGFuZ2VzW2ldID0gY2hpbGRyZW5DaGFuZ2VzW2ldIHx8IFtdKS5wdXNoKGluZGV4Q2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXSAmJiB0aGlzLmNoaWxkcmVuW2ldLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleENoYW5nZS5leHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtIGRlbGV0ZUNvdW50ICsgaW5zZXJ0aW9uc0xlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzaWxlbnQ6IDF9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsZXRlTGVuID0gZGVsZXRlQ291bnQ7XG4gICAgICAgICAgICB3aGlsZSAoZGVsZXRlTGVuLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGVuIDwgaW5zZXJ0aW9uc0xlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGNoYW5nZVN0YXJ0ICsgZGVsZXRlTGVuO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgKGNoaWxkcmVuQ2hhbmdlc1tpXSA9IGNoaWxkcmVuQ2hhbmdlc1tpXSB8fCBbXSkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRhQ2hhbmdlVHlwZS5TRVQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IGNoYW5nZS5vcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByOiBjcmVhdGVBY2Nlc3Nvcih0aGlzLnBhcmFtLml0ZW0ucGF0aHMuc2xpY2UoMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS5pbnNlcnRpb25zW2RlbGV0ZUxlbl1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbS5pdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5pbnNlcnRpb25zW2RlbGV0ZUxlbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3NpbGVudDogMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdDb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlQ2hpbGRyZW4gPSBkaXNwb3NlQ2hpbGRyZW4uY29uY2F0KHRoaXMuY2hpbGRyZW4uc3BsaWNlKGNoYW5nZVN0YXJ0ICsgaW5zZXJ0aW9uc0xlbiwgLW5ld0NvdW50KSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzLnNwbGljZShjaGFuZ2VTdGFydCArIGluc2VydGlvbnNMZW4sIC1uZXdDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BsaWNlQXJncyA9IFtjaGFuZ2VTdGFydCArIGRlbGV0ZUNvdW50LCAwXS5jb25jYXQobmV3IEFycmF5KG5ld0NvdW50KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UuYXBwbHkodGhpcy5jaGlsZHJlbiwgc3BsaWNlQXJncyk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzLnNwbGljZS5hcHBseShjaGlsZHJlbkNoYW5nZXMsIHNwbGljZUFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuTGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAvLyDmoIforrAgbGVuZ3RoIOaYr+WQpuWPkeeUn+WPmOWMllxuICAgIGlmIChuZXdDaGlsZHJlbkxlbiAhPT0gb2xkQ2hpbGRyZW5MZW4gJiYgdGhpcy5wYXJhbS52YWx1ZS5wYXRocykge1xuICAgICAgICB2YXIgbGVuZ3RoQ2hhbmdlID0ge1xuICAgICAgICAgICAgdHlwZTogRGF0YUNoYW5nZVR5cGUuU0VULFxuICAgICAgICAgICAgb3B0aW9uOiB7fSxcbiAgICAgICAgICAgIGV4cHI6IGNyZWF0ZUFjY2Vzc29yKFxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW0udmFsdWUucGF0aHMuY29uY2F0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuU1RSSU5HLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ2xlbmd0aCdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjaGFuZ2VzSXNJbkRhdGFSZWYoW2xlbmd0aENoYW5nZV0sIHRoaXMuYU5vZGUuaG90c3BvdC5kYXRhKSkge1xuICAgICAgICAgICAgcHVzaFRvQ2hpbGRyZW5DaGFuZ2VzKGxlbmd0aENoYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxpc3REYXRhID0gbmV3TGlzdDtcblxuICAgIC8vIOa4hemZpOW6lOivpeW5suaOieeahCBjaGlsZFxuICAgIHRoaXMuX2RvQ3JlYXRlQW5kVXBkYXRlID0gZG9DcmVhdGVBbmRVcGRhdGU7XG5cbiAgICAvLyDov5nph4zkuI3nlKhnZXRUcmFuc2l0aW9u77yMZ2V0VHJhbnNpdGlvbuWSjHNjb3Bl55u45YWz77yMZm9y5ZKMZm9ySXRlbeeahHNjb3Bl5piv5LiN5ZCM55qEXG4gICAgLy8g5omA5LulZ2V0VHJhbnNpdGlvbue7k+aenOacrOi6q+S5n+aYr+S4jeS4gOiHtOeahOOAguS4jeWmguebtOaOpeWIpOaWreaMh+S7pOaYr+WQpuWtmOWcqO+8jOWmguaenOWtmOWcqOWwseS4jei/m+WFpeaatOWKm+a4hemZpOaooeW8j1xuICAgIC8vIHZhciB2aW9sZW50Q2xlYXIgPSBpc09ubHlQYXJlbnRDaGlsZCAmJiBuZXdDaGlsZHJlbkxlbiA9PT0gMCAmJiAhZWxlbWVudEdldFRyYW5zaXRpb24obWUpO1xuICAgIHZhciB2aW9sZW50Q2xlYXIgPSAhb3JpZ2luYWxVcGRhdGUgJiYgaXNPbmx5UGFyZW50Q2hpbGQgJiYgbmV3Q2hpbGRyZW5MZW4gPT09IDA7XG5cbiAgICB2YXIgZGlzcG9zZWRDaGlsZENvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3Bvc2VDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlzcG9zZUNoaWxkID0gZGlzcG9zZUNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoZGlzcG9zZUNoaWxkKSB7XG4gICAgICAgICAgICBkaXNwb3NlQ2hpbGQuX29uZGlzcG9zZWQgPSBjaGlsZERpc3Bvc2VkO1xuICAgICAgICAgICAgZGlzcG9zZUNoaWxkLmRpc3Bvc2UodmlvbGVudENsZWFyLCB2aW9sZW50Q2xlYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hpbGREaXNwb3NlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpb2xlbnRDbGVhcikge1xuICAgICAgICAvLyBjbG9uZU5vZGUgKyByZXBsYWNlQ2hpbGQgaXMgZmFzdGVyXG4gICAgICAgIC8vIHBhcmVudEVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB2YXIgcmVwbGFjZU5vZGUgPSBwYXJlbnRFbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBwYXJlbnRFbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyZXBsYWNlTm9kZSwgcGFyZW50RWwpO1xuICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLmlkKTtcbiAgICAgICAgcmVwbGFjZU5vZGUuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2VDaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9DcmVhdGVBbmRVcGRhdGUoKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNoaWxkRGlzcG9zZWQoKSB7XG4gICAgICAgIGRpc3Bvc2VkQ2hpbGRDb3VudCsrO1xuICAgICAgICBpZiAoZGlzcG9zZWRDaGlsZENvdW50ID09PSBkaXNwb3NlQ2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgICAmJiBkb0NyZWF0ZUFuZFVwZGF0ZSA9PT0gbWUuX2RvQ3JlYXRlQW5kVXBkYXRlXG4gICAgICAgICkge1xuICAgICAgICAgICAgZG9DcmVhdGVBbmRVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ3JlYXRlQW5kVXBkYXRlKCkge1xuICAgICAgICBtZS5fZG9DcmVhdGVBbmRVcGRhdGUgPSBudWxsO1xuICAgICAgICBpZiAodmlvbGVudENsZWFyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBiZWZvcmVFbCA9IG1lLmVsO1xuXG4gICAgICAgIC8vIOWvueebuOW6lOeahOmhuei/m+ihjOabtOaWsFxuICAgICAgICBpZiAob2xkQ2hpbGRyZW5MZW4gPT09IDAgJiYgaXNPbmx5UGFyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW5MZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkcmVuW2ldID0gY3JlYXRlRm9yRGlyZWN0aXZlQ2hpbGQobWUsIG5ld0xpc3RbaV0sIGkpO1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkcmVuW2ldLmF0dGFjaChwYXJlbnRFbCwgYmVmb3JlRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8g5aaC5p6c5LiNYXR0YWNoZWTliJnnm7TmjqXliJvlu7rvvIzlpoLmnpzlrZjlnKjliJnosIPnlKjmm7TmlrDlh73mlbBcbiAgICAgICAgICAgIHZhciBqID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBtZS5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkNoYW5nZXNbaV0gJiYgY2hpbGQuX3VwZGF0ZShjaGlsZHJlbkNoYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IG5ld0NoaWxkcmVuTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZCA9IG1lLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWwgPSBuZXh0Q2hpbGQuc2VsIHx8IG5leHRDaGlsZC5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1lLmNoaWxkcmVuW2ldID0gY3JlYXRlRm9yRGlyZWN0aXZlQ2hpbGQobWUsIG5ld0xpc3RbaV0sIGkpO1xuICAgICAgICAgICAgICAgICAgICBtZS5jaGlsZHJlbltpXS5hdHRhY2gocGFyZW50RWwsIGJlZm9yZUVsIHx8IG1lLmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZvck5vZGU7XG5cblxuLyoqXG4gKiBAZmlsZSDmuIXmtJfmnaHku7YgYU5vZGVcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGNyZWF0ZUFOb2RlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2NyZWF0ZS1hLW5vZGUnKTtcbi8vIHZhciBjbG9uZURpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9wYXJzZXIvY2xvbmUtZGlyZWN0aXZlcycpO1xuXG5cbi8qKlxuICog5riF5rSX5p2h5Lu2IGFOb2Rl77yM6L+U5Zue57qv5YeA5peg5p2h5Lu25oyH5Luk55qEIGFOb2RlXG4gKlxuICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg5p2h5Lu26IqC54K55a+56LGhXG4gKiBAcmV0dXJuIHtBTm9kZX1cbiAqL1xuZnVuY3Rpb24gcmluc2VDb25kQU5vZGUoYU5vZGUpIHtcbiAgICB2YXIgY2xlYXJBTm9kZSA9IGNyZWF0ZUFOb2RlKHtcbiAgICAgICAgY2hpbGRyZW46IGFOb2RlLmNoaWxkcmVuLFxuICAgICAgICBwcm9wczogYU5vZGUucHJvcHMsXG4gICAgICAgIGV2ZW50czogYU5vZGUuZXZlbnRzLFxuICAgICAgICB0YWdOYW1lOiBhTm9kZS50YWdOYW1lLFxuICAgICAgICB2YXJzOiBhTm9kZS52YXJzLFxuICAgICAgICBob3RzcG90OiBhTm9kZS5ob3RzcG90LFxuICAgICAgICBkaXJlY3RpdmVzOiBjbG9uZURpcmVjdGl2ZXMoYU5vZGUuZGlyZWN0aXZlcywge1xuICAgICAgICAgICAgJ2lmJzogMSxcbiAgICAgICAgICAgICdlbHNlJzogMSxcbiAgICAgICAgICAgICdlbGlmJzogMVxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNsZWFyQU5vZGU7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJpbnNlQ29uZEFOb2RlO1xuXG5cbi8qKlxuICogQGZpbGUgaWYg5oyH5Luk6IqC54K557G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGd1aWQgPSByZXF1aXJlKCcuLi91dGlsL2d1aWQnKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcbi8vIHZhciBldmFsRXhwciA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZXZhbC1leHByJyk7XG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuLy8gdmFyIHJpbnNlQ29uZEFOb2RlID0gcmVxdWlyZSgnLi9yaW5zZS1jb25kLWFub2RlJyk7XG4vLyB2YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLW5vZGUnKTtcbi8vIHZhciBjcmVhdGVSZXZlcnNlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLXJldmVyc2Utbm9kZScpO1xuLy8gdmFyIG5vZGVPd25DcmVhdGVTdHVtcCA9IHJlcXVpcmUoJy4vbm9kZS1vd24tY3JlYXRlLXN0dW1wJyk7XG4vLyB2YXIgZWxlbWVudFVwZGF0ZUNoaWxkcmVuID0gcmVxdWlyZSgnLi9lbGVtZW50LXVwZGF0ZS1jaGlsZHJlbicpO1xuLy8gdmFyIG5vZGVPd25TaW1wbGVEaXNwb3NlID0gcmVxdWlyZSgnLi9ub2RlLW93bi1zaW1wbGUtZGlzcG9zZScpO1xuXG4vKipcbiAqIGlmIOaMh+S7pOiKgueCueexu1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhTm9kZSDmir3osaHoioLngrlcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBvd25lciDmiYDlsZ7nu4Tku7bnjq/looNcbiAqIEBwYXJhbSB7TW9kZWw9fSBzY29wZSDmiYDlsZ7mlbDmja7njq/looNcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50IOeItuS6suiKgueCuVxuICogQHBhcmFtIHtET01DaGlsZHJlbldhbGtlcj99IHJldmVyc2VXYWxrZXIg5a2Q5YWD57Sg6YGN5Y6G5a+56LGhXG4gKi9cbmZ1bmN0aW9uIElmTm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB0aGlzLmFOb2RlID0gYU5vZGU7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnBhcmVudENvbXBvbmVudCA9IHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ01QVFxuICAgICAgICA/IHBhcmVudFxuICAgICAgICA6IHBhcmVudC5wYXJlbnRDb21wb25lbnQ7XG5cbiAgICB0aGlzLmlkID0gZ3VpZCgpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuY29uZCA9IHRoaXMuYU5vZGUuZGlyZWN0aXZlc1snaWYnXS52YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuICAgICAgICBpZiAoZXZhbEV4cHIodGhpcy5jb25kLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKSkge1xuICAgICAgICAgICAgdGhpcy5lbHNlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bMF0gPSBjcmVhdGVSZXZlcnNlTm9kZShcbiAgICAgICAgICAgICAgICByaW5zZUNvbmRBTm9kZShhTm9kZSksXG4gICAgICAgICAgICAgICAgcmV2ZXJzZVdhbGtlcixcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIGVhY2goYU5vZGUuZWxzZXMsIGZ1bmN0aW9uIChlbHNlQU5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsaWYgPSBlbHNlQU5vZGUuZGlyZWN0aXZlcy5lbGlmO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlbGlmIHx8IGVsaWYgJiYgZXZhbEV4cHIoZWxpZi52YWx1ZSwgbWUuc2NvcGUsIG1lLm93bmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5lbHNlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2hpbGRyZW5bMF0gPSBjcmVhdGVSZXZlcnNlTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpbnNlQ29uZEFOb2RlKGVsc2VBTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgICAgIGluc2VydEJlZm9yZSh0aGlzLmVsLCByZXZlcnNlV2Fsa2VyLnRhcmdldCwgcmV2ZXJzZVdhbGtlci5jdXJyZW50KTtcbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cbklmTm9kZS5wcm90b3R5cGUubm9kZVR5cGUgPSBOb2RlVHlwZS5JRjtcblxuSWZOb2RlLnByb3RvdHlwZS5fY3JlYXRlID0gbm9kZU93bkNyZWF0ZVN0dW1wO1xuSWZOb2RlLnByb3RvdHlwZS5kaXNwb3NlID0gbm9kZU93blNpbXBsZURpc3Bvc2U7XG5cbklmTm9kZS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBhcmVudEVsLCBiZWZvcmVFbCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGVsc2VJbmRleDtcbiAgICB2YXIgY2hpbGQ7XG5cbiAgICBpZiAoZXZhbEV4cHIodGhpcy5jb25kLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKSkge1xuICAgICAgICBjaGlsZCA9IGNyZWF0ZU5vZGUocmluc2VDb25kQU5vZGUobWUuYU5vZGUpLCBtZSk7XG4gICAgICAgIGVsc2VJbmRleCA9IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWFjaChtZS5hTm9kZS5lbHNlcywgZnVuY3Rpb24gKGVsc2VBTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBlbGlmID0gZWxzZUFOb2RlLmRpcmVjdGl2ZXMuZWxpZjtcblxuICAgICAgICAgICAgaWYgKCFlbGlmIHx8IGVsaWYgJiYgZXZhbEV4cHIoZWxpZi52YWx1ZSwgbWUuc2NvcGUsIG1lLm93bmVyKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY3JlYXRlTm9kZShyaW5zZUNvbmRBTm9kZShlbHNlQU5vZGUpLCBtZSk7XG4gICAgICAgICAgICAgICAgZWxzZUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgbWUuY2hpbGRyZW5bMF0gPSBjaGlsZDtcbiAgICAgICAgY2hpbGQuYXR0YWNoKHBhcmVudEVsLCBiZWZvcmVFbCk7XG4gICAgICAgIG1lLmVsc2VJbmRleCA9IGVsc2VJbmRleDtcbiAgICB9XG5cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIGluc2VydEJlZm9yZSh0aGlzLmVsLCBwYXJlbnRFbCwgYmVmb3JlRWwpO1xufTtcblxuXG4vKipcbiAqIOinhuWbvuabtOaWsOWHveaVsFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMg5pWw5o2u5Y+Y5YyW5L+h5oGvXG4gKi9cbklmTm9kZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgY2hpbGRBTm9kZSA9IG1lLmFOb2RlO1xuICAgIHZhciBlbHNlSW5kZXg7XG5cbiAgICBpZiAoZXZhbEV4cHIodGhpcy5jb25kLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKSkge1xuICAgICAgICBlbHNlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVhY2gobWUuYU5vZGUuZWxzZXMsIGZ1bmN0aW9uIChlbHNlQU5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZWxpZiA9IGVsc2VBTm9kZS5kaXJlY3RpdmVzLmVsaWY7XG5cbiAgICAgICAgICAgIGlmIChlbGlmICYmIGV2YWxFeHByKGVsaWYudmFsdWUsIG1lLnNjb3BlLCBtZS5vd25lcikgfHwgIWVsaWYpIHtcbiAgICAgICAgICAgICAgICBlbHNlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjaGlsZEFOb2RlID0gZWxzZUFOb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGVsc2VJbmRleCA9PT0gbWUuZWxzZUluZGV4KSB7XG4gICAgICAgIGVsZW1lbnRVcGRhdGVDaGlsZHJlbihtZSwgY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQgPSBtZS5jaGlsZHJlblswXTtcbiAgICAgICAgbWUuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5fb25kaXNwb3NlZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3Q2hpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmVsc2VJbmRleCA9IGVsc2VJbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXdDaGlsZCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbHNlSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjcmVhdGVOb2RlKHJpbnNlQ29uZEFOb2RlKGNoaWxkQU5vZGUpLCBtZSk7XG4gICAgICAgICAgICAvLyB2YXIgcGFyZW50RWwgPSBnZXROb2RlU3R1bXBQYXJlbnQobWUpO1xuICAgICAgICAgICAgY2hpbGQuYXR0YWNoKG1lLmVsLnBhcmVudE5vZGUsIG1lLmVsKTtcblxuICAgICAgICAgICAgbWUuY2hpbGRyZW5bMF0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IElmTm9kZTtcblxuXG4vKipcbiAqIEBmaWxlIHRlbXBsYXRlIOiKgueCueexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcbi8vIHZhciBndWlkID0gcmVxdWlyZSgnLi4vdXRpbC9ndWlkJyk7XG4vLyB2YXIgaW5zZXJ0QmVmb3JlID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9pbnNlcnQtYmVmb3JlJyk7XG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuLy8gdmFyIExpZmVDeWNsZSA9IHJlcXVpcmUoJy4vbGlmZS1jeWNsZScpO1xuLy8gdmFyIG5vZGVEaXNwb3NlID0gcmVxdWlyZSgnLi9ub2RlLWRpc3Bvc2UnKTtcbi8vIHZhciBjcmVhdGVSZXZlcnNlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLXJldmVyc2Utbm9kZScpO1xuLy8gdmFyIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtZGlzcG9zZS1jaGlsZHJlbicpO1xuLy8gdmFyIGVsZW1lbnRPd25Ub1BoYXNlID0gcmVxdWlyZSgnLi9lbGVtZW50LW93bi10by1waGFzZScpO1xuLy8gdmFyIGVsZW1lbnRVcGRhdGVDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZWxlbWVudC11cGRhdGUtY2hpbGRyZW4nKTtcbi8vIHZhciBub2RlT3duT25seUNoaWxkcmVuQXR0YWNoID0gcmVxdWlyZSgnLi9ub2RlLW93bi1vbmx5LWNoaWxkcmVuLWF0dGFjaCcpO1xuXG4vKipcbiAqIHRlbXBsYXRlIOiKgueCueexu1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhTm9kZSDmir3osaHoioLngrlcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBvd25lciDmiYDlsZ7nu4Tku7bnjq/looNcbiAqIEBwYXJhbSB7TW9kZWw9fSBzY29wZSDmiYDlsZ7mlbDmja7njq/looNcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50IOeItuS6suiKgueCuVxuICogQHBhcmFtIHtET01DaGlsZHJlbldhbGtlcj99IHJldmVyc2VXYWxrZXIg5a2Q5YWD57Sg6YGN5Y6G5a+56LGhXG4gKi9cbmZ1bmN0aW9uIFRlbXBsYXRlTm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB0aGlzLmFOb2RlID0gYU5vZGU7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnBhcmVudENvbXBvbmVudCA9IHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ01QVFxuICAgICAgICA/IHBhcmVudFxuICAgICAgICA6IHBhcmVudC5wYXJlbnRDb21wb25lbnQ7XG5cbiAgICB0aGlzLmlkID0gZ3VpZCgpO1xuICAgIHRoaXMubGlmZUN5Y2xlID0gTGlmZUN5Y2xlLnN0YXJ0O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuICAgICAgICB0aGlzLnNlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy5pZCk7XG4gICAgICAgIGluc2VydEJlZm9yZSh0aGlzLnNlbCwgcmV2ZXJzZVdhbGtlci50YXJnZXQsIHJldmVyc2VXYWxrZXIuY3VycmVudCk7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgZWFjaCh0aGlzLmFOb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoYU5vZGVDaGlsZCkge1xuICAgICAgICAgICAgbWUuY2hpbGRyZW4ucHVzaChjcmVhdGVSZXZlcnNlTm9kZShhTm9kZUNoaWxkLCByZXZlcnNlV2Fsa2VyLCBtZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLmlkKTtcbiAgICAgICAgaW5zZXJ0QmVmb3JlKHRoaXMuZWwsIHJldmVyc2VXYWxrZXIudGFyZ2V0LCByZXZlcnNlV2Fsa2VyLmN1cnJlbnQpO1xuXG4gICAgICAgIHRoaXMuX3RvUGhhc2UoJ2F0dGFjaGVkJyk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG5cblxuVGVtcGxhdGVOb2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5vZGVUeXBlLlRQTDtcblxuVGVtcGxhdGVOb2RlLnByb3RvdHlwZS5hdHRhY2ggPSBub2RlT3duT25seUNoaWxkcmVuQXR0YWNoO1xuXG4vKipcbiAqIOmUgOavgemHiuaUvlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vRGV0YWNoIOaYr+WQpuS4jeimgeaKiuiKgueCueS7jmRvbeenu+mZpFxuICogQHBhcmFtIHtib29sZWFuPX0gbm9UcmFuc2l0aW9uIOaYr+WQpuS4jeaYvuekuui/h+a4oeWKqOeUu+aViOaenFxuICovXG5UZW1wbGF0ZU5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAobm9EZXRhY2gsIG5vVHJhbnNpdGlvbikge1xuICAgIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4odGhpcywgbm9EZXRhY2gsIG5vVHJhbnNpdGlvbik7XG4gICAgbm9kZURpc3Bvc2UodGhpcyk7XG59O1xuXG5cblRlbXBsYXRlTm9kZS5wcm90b3R5cGUuX3RvUGhhc2UgPSBlbGVtZW50T3duVG9QaGFzZTtcblxuLyoqXG4gKiDop4blm77mm7TmlrDlh73mlbBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VzIOaVsOaNruWPmOWMluS/oeaBr1xuICovXG5UZW1wbGF0ZU5vZGUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgIGVsZW1lbnRVcGRhdGVDaGlsZHJlbih0aGlzLCBjaGFuZ2VzKTtcbn07XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFRlbXBsYXRlTm9kZTtcblxuXG4vKipcbiAqIEBmaWxlIOWvueWFg+e0oOeahOWtkOiKgueCuei/m+ihjOWPjeino1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIERPTUNoaWxkcmVuV2Fsa2VyID0gcmVxdWlyZSgnLi9kb20tY2hpbGRyZW4td2Fsa2VyJyk7XG4vLyB2YXIgY3JlYXRlUmV2ZXJzZU5vZGUgPSByZXF1aXJlKCcuL2NyZWF0ZS1yZXZlcnNlLW5vZGUnKTtcblxuLy8gI1tiZWdpbl0gcmV2ZXJzZVxuXG4vKipcbiAqIOWvueWFg+e0oOeahOWtkOiKgueCuei/m+ihjOWPjeino1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IOWFg+e0oFxuICovXG5mdW5jdGlvbiByZXZlcnNlRWxlbWVudENoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICB2YXIgaHRtbERpcmVjdGl2ZSA9IGVsZW1lbnQuYU5vZGUuZGlyZWN0aXZlcy5odG1sO1xuXG4gICAgaWYgKCFodG1sRGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciByZXZlcnNlV2Fsa2VyID0gbmV3IERPTUNoaWxkcmVuV2Fsa2VyKGVsZW1lbnQuZWwpO1xuXG4gICAgICAgIGVhY2goZWxlbWVudC5hTm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGFOb2RlQ2hpbGQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucHVzaChjcmVhdGVSZXZlcnNlTm9kZShhTm9kZUNoaWxkLCByZXZlcnNlV2Fsa2VyLCBlbGVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vICNbZW5kXVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXZlcnNlRWxlbWVudENoaWxkcmVuO1xuXG5cbi8qKlxuICogQGZpbGUg5aSE55CG5YWD57Sg55qE5bGe5oCn5pON5L2cXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZ2V0UHJvcEhhbmRsZXIgPSByZXF1aXJlKCcuL2dldC1wcm9wLWhhbmRsZXInKTtcblxuLyoqXG4gKiDlpITnkIblhYPntKDlsZ7mgKfmk43kvZxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDlhYPntKDlr7nosaFcbiAqIEBwYXJhbSB7Kn0gdmFsdWUg5bGe5oCn5YC8XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcCDlsZ7mgKfkv6Hmga/lr7nosaFcbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcChlbGVtZW50LCB2YWx1ZSwgcHJvcCkge1xuICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgIGdldFByb3BIYW5kbGVyKGVsZW1lbnQudGFnTmFtZSwgbmFtZSkucHJvcChlbGVtZW50LmVsLCB2YWx1ZSwgbmFtZSwgZWxlbWVudCwgcHJvcCk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGhhbmRsZVByb3A7XG5cblxuLyoqXG4gKiBAZmlsZSDliJvlu7roioLngrnlr7nlupTnmoQgSFRNTEVsZW1lbnQg5Li75YWD57SgXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBldmFsRXhwciA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZXZhbC1leHByJyk7XG4vLyB2YXIgY3JlYXRlRWwgPSByZXF1aXJlKCcuLi9icm93c2VyL2NyZWF0ZS1lbCcpO1xuLy8gdmFyIGhhbmRsZVByb3AgPSByZXF1aXJlKCcuL2hhbmRsZS1wcm9wJyk7XG4vLyB2YXIgTGlmZUN5Y2xlID0gcmVxdWlyZSgnLi9saWZlLWN5Y2xlJyk7XG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuXG52YXIgZW1wdHlQcm9wV2hlbkNyZWF0ZSA9IHtcbiAgICAnY2xhc3MnOiAxLFxuICAgICdzdHlsZSc6IDEsXG4gICAgJ2lkJzogMVxufTtcblxuLyoqXG4gKiDliJvlu7roioLngrnlr7nlupTnmoQgSFRNTEVsZW1lbnQg5Li75YWD57SgXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRPd25DcmVhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmxpZmVDeWNsZS5jcmVhdGVkKSB7XG4gICAgICAgIHZhciBpc0NvbXBvbmVudCA9IHRoaXMubm9kZVR5cGUgPT09IE5vZGVUeXBlLkNNUFQ7XG4gICAgICAgIHZhciBzb3VyY2VOb2RlID0gdGhpcy5hTm9kZS5ob3RzcG90LnNvdXJjZU5vZGU7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuYU5vZGUucHJvcHM7XG5cbiAgICAgICAgaWYgKHNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBzb3VyY2VOb2RlLmNsb25lTm9kZSgpO1xuICAgICAgICAgICAgcHJvcHMgPSB0aGlzLmFOb2RlLmhvdHNwb3QuZHluYW1pY1Byb3BzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGNyZWF0ZUVsKHRoaXMudGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fc2JpbmREYXRhKSB7XG4gICAgICAgICAgICBnZXRQcm9wSGFuZGxlcih0aGlzLnRhZ05hbWUsIGtleSkucHJvcCh0aGlzLmVsLCB0aGlzLl9zYmluZERhdGFba2V5XSwga2V5LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcHJvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaXNDb21wb25lbnRcbiAgICAgICAgICAgICAgICA/IGV2YWxFeHByKHByb3AuZXhwciwgdGhpcy5kYXRhLCB0aGlzKVxuICAgICAgICAgICAgICAgIDogZXZhbEV4cHIocHJvcC5leHByLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIHx8ICFlbXB0eVByb3BXaGVuQ3JlYXRlW3Byb3AubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVQcm9wKHRoaXMsIHZhbHVlLCBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RvUGhhc2UoJ2NyZWF0ZWQnKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25DcmVhdGU7XG5cblxuLyoqXG4gKiBAZmlsZSDlsIblhYPntKBhdHRhY2jliLDpobXpnaJcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBjcmVhdGVOb2RlID0gcmVxdWlyZSgnLi9jcmVhdGUtbm9kZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcblxuLyoqXG4gKiDlsIblhYPntKBhdHRhY2jliLDpobXpnaJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDlhYPntKDoioLngrlcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudEVsIOimgea3u+WKoOWIsOeahOeItuWFg+e0oFxuICogQHBhcmFtIHtIVE1MRWxlbWVudO+8nX0gYmVmb3JlRWwg6KaB5re75Yqg5Yiw5ZOq5Liq5YWD57Sg5LmL5YmNXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRBdHRhY2goZWxlbWVudCwgcGFyZW50RWwsIGJlZm9yZUVsKSB7XG4gICAgZWxlbWVudC5fY3JlYXRlKCk7XG4gICAgaW5zZXJ0QmVmb3JlKGVsZW1lbnQuZWwsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG5cbiAgICBpZiAoIWVsZW1lbnQuX2NvbnRlbnRSZWFkeSkge1xuICAgICAgICB2YXIgaHRtbERpcmVjdGl2ZSA9IGVsZW1lbnQuYU5vZGUuZGlyZWN0aXZlcy5odG1sO1xuXG4gICAgICAgIGlmIChodG1sRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBlbGVtZW50LmVsLmlubmVySFRNTCA9IGV2YWxFeHByKGh0bWxEaXJlY3RpdmUudmFsdWUsIGVsZW1lbnQuc2NvcGUsIGVsZW1lbnQub3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFOb2RlQ2hpbGRyZW4gPSBlbGVtZW50LmFOb2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTm9kZUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY3JlYXRlTm9kZShhTm9kZUNoaWxkcmVuW2ldLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLmF0dGFjaChlbGVtZW50LmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuX2NvbnRlbnRSZWFkeSA9IDE7XG4gICAgfVxufVxuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRBdHRhY2g7XG5cblxuLyoqXG4gKiBAZmlsZSDlsIblhYPntKBhdHRhY2jliLDpobXpnaJcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGVsZW1lbnRBdHRhY2ggPSByZXF1aXJlKCcuL2VsZW1lbnQtYXR0YWNoJyk7XG5cbi8qKlxuICog5bCG5YWD57SgYXR0YWNo5Yiw6aG16Z2iXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50RWwg6KaB5re75Yqg5Yiw55qE54i25YWD57SgXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW5077ydfSBiZWZvcmVFbCDopoHmt7vliqDliLDlk6rkuKrlhYPntKDkuYvliY1cbiAqL1xuZnVuY3Rpb24gZWxlbWVudE93bkF0dGFjaChwYXJlbnRFbCwgYmVmb3JlRWwpIHtcbiAgICBpZiAoIXRoaXMubGlmZUN5Y2xlLmF0dGFjaGVkKSB7XG4gICAgICAgIGVsZW1lbnRBdHRhY2godGhpcywgcGFyZW50RWwsIGJlZm9yZUVsKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWQoKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25BdHRhY2g7XG5cblxuLyoqXG4gKiBAZmlsZSDojrflj5YgZWxlbWVudCDnmoQgdHJhbnNpdGlvbiDmjqfliLblr7nosaFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBldmFsQXJncyA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZXZhbC1hcmdzJyk7XG4vLyB2YXIgZmluZE1ldGhvZCA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZmluZC1tZXRob2QnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG5cbi8qKlxuICog6I635Y+WIGVsZW1lbnQg55qEIHRyYW5zaXRpb24g5o6n5Yi25a+56LGhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQg5YWD57SgXG4gKiBAcmV0dXJuIHtPYmplY3Q/fVxuICovXG5mdW5jdGlvbiBlbGVtZW50R2V0VHJhbnNpdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGRpcmVjdGl2ZSA9IGVsZW1lbnQuYU5vZGUuZGlyZWN0aXZlcy50cmFuc2l0aW9uO1xuICAgIHZhciBvd25lciA9IGVsZW1lbnQub3duZXI7XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ01QVCkge1xuICAgICAgICB2YXIgY21wdEdpdmVuVHJhbnNpdGlvbiA9IGVsZW1lbnQuZ2l2ZW5BTm9kZSAmJiBlbGVtZW50LmdpdmVuQU5vZGUuZGlyZWN0aXZlcy50cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY21wdEdpdmVuVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aXZlID0gY21wdEdpdmVuVHJhbnNpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFuc2l0aW9uO1xuICAgIGlmIChkaXJlY3RpdmUgJiYgb3duZXIpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IGZpbmRNZXRob2Qob3duZXIsIGRpcmVjdGl2ZS52YWx1ZS5uYW1lKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLmFwcGx5KFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgIGV2YWxBcmdzKGRpcmVjdGl2ZS52YWx1ZS5hcmdzLCBlbGVtZW50LnNjb3BlLCBvd25lcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvbiB8fCBlbGVtZW50LnRyYW5zaXRpb247XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRHZXRUcmFuc2l0aW9uO1xuXG5cbi8qKlxuICogQGZpbGUg5YWD57Sg6IqC54K55omn6KGMbGVhdmXooYzkuLpcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlbGVtZW50R2V0VHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vZWxlbWVudC1nZXQtdHJhbnNpdGlvbicpO1xuXG5cbi8qKlxuICog5YWD57Sg6IqC54K55omn6KGMbGVhdmXooYzkuLpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDlhYPntKBcbiAqL1xuZnVuY3Rpb24gZWxlbWVudExlYXZlKGVsZW1lbnQpIHtcbiAgICB2YXIgbGlmZUN5Y2xlID0gZWxlbWVudC5saWZlQ3ljbGU7XG4gICAgaWYgKGxpZmVDeWNsZS5sZWF2aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5kaXNwb3NlTm9UcmFuc2l0aW9uKSB7XG4gICAgICAgIGVsZW1lbnQuX2RvbmVMZWF2ZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBlbGVtZW50R2V0VHJhbnNpdGlvbihlbGVtZW50KTtcblxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB0cmFuc2l0aW9uLmxlYXZlKSB7XG4gICAgICAgICAgICBlbGVtZW50Ll90b1BoYXNlKCdsZWF2aW5nJyk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsZW1lbnQuZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Ll9kb25lTGVhdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5fZG9uZUxlYXZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRMZWF2ZTtcblxuXG4vKipcbiAqIEBmaWxlIOWwhuWFg+e0oOS7jumhtemdouS4iuenu+mZpFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGVsZW1lbnRMZWF2ZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1sZWF2ZScpO1xuXG4vKipcbiAqIOWwhuWFg+e0oOS7jumhtemdouS4iuenu+mZpFxuICovXG5mdW5jdGlvbiBlbGVtZW50T3duRGV0YWNoKCkge1xuICAgIGVsZW1lbnRMZWF2ZSh0aGlzKTtcbn1cblxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlbGVtZW50T3duRGV0YWNoO1xuXG5cbi8qKlxuICogQGZpbGUg6ZSA5q+B6YeK5pS+5YWD57SgXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWxlbWVudExlYXZlID0gcmVxdWlyZSgnLi9lbGVtZW50LWxlYXZlJyk7XG5cbi8qKlxuICog6ZSA5q+B6YeK5pS+5YWD57SgXG4gKlxuICogQHBhcmFtIHtib29sZWFuPX0gbm9EZXRhY2gg5piv5ZCm5LiN6KaB5oqK6IqC54K55LuOZG9t56e76ZmkXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub1RyYW5zaXRpb24g5piv5ZCm5LiN5pi+56S66L+H5rih5Yqo55S75pWI5p6cXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRPd25EaXNwb3NlKG5vRGV0YWNoLCBub1RyYW5zaXRpb24pIHtcbiAgICB0aGlzLmxlYXZlRGlzcG9zZSA9IDE7XG4gICAgdGhpcy5kaXNwb3NlTm9EZXRhY2ggPSBub0RldGFjaDtcbiAgICB0aGlzLmRpc3Bvc2VOb1RyYW5zaXRpb24gPSBub1RyYW5zaXRpb247XG5cbiAgICBlbGVtZW50TGVhdmUodGhpcyk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25EaXNwb3NlO1xuXG5cbi8qKlxuICogQGZpbGUg5Li65YWD57Sg55qEIGVsIOe7keWumuS6i+S7tlxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIG9uID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9vbicpO1xuXG4vKipcbiAqIOS4uuWFg+e0oOeahCBlbCDnu5Hlrprkuovku7ZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDkuovku7blkI1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIOebkeWQrOWZqFxuICogQHBhcmFtIHtib29sZWFufSBjYXB0dXJlIOaYr+WQpuaYr+aNleiOt+mYtuauteinpuWPkVxuICovXG5mdW5jdGlvbiBlbGVtZW50T3duT25FbChuYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FwdHVyZSA9ICEhY2FwdHVyZTtcbiAgICAgICAgdGhpcy5fZWxGbnMucHVzaChbbmFtZSwgbGlzdGVuZXIsIGNhcHR1cmVdKTtcbiAgICAgICAgb24odGhpcy5lbCwgbmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudE93bk9uRWw7XG5cblxuLyoqXG4gKiBAZmlsZSAg5LqL5Lu257uR5a6a5LiN5a2Y5Zyo55qEIHdhcm5pbmdcbiAqIEBhdXRob3IgdmFyc2hhKHdhbmdzaHVvbnB1QGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuXG4vLyAjW2JlZ2luXSBlcnJvclxuLy8gLyoqXG4vLyAgKiDkuovku7bnu5HlrprkuI3lrZjlnKjnmoQgd2FybmluZ1xuLy8gICpcbi8vICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEJpbmQg5LqL5Lu257uR5a6a5a+56LGhXG4vLyAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe55qE57uE5Lu25a+56LGhXG4vLyAgKi9cbi8vIGZ1bmN0aW9uIHdhcm5FdmVudExpc3Rlbk1ldGhvZChldmVudEJpbmQsIG93bmVyKSB7XG4vLyAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcbi8vICAgICB2YXIgbWV0aG9kID0gb3duZXI7XG4vLyAgICAgZWFjaChldmVudEJpbmQuZXhwci5uYW1lLnBhdGhzLCBmdW5jdGlvbiAocGF0aCkge1xuLy8gICAgICAgICBpZiAoIXBhdGgudmFsdWUpIHtcbi8vICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIG1ldGhvZCA9IG1ldGhvZFtwYXRoLnZhbHVlXTtcbi8vICAgICAgICAgdmFsaWQgPSAhIW1ldGhvZDtcbi8vICAgICAgICAgcmV0dXJuIHZhbGlkO1xuLy8gICAgIH0pO1xuLy8gXG4vLyAgICAgaWYgKCF2YWxpZCkge1xuLy8gICAgICAgICB2YXIgcGF0aHMgPSBbXTtcbi8vICAgICAgICAgZWFjaChldmVudEJpbmQuZXhwci5uYW1lLnBhdGhzLCBmdW5jdGlvbiAocGF0aCkge1xuLy8gICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoLnZhbHVlKTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHZhciBtZXNzYWdlID0gJ1tTQU4gV0FSTklOR10gJyArIGV2ZW50QmluZC5uYW1lICsgJyBsaXN0ZW4gZmFpbCxcIicgKyBwYXRocy5qb2luKCcuJykgKyAnXCIgbm90IGV4aXN0Jztcbi8vIFxuLy8gICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4vLyAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4vLyAgICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4vLyAgICAgfVxuLy8gfVxuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHdhcm5FdmVudExpc3Rlbk1ldGhvZDtcblxuXG4vKipcbiAqIEBmaWxlIOWujOaIkOWFg+e0oCBhdHRhY2hlZCDlkI7nmoTooYzkuLpcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGJpbmQgPSByZXF1aXJlKCcuLi91dGlsL2JpbmQnKTtcbi8vIHZhciBlbXB0eSA9IHJlcXVpcmUoJy4uL3V0aWwvZW1wdHknKTtcbi8vIHZhciBpc0Jyb3dzZXIgPSByZXF1aXJlKCcuLi9icm93c2VyL2lzLWJyb3dzZXInKTtcbi8vIHZhciB0cmlnZ2VyID0gcmVxdWlyZSgnLi4vYnJvd3Nlci90cmlnZ2VyJyk7XG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuLy8gdmFyIGVsZW1lbnRHZXRUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9lbGVtZW50LWdldC10cmFuc2l0aW9uJyk7XG4vLyB2YXIgZXZlbnREZWNsYXJhdGlvbkxpc3RlbmVyID0gcmVxdWlyZSgnLi9ldmVudC1kZWNsYXJhdGlvbi1saXN0ZW5lcicpO1xuLy8gdmFyIGdldFByb3BIYW5kbGVyID0gcmVxdWlyZSgnLi9nZXQtcHJvcC1oYW5kbGVyJyk7XG4vLyB2YXIgd2FybkV2ZW50TGlzdGVuTWV0aG9kID0gcmVxdWlyZSgnLi93YXJuLWV2ZW50LWxpc3Rlbi1tZXRob2QnKTtcblxuLyoqXG4gKiDlj4znu5HovpPlhaXmoYZDb21wb3NpdGlvbkVuZOS6i+S7tuebkeWQrOWHveaVsFxuICpcbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpbnB1dE9uQ29tcG9zaXRpb25FbmQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBvc2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb3NpbmcgPSAwO1xuXG4gICAgdHJpZ2dlcih0aGlzLCAnaW5wdXQnKTtcbn1cblxuLyoqXG4gKiDlj4znu5HovpPlhaXmoYZDb21wb3NpdGlvblN0YXJ05LqL5Lu255uR5ZCs5Ye95pWwXG4gKlxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGlucHV0T25Db21wb3NpdGlvblN0YXJ0KCkge1xuICAgIHRoaXMuY29tcG9zaW5nID0gMTtcbn1cblxuZnVuY3Rpb24geFByb3BPdXRwdXRlcih4UHJvcCwgZGF0YSkge1xuICAgIGdldFByb3BIYW5kbGVyKHRoaXMudGFnTmFtZSwgeFByb3AubmFtZSkub3V0cHV0KHRoaXMsIHhQcm9wLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gaW5wdXRYUHJvcE91dHB1dGVyKGVsZW1lbnQsIHhQcm9wLCBkYXRhKSB7XG4gICAgdmFyIG91dHB1dGVyID0gYmluZCh4UHJvcE91dHB1dGVyLCBlbGVtZW50LCB4UHJvcCwgZGF0YSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIG91dHB1dGVyKGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiDlrozmiJDlhYPntKAgYXR0YWNoZWQg5ZCO55qE6KGM5Li6XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQg5YWD57Sg6IqC54K5XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRPd25BdHRhY2hlZCgpIHtcbiAgICB0aGlzLl90b1BoYXNlKCdjcmVhdGVkJyk7XG5cbiAgICB2YXIgaXNDb21wb25lbnQgPSB0aGlzLm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUO1xuICAgIHZhciBkYXRhID0gaXNDb21wb25lbnQgPyB0aGlzLmRhdGEgOiB0aGlzLnNjb3BlO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cbiAgICAvLyDlpITnkIboh6rouqvlj5jljJbml7blj4zlkJHnu5HlrprnmoTpgLvovpFcbiAgICB2YXIgeFByb3BzID0gdGhpcy5hTm9kZS5ob3RzcG90LnhQcm9wcztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhQcm9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHhQcm9wID0geFByb3BzW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoeFByb3AubmFtZSkge1xuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQnJvd3NlciAmJiB3aW5kb3cuQ29tcG9zaXRpb25FdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRWwoJ2NoYW5nZScsIGlucHV0T25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FbCgnY29tcG9zaXRpb25zdGFydCcsIGlucHV0T25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVsKCdjb21wb3NpdGlvbmVuZCcsIGlucHV0T25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCdvbmlucHV0JyBpbiB0aGlzLmVsKSA/ICdpbnB1dCcgOiAncHJvcGVydHljaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0WFByb3BPdXRwdXRlcih0aGlzLCB4UHJvcCwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVsKCdjaGFuZ2UnLCBiaW5kKHhQcm9wT3V0cHV0ZXIsIHRoaXMsIHhQcm9wLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5lbC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FbCgnY2xpY2snLCBiaW5kKHhQcm9wT3V0cHV0ZXIsIHRoaXMsIHhQcm9wLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmluZCBldmVudHNcbiAgICB2YXIgZXZlbnRzID0gaXNDb21wb25lbnRcbiAgICAgICAgPyB0aGlzLmFOb2RlLmV2ZW50cy5jb25jYXQodGhpcy5uYXRpdmVFdmVudHMpXG4gICAgICAgIDogdGhpcy5hTm9kZS5ldmVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGV2ZW50QmluZCA9IGV2ZW50c1tpXTtcbiAgICAgICAgdmFyIG93bmVyID0gaXNDb21wb25lbnQgPyB0aGlzIDogdGhpcy5vd25lcjtcblxuICAgICAgICAvLyDliKTmlq3mmK/lkKbmmK9uYXRpdmVFdmVudO+8jOS4i+mdoueahHdhcm7mlrnms5Xlkozkuovku7bnu5Hlrprpg73pnIDopoFcbiAgICAgICAgLy8g5L6d5q2k5oyH5a6aZXZlbnRCaW5kLmV4cHIubmFtZeS9jeS6jm93bmVy6L+Y5pivb3duZXIub3duZXLkuIpcbiAgICAgICAgaWYgKGV2ZW50QmluZC5tb2RpZmllci5uYXRpdmUpIHtcbiAgICAgICAgICAgIG93bmVyID0gb3duZXIub3duZXI7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5zY29wZSB8fCBvd25lci5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICAgICAgd2FybkV2ZW50TGlzdGVuTWV0aG9kKGV2ZW50QmluZCwgb3duZXIpO1xuICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICB0aGlzLl9vbkVsKFxuICAgICAgICAgICAgZXZlbnRCaW5kLm5hbWUsXG4gICAgICAgICAgICBiaW5kKFxuICAgICAgICAgICAgICAgIGV2ZW50RGVjbGFyYXRpb25MaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICBldmVudEJpbmQsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXZlbnRCaW5kLm1vZGlmaWVyLmNhcHR1cmVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl90b1BoYXNlKCdhdHRhY2hlZCcpO1xuXG5cbiAgICBpZiAodGhpcy5faXNJbml0RnJvbUVsKSB7XG4gICAgICAgIHRoaXMuX2lzSW5pdEZyb21FbCA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBlbGVtZW50R2V0VHJhbnNpdGlvbih0aGlzKTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdHJhbnNpdGlvbi5lbnRlcikge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcih0aGlzLmVsLCBlbXB0eSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25BdHRhY2hlZDtcblxuXG4vKipcbiAqIEBmaWxlIOmUgOavgeWFg+e0oOiKgueCuVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgdW4gPSByZXF1aXJlKCcuLi9icm93c2VyL3VuJyk7XG4vLyB2YXIgcmVtb3ZlRWwgPSByZXF1aXJlKCcuLi9icm93c2VyL3JlbW92ZS1lbCcpO1xuLy8gdmFyIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtZGlzcG9zZS1jaGlsZHJlbicpO1xuLy8gdmFyIG5vZGVEaXNwb3NlID0gcmVxdWlyZSgnLi9ub2RlLWRpc3Bvc2UnKTtcblxuLyoqXG4gKiDplIDmr4HlhYPntKDoioLngrlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDopoHplIDmr4HnmoTlhYPntKDoioLngrlcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyDplIDmr4HooYzkuLrnmoTlj4LmlbBcbiAqL1xuZnVuY3Rpb24gZWxlbWVudERpc3Bvc2UoZWxlbWVudCkge1xuICAgIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4oZWxlbWVudCwgMSwgMSk7XG5cbiAgICAvLyBlbCDkuovku7bop6Pnu5FcbiAgICB2YXIgbGVuID0gZWxlbWVudC5fZWxGbnMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICB2YXIgZm4gPSBlbGVtZW50Ll9lbEZuc1tsZW5dO1xuICAgICAgICB1bihlbGVtZW50LmVsLCBmblswXSwgZm5bMV0sIGZuWzJdKTtcbiAgICB9XG4gICAgZWxlbWVudC5fZWxGbnMgPSBudWxsO1xuXG5cbiAgICAvLyDlpoLmnpzmsqHmnIlwYXJlbnTvvIzor7TmmI7mmK/kuIDkuKpyb290IGNvbXBvbmVudO+8jOS4gOWumuimgeS7jmRvbeagkeS4rXJlbW92ZVxuICAgIGlmICghZWxlbWVudC5kaXNwb3NlTm9EZXRhY2ggfHwgIWVsZW1lbnQucGFyZW50KSB7XG4gICAgICAgIHJlbW92ZUVsKGVsZW1lbnQuZWwpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Ll90b1BoYXNlKSB7XG4gICAgICAgIGVsZW1lbnQuX3RvUGhhc2UoJ2RldGFjaGVkJyk7XG4gICAgfVxuXG4gICAgbm9kZURpc3Bvc2UoZWxlbWVudCk7XG59XG5cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudERpc3Bvc2U7XG5cblxuLyoqXG4gKiBAZmlsZSDliJ3lp4vljJYgZWxlbWVudCDoioLngrnnmoQgdGFnTmFtZSDlpITnkIZcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBpZU9sZFRoYW45ID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9pZS1vbGQtdGhhbi05Jyk7XG5cbi8qKlxuICog5Yid5aeL5YyWIGVsZW1lbnQg6IqC54K555qEIHRhZ05hbWUg5aSE55CGXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUg6IqC54K55a+56LGhXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRJbml0VGFnTmFtZShub2RlKSB7XG4gICAgbm9kZS50YWdOYW1lID0gbm9kZS50YWdOYW1lIHx8IG5vZGUuYU5vZGUudGFnTmFtZSB8fCAnZGl2JztcblxuICAgIC8vICNbYmVnaW5dIGFsbHVhXG4gICAgLy8gaWU4LSDkuI3mlK/mjIFpbm5lckhUTUzovpPlh7roh6rlrprkuYnmoIfnrb5cbiAgICBpZiAoaWVPbGRUaGFuOSAmJiBub2RlLnRhZ05hbWUuaW5kZXhPZignLScpID4gMCkge1xuICAgICAgICBub2RlLnRhZ05hbWUgPSAnZGl2JztcbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudEluaXRUYWdOYW1lO1xuXG5cbi8qKlxuICogQGZpbGUg57uZIGRldnRvb2wg5Y+R6YCa55+l5raI5oGvXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgaXNCcm93c2VyID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9pcy1icm93c2VyJyk7XG5cbi8vICNbYmVnaW5dIGRldnRvb2xcbi8vIHZhciBzYW40ZGV2dG9vbDtcbi8vIFxuLy8gLyoqXG4vLyAgKiDnu5kgZGV2dG9vbCDlj5HpgJrnn6Xmtojmga9cbi8vICAqXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDmtojmga/lkI3np7Bcbi8vICAqIEBwYXJhbSB7Kn0gYXJnIOa2iOaBr+WPguaVsFxuLy8gICovXG4vLyBmdW5jdGlvbiBlbWl0RGV2dG9vbChuYW1lLCBhcmcpIHtcbi8vICAgICBpZiAoaXNCcm93c2VyICYmIHNhbjRkZXZ0b29sICYmIHNhbjRkZXZ0b29sLmRlYnVnICYmIHdpbmRvdy5fX3Nhbl9kZXZ0b29sX18pIHtcbi8vICAgICAgICAgd2luZG93Ll9fc2FuX2RldnRvb2xfXy5lbWl0KG5hbWUsIGFyZyk7XG4vLyAgICAgfVxuLy8gfVxuLy8gXG4vLyBlbWl0RGV2dG9vbC5zdGFydCA9IGZ1bmN0aW9uIChtYWluKSB7XG4vLyAgICAgc2FuNGRldnRvb2wgPSBtYWluO1xuLy8gICAgIGVtaXREZXZ0b29sKCdzYW4nLCBtYWluKTtcbi8vIH07XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZW1pdERldnRvb2w7XG5cblxuLyoqXG4gKiBAZmlsZSDnu4Tku7bnsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBiaW5kID0gcmVxdWlyZSgnLi4vdXRpbC9iaW5kJyk7XG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGd1aWQgPSByZXF1aXJlKCcuLi91dGlsL2d1aWQnKTtcbi8vIHZhciBleHRlbmQgPSByZXF1aXJlKCcuLi91dGlsL2V4dGVuZCcpO1xuLy8gdmFyIG5leHRUaWNrID0gcmVxdWlyZSgnLi4vdXRpbC9uZXh0LXRpY2snKTtcbi8vIHZhciBlbWl0RGV2dG9vbCA9IHJlcXVpcmUoJy4uL3V0aWwvZW1pdC1kZXZ0b29sJyk7XG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvZXhwci10eXBlJyk7XG4vLyB2YXIgcGFyc2VFeHByID0gcmVxdWlyZSgnLi4vcGFyc2VyL3BhcnNlLWV4cHInKTtcbi8vIHZhciBjcmVhdGVBY2Nlc3NvciA9IHJlcXVpcmUoJy4uL3BhcnNlci9jcmVhdGUtYWNjZXNzb3InKTtcbi8vIHZhciBwb3N0UHJvcCA9IHJlcXVpcmUoJy4uL3BhcnNlci9wb3N0LXByb3AnKTtcbi8vIHZhciByZW1vdmVFbCA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcmVtb3ZlLWVsJyk7XG4vLyB2YXIgRGF0YSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZGF0YScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBjaGFuZ2VFeHByQ29tcGFyZSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY2hhbmdlLWV4cHItY29tcGFyZScpO1xuLy8gdmFyIERhdGFDaGFuZ2VUeXBlID0gcmVxdWlyZSgnLi4vcnVudGltZS9kYXRhLWNoYW5nZS10eXBlJyk7XG4vLyB2YXIgY29tcGlsZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcGlsZS1jb21wb25lbnQnKTtcbi8vIHZhciBjb21wb25lbnRQcmVoZWF0ID0gcmVxdWlyZSgnLi9jb21wb25lbnQtcHJlaGVhdCcpO1xuLy8gdmFyIExpZmVDeWNsZSA9IHJlcXVpcmUoJy4vbGlmZS1jeWNsZScpO1xuLy8gdmFyIGdldEFOb2RlUHJvcCA9IHJlcXVpcmUoJy4vZ2V0LWEtbm9kZS1wcm9wJyk7XG4vLyB2YXIgaXNEYXRhQ2hhbmdlQnlFbGVtZW50ID0gcmVxdWlyZSgnLi9pcy1kYXRhLWNoYW5nZS1ieS1lbGVtZW50Jyk7XG4vLyB2YXIgZXZlbnREZWNsYXJhdGlvbkxpc3RlbmVyID0gcmVxdWlyZSgnLi9ldmVudC1kZWNsYXJhdGlvbi1saXN0ZW5lcicpO1xuLy8gdmFyIHJldmVyc2VFbGVtZW50Q2hpbGRyZW4gPSByZXF1aXJlKCcuL3JldmVyc2UtZWxlbWVudC1jaGlsZHJlbicpO1xuLy8gdmFyIGNhbWVsQ29tcG9uZW50QmluZHMgPSByZXF1aXJlKCcuL2NhbWVsLWNvbXBvbmVudC1iaW5kcycpO1xuLy8gdmFyIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9ub2RlLXR5cGUnKTtcbi8vIHZhciBub2RlU0JpbmRJbml0ID0gcmVxdWlyZSgnLi9ub2RlLXMtYmluZC1pbml0Jyk7XG4vLyB2YXIgbm9kZVNCaW5kVXBkYXRlID0gcmVxdWlyZSgnLi9ub2RlLXMtYmluZC11cGRhdGUnKTtcbi8vIHZhciBlbGVtZW50SW5pdFRhZ05hbWUgPSByZXF1aXJlKCcuL2VsZW1lbnQtaW5pdC10YWctbmFtZScpO1xuLy8gdmFyIGVsZW1lbnRPd25BdHRhY2hlZCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tYXR0YWNoZWQnKTtcbi8vIHZhciBlbGVtZW50RGlzcG9zZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1kaXNwb3NlJyk7XG4vLyB2YXIgZWxlbWVudFVwZGF0ZUNoaWxkcmVuID0gcmVxdWlyZSgnLi9lbGVtZW50LXVwZGF0ZS1jaGlsZHJlbicpO1xuLy8gdmFyIGVsZW1lbnRPd25PbkVsID0gcmVxdWlyZSgnLi9lbGVtZW50LW93bi1vbi1lbCcpO1xuLy8gdmFyIGVsZW1lbnRPd25DcmVhdGUgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWNyZWF0ZScpO1xuLy8gdmFyIGVsZW1lbnRPd25BdHRhY2ggPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWF0dGFjaCcpO1xuLy8gdmFyIGVsZW1lbnRPd25EZXRhY2ggPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWRldGFjaCcpO1xuLy8gdmFyIGVsZW1lbnRPd25EaXNwb3NlID0gcmVxdWlyZSgnLi9lbGVtZW50LW93bi1kaXNwb3NlJyk7XG4vLyB2YXIgd2FybkV2ZW50TGlzdGVuTWV0aG9kID0gcmVxdWlyZSgnLi93YXJuLWV2ZW50LWxpc3Rlbi1tZXRob2QnKTtcbi8vIHZhciBlbGVtZW50RGlzcG9zZUNoaWxkcmVuID0gcmVxdWlyZSgnLi9lbGVtZW50LWRpc3Bvc2UtY2hpbGRyZW4nKTtcbi8vIHZhciBlbGVtZW50QXR0YWNoID0gcmVxdWlyZSgnLi9lbGVtZW50LWF0dGFjaCcpO1xuLy8gdmFyIGhhbmRsZVByb3AgPSByZXF1aXJlKCcuL2hhbmRsZS1wcm9wJyk7XG4vLyB2YXIgY3JlYXRlRGF0YVR5cGVzQ2hlY2tlciA9IHJlcXVpcmUoJy4uL3V0aWwvY3JlYXRlLWRhdGEtdHlwZXMtY2hlY2tlcicpO1xuXG5cblxuXG4vKipcbiAqIOe7hOS7tuexu1xuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg5Yid5aeL5YyW5Y+C5pWwXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChvcHRpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMubGlmZUN5Y2xlID0gTGlmZUN5Y2xlLnN0YXJ0O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl9lbEZucyA9IFtdO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5zbG90Q2hpbGRyZW4gPSBbXTtcblxuICAgIHZhciBjbGF6eiA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICB0aGlzLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnMgfHwgY2xhenouZmlsdGVycyB8fCB7fTtcbiAgICB0aGlzLmNvbXB1dGVkID0gdGhpcy5jb21wdXRlZCB8fCBjbGF6ei5jb21wdXRlZCB8fCB7fTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcyB8fCBjbGF6ei5tZXNzYWdlcyB8fCB7fTtcblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuc3ViVGFnID0gb3B0aW9ucy5zdWJUYWc7XG5cbiAgICAvLyBjb21waWxlXG4gICAgY29tcGlsZUNvbXBvbmVudChjbGF6eik7XG4gICAgY29tcG9uZW50UHJlaGVhdChjbGF6eik7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBwcm90b0FOb2RlID0gY2xhenoucHJvdG90eXBlLmFOb2RlO1xuXG4gICAgbWUuZ2l2ZW5BTm9kZSA9IG9wdGlvbnMuYU5vZGU7XG4gICAgbWUuZ2l2ZW5OYW1lZFNsb3RCaW5kcyA9IFtdO1xuICAgIG1lLmdpdmVuU2xvdHMgPSB7XG4gICAgICAgIG5hbWVkOiB7fVxuICAgIH07XG5cbiAgICB0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lcjtcbiAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5zY29wZTtcbiAgICB0aGlzLmVsID0gb3B0aW9ucy5lbDtcblxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnBhcmVudENvbXBvbmVudCA9IHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ01QVFxuICAgICAgICAgICAgPyBwYXJlbnRcbiAgICAgICAgICAgIDogcGFyZW50ICYmIHBhcmVudC5wYXJlbnRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgdGhpcy5pZCA9IGd1aWQoKTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgICB2YXIgZmlyc3RDb21tZW50Tm9kZSA9IHRoaXMuZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q29tbWVudE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIGZpcnN0Q29tbWVudE5vZGUgPSBmaXJzdENvbW1lbnROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0Q29tbWVudE5vZGUgJiYgZmlyc3RDb21tZW50Tm9kZS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgdmFyIHN0dW1wTWF0Y2ggPSBmaXJzdENvbW1lbnROb2RlLmRhdGEubWF0Y2goL15cXHMqcy1kYXRhOihbXFxzXFxTXSspPyQvKTtcbiAgICAgICAgICAgIGlmIChzdHVtcE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0dW1wVGV4dCA9IHN0dW1wTWF0Y2hbMV07XG5cbiAgICAgICAgICAgICAgICAvLyBmaWxsIGNvbXBvbmVudCBkYXRhXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gKG5ldyBGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybiAnICsgc3R1bXBUZXh0LnJlcGxhY2UoL15bXFxzXFxuXSovLCAnJylcbiAgICAgICAgICAgICAgICApKSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29tbWVudE5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsKGZpcnN0Q29tbWVudE5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWwoZmlyc3RDb21tZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI1tlbmRdXG5cbiAgICAvLyBuYXRpdmXkuovku7bmlbDnu4RcbiAgICB0aGlzLm5hdGl2ZUV2ZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZ2l2ZW5BTm9kZSkge1xuICAgICAgICAvLyDnu4Tku7bov5DooYzml7bkvKDlhaXnmoTnu5PmnoTvvIzlgZpzbG906Kej5p6QXG4gICAgICAgIHRoaXMuX2NyZWF0ZUdpdmVuU2xvdHMoKTtcblxuICAgICAgICBlYWNoKHRoaXMuZ2l2ZW5BTm9kZS5ldmVudHMsIGZ1bmN0aW9uIChldmVudEJpbmQpIHtcbiAgICAgICAgICAgIC8vIOS/neWtmOW9k+WJjeWunuS+i+eahG5hdGl2ZeS6i+S7tu+8jOS4i+mdouWIm+W7umFOb2Rl5pe25YCZ5YGa5ZCI5bm2XG4gICAgICAgICAgICBpZiAoZXZlbnRCaW5kLm1vZGlmaWVyLm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIG1lLm5hdGl2ZUV2ZW50cy5wdXNoKGV2ZW50QmluZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgICAgICAgICAgd2FybkV2ZW50TGlzdGVuTWV0aG9kKGV2ZW50QmluZCwgb3B0aW9ucy5vd25lcik7XG4gICAgICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAgICAgbWUub24oXG4gICAgICAgICAgICAgICAgZXZlbnRCaW5kLm5hbWUsXG4gICAgICAgICAgICAgICAgYmluZChldmVudERlY2xhcmF0aW9uTGlzdGVuZXIsIG9wdGlvbnMub3duZXIsIGV2ZW50QmluZCwgMSwgb3B0aW9ucy5zY29wZSksXG4gICAgICAgICAgICAgICAgZXZlbnRCaW5kXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRhZ05hbWUgPSBwcm90b0FOb2RlLnRhZ05hbWUgfHwgbWUuZ2l2ZW5BTm9kZS50YWdOYW1lO1xuICAgICAgICB0aGlzLmJpbmRzID0gY2FtZWxDb21wb25lbnRCaW5kcyh0aGlzLmdpdmVuQU5vZGUucHJvcHMpO1xuXG4gICAgICAgIC8vIGluaXQgcy1iaW5kIGRhdGFcbiAgICAgICAgbm9kZVNCaW5kSW5pdCh0aGlzLCB0aGlzLmdpdmVuQU5vZGUuZGlyZWN0aXZlcy5iaW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLl90b1BoYXNlKCdjb21waWxlZCcpO1xuXG4gICAgLy8gaW5pdCBkYXRhXG4gICAgdGhpcy5kYXRhID0gbmV3IERhdGEoXG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmluaXREYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaXMuaW5pdERhdGEoKSB8fCB7fSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSB8fCB0aGlzLl9zYmluZERhdGFcbiAgICAgICAgKVxuICAgICk7XG5cbiAgICBlbGVtZW50SW5pdFRhZ05hbWUodGhpcyk7XG5cbiAgICBlYWNoKHRoaXMuYmluZHMsIGZ1bmN0aW9uIChiaW5kKSB7XG4gICAgICAgIHBvc3RQcm9wKGJpbmQpO1xuXG4gICAgICAgIGlmIChtZS5zY29wZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZhbEV4cHIoYmluZC5leHByLCBtZS5zY29wZSwgbWUub3duZXIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvc2FuL2lzc3Vlcy8xOTFcbiAgICAgICAgICAgICAgICBtZS5kYXRhLnNldChiaW5kLm5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3Jcbi8vICAgICAvLyDlnKjliJ3lp4vljJYgKyDmlbDmja7nu5HlrprlkI7vvIzlvIDlp4vmlbDmja7moKHpqoxcbi8vICAgICAvLyBOT1RFOiDlj6rlnKjlvIDlj5HniYjmnKzkuK3ov5vooYzlsZ7mgKfmoKHpqoxcbi8vICAgICB2YXIgZGF0YVR5cGVzID0gdGhpcy5kYXRhVHlwZXMgfHwgY2xhenouZGF0YVR5cGVzO1xuLy8gICAgIGlmIChkYXRhVHlwZXMpIHtcbi8vICAgICAgICAgdmFyIGRhdGFUeXBlQ2hlY2tlciA9IGNyZWF0ZURhdGFUeXBlc0NoZWNrZXIoXG4vLyAgICAgICAgICAgICBkYXRhVHlwZXMsXG4vLyAgICAgICAgICAgICB0aGlzLnN1YlRhZyB8fCB0aGlzLm5hbWUgfHwgY2xhenoubmFtZVxuLy8gICAgICAgICApO1xuLy8gICAgICAgICB0aGlzLmRhdGEuc2V0VHlwZUNoZWNrZXIoZGF0YVR5cGVDaGVja2VyKTtcbi8vICAgICAgICAgdGhpcy5kYXRhLmNoZWNrRGF0YVR5cGVzKCk7XG4vLyAgICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgdGhpcy5jb21wdXRlZERlcHMgPSB7fTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbiAgICBmb3IgKHZhciBleHByIGluIHRoaXMuY29tcHV0ZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXB1dGVkRGVwc1tleHByXSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY0NvbXB1dGVkKGV4cHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXG5cbiAgICBpZiAoIXRoaXMuZGF0YUNoYW5nZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlciA9IGJpbmQodGhpcy5fZGF0YUNoYW5nZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGEubGlzdGVuKHRoaXMuZGF0YUNoYW5nZXIpO1xuICAgIH1cbiAgICB0aGlzLl90b1BoYXNlKCdpbml0ZWQnKTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgICByZXZlcnNlRWxlbWVudENoaWxkcmVuKHRoaXMpO1xuICAgICAgICB0aGlzLl9hdHRhY2hlZCgpO1xuICAgIH1cblxuICAgIHZhciB3YWxrZXIgPSBvcHRpb25zLnJldmVyc2VXYWxrZXI7XG4gICAgaWYgKHdhbGtlcikge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB3YWxrZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmVsID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICB3YWxrZXIuZ29OZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXZlcnNlRWxlbWVudENoaWxkcmVuKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkKCk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG5cbi8qKlxuICog5Yid5aeL5YyW5Yib5bu657uE5Lu25aSW6YOo5Lyg5YWl55qE5o+S5qe95a+56LGhXG4gKlxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLl9jcmVhdGVHaXZlblNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgbWUuZ2l2ZW5TbG90cy5uYW1lZCA9IHt9O1xuXG4gICAgLy8g57uE5Lu26L+Q6KGM5pe25Lyg5YWl55qE57uT5p6E77yM5YGac2xvdOino+aekFxuICAgIG1lLmdpdmVuQU5vZGUgJiYgbWUuc2NvcGUgJiYgZWFjaChtZS5naXZlbkFOb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIHRhcmdldDtcblxuICAgICAgICB2YXIgc2xvdEJpbmQgPSAhY2hpbGQudGV4dEV4cHIgJiYgZ2V0QU5vZGVQcm9wKGNoaWxkLCAnc2xvdCcpO1xuICAgICAgICBpZiAoc2xvdEJpbmQpIHtcbiAgICAgICAgICAgICFtZS5naXZlblNsb3RJbml0ZWQgJiYgbWUuZ2l2ZW5OYW1lZFNsb3RCaW5kcy5wdXNoKHNsb3RCaW5kKTtcblxuICAgICAgICAgICAgdmFyIHNsb3ROYW1lID0gZXZhbEV4cHIoc2xvdEJpbmQuZXhwciwgbWUuc2NvcGUsIG1lLm93bmVyKTtcbiAgICAgICAgICAgIHRhcmdldCA9IG1lLmdpdmVuU2xvdHMubmFtZWRbc2xvdE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBtZS5naXZlblNsb3RzLm5hbWVkW3Nsb3ROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFtZS5naXZlblNsb3RJbml0ZWQpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG1lLmdpdmVuU2xvdHMubm9uYW1lO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBtZS5naXZlblNsb3RzLm5vbmFtZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ICYmIHRhcmdldC5wdXNoKGNoaWxkKTtcbiAgICB9KTtcblxuICAgIG1lLmdpdmVuU2xvdEluaXRlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIOexu+Wei+agh+ivhlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUubm9kZVR5cGUgPSBOb2RlVHlwZS5DTVBUO1xuXG4vKipcbiAqIOWcqOS4i+S4gOS4quabtOaWsOWRqOacn+i/kOihjOWHveaVsFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIOimgei/kOihjOeahOWHveaVsFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qIGVzbGludC1kaXNhYmxlIG9wZXJhdG9yLWxpbmVicmVhayAqL1xuLyoqXG4gKiDkvb/oioLngrnliLDovr7nm7jlupTnmoTnlJ/lkb3lkajmnJ9cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDnlJ/lkb3lkajmnJ/lkI3np7BcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5fY2FsbEhvb2sgPVxuQ29tcG9uZW50LnByb3RvdHlwZS5fdG9QaGFzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmxpZmVDeWNsZVtuYW1lXSkge1xuICAgICAgICB0aGlzLmxpZmVDeWNsZSA9IExpZmVDeWNsZVtuYW1lXSB8fCB0aGlzLmxpZmVDeWNsZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1snX2FmdGVyJyArIG5hbWVdID0gMTtcblxuICAgICAgICAvLyDpgJrnn6VkZXZ0b29sXG4gICAgICAgIC8vICNbYmVnaW5dIGRldnRvb2xcbi8vICAgICAgICAgZW1pdERldnRvb2woJ2NvbXAtJyArIG5hbWUsIHRoaXMpO1xuICAgICAgICAvLyAjW2VuZF1cbiAgICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSBvcGVyYXRvci1saW5lYnJlYWsgKi9cblxuXG4vKipcbiAqIOa3u+WKoOS6i+S7tuebkeWQrOWZqFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOS6i+S7tuWQjVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5ZmoXG4gKiBAcGFyYW0ge3N0cmluZz99IGRlY2xhcmF0aW9uIOWjsOaYjuW8j1xuICovXG5Db21wb25lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyLCBkZWNsYXJhdGlvbikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tuYW1lXS5wdXNoKHtmbjogbGlzdGVuZXIsIGRlY2xhcmF0aW9uOiBkZWNsYXJhdGlvbn0pO1xuICAgIH1cbn07XG5cbi8qKlxuICog56e76Zmk5LqL5Lu255uR5ZCs5ZmoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg5LqL5Lu25ZCNXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gbGlzdGVuZXIg55uR5ZCs5ZmoXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUudW4gPSBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgbmFtZUxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW25hbWVdO1xuICAgIHZhciBsZW4gPSBuYW1lTGlzdGVuZXJzICYmIG5hbWVMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgbGlzdGVuZXIgPT09IG5hbWVMaXN0ZW5lcnNbbGVuXS5mbikge1xuICAgICAgICAgICAgbmFtZUxpc3RlbmVycy5zcGxpY2UobGVuLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiDmtL7lj5Hkuovku7ZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDkuovku7blkI1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKG5hbWUsIGV2ZW50KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBlYWNoKHRoaXMubGlzdGVuZXJzW25hbWVdLCBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIuZm4uY2FsbChtZSwgZXZlbnQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiDorqHnrpcgY29tcHV0ZWQg5bGe5oCn55qE5YC8XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wdXRlZEV4cHIgY29tcHV0ZWTooajovr7lvI/kuLJcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5fY2FsY0NvbXB1dGVkID0gZnVuY3Rpb24gKGNvbXB1dGVkRXhwcikge1xuICAgIHZhciBjb21wdXRlZERlcHMgPSB0aGlzLmNvbXB1dGVkRGVwc1tjb21wdXRlZEV4cHJdO1xuICAgIGlmICghY29tcHV0ZWREZXBzKSB7XG4gICAgICAgIGNvbXB1dGVkRGVwcyA9IHRoaXMuY29tcHV0ZWREZXBzW2NvbXB1dGVkRXhwcl0gPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEuc2V0KGNvbXB1dGVkRXhwciwgdGhpcy5jb21wdXRlZFtjb21wdXRlZEV4cHJdLmNhbGwoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBnZXQ6IGJpbmQoZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuLy8gICAgICAgICAgICAgICAgIGlmICghZXhwcikge1xuLy8gICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdIGNhbGwgZ2V0IG1ldGhvZCBpbiBjb21wdXRlZCBuZWVkIGFyZ3VtZW50Jyk7XG4vLyAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wdXRlZERlcHNbZXhwcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWREZXBzW2V4cHJdID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wdXRlZFtleHByXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsY0NvbXB1dGVkKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXRjaChleHByLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxjQ29tcHV0ZWQoY29tcHV0ZWRFeHByKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZXhwcik7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICB9XG4gICAgfSkpO1xufTtcblxuLyoqXG4gKiDmtL7lj5Hmtojmga9cbiAqIOe7hOS7tuWPr+S7pea0vuWPkea2iOaBr++8jOa2iOaBr+Wwhuayv+edgOe7hOS7tuagkeWQkeS4iuS8oOmAku+8jOebtOWIsOmBh+S4iuesrOS4gOS4quWkhOeQhua2iOaBr+eahOe7hOS7tlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOa2iOaBr+WQjeensFxuICogQHBhcmFtIHsqP30gdmFsdWUg5raI5oGv5YC8XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcGFyZW50Q29tcG9uZW50ID0gdGhpcy5wYXJlbnRDb21wb25lbnQ7XG5cbiAgICB3aGlsZSAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHBhcmVudENvbXBvbmVudC5tZXNzYWdlc1tuYW1lXSB8fCBwYXJlbnRDb21wb25lbnQubWVzc2FnZXNbJyonXTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWNlaXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVjZWl2ZXIuY2FsbChcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAge3RhcmdldDogdGhpcywgdmFsdWU6IHZhbHVlLCBuYW1lOiBuYW1lfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50Q29tcG9uZW50ID0gcGFyZW50Q29tcG9uZW50LnBhcmVudENvbXBvbmVudDtcbiAgICB9XG59O1xuXG4vKipcbiAqIOiOt+WPlue7hOS7tuWGhemDqOeahCBzbG90XG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIHNsb3TlkI3np7DvvIznqbrkuLpkZWZhdWx0IHNsb3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNsb3QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gY2hpbGRyZW5UcmF2ZXJzYWwoY2hpbGRyZW4pIHtcbiAgICAgICAgZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IE5vZGVUeXBlLlNMT1QgJiYgY2hpbGQub3duZXIgPT09IG1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzTmFtZWQgJiYgY2hpbGQubmFtZSA9PT0gbmFtZVxuICAgICAgICAgICAgICAgICAgICB8fCAhY2hpbGQuaXNOYW1lZCAmJiAhbmFtZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5UcmF2ZXJzYWwoY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjaGlsZHJlblRyYXZlcnNhbCh0aGlzLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiDojrflj5bluKbmnIkgc2FuLXJlZiDmjIfku6TnmoTlrZDnu4Tku7blvJXnlKhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDlrZDnu4Tku7bnmoTlvJXnlKjlkI1cbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciByZWZUYXJnZXQ7XG4gICAgdmFyIG93bmVyID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGNoaWxkcmVuVHJhdmVyc2FsKGNoaWxkcmVuKSB7XG4gICAgICAgIGVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgZWxlbWVudFRyYXZlcnNhbChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gIXJlZlRhcmdldDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxlbWVudFRyYXZlcnNhbChlbGVtZW50KSB7XG4gICAgICAgIHZhciBub2RlVHlwZSA9IGVsZW1lbnQubm9kZVR5cGU7XG4gICAgICAgIGlmIChub2RlVHlwZSA9PT0gTm9kZVR5cGUuVEVYVCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQub3duZXIgPT09IG93bmVyKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5FTEVNOlxuICAgICAgICAgICAgICAgICAgICByZWYgPSBlbGVtZW50LmFOb2RlLmRpcmVjdGl2ZXMucmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmICYmIGV2YWxFeHByKHJlZi52YWx1ZSwgZWxlbWVudC5zY29wZSwgb3duZXIpID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZUYXJnZXQgPSBlbGVtZW50LmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5DTVBUOlxuICAgICAgICAgICAgICAgICAgICByZWYgPSBlbGVtZW50LmdpdmVuQU5vZGUuZGlyZWN0aXZlcy5yZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYgJiYgZXZhbEV4cHIocmVmLnZhbHVlLCBlbGVtZW50LnNjb3BlLCBvd25lcikgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIXJlZlRhcmdldCAmJiBjaGlsZHJlblRyYXZlcnNhbChlbGVtZW50LnNsb3RDaGlsZHJlbik7XG4gICAgICAgIH1cblxuICAgICAgICAhcmVmVGFyZ2V0ICYmIGNoaWxkcmVuVHJhdmVyc2FsKGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGNoaWxkcmVuVHJhdmVyc2FsKHRoaXMuY2hpbGRyZW4pO1xuXG4gICAgcmV0dXJuIHJlZlRhcmdldDtcbn07XG5cblxuLyoqXG4gKiDop4blm77mm7TmlrDlh73mlbBcbiAqXG4gKiBAcGFyYW0ge0FycmF5P30gY2hhbmdlcyDmlbDmja7lj5jljJbkv6Hmga9cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBpZiAodGhpcy5saWZlQ3ljbGUuZGlzcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG5cblxuICAgIHZhciBuZWVkUmVsb2FkRm9yU2xvdCA9IGZhbHNlO1xuICAgIHRoaXMuX25vdGlmeU5lZWRSZWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5lZWRSZWxvYWRGb3JTbG90ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgbm9kZVNCaW5kVXBkYXRlKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHRoaXMuZ2l2ZW5BTm9kZS5kaXJlY3RpdmVzLmJpbmQsXG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gbWUuZ2l2ZW5BTm9kZS5ob3RzcG90LnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5kYXRhLnNldChuYW1lLCB2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtZS5vd25lci5pZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cblxuICAgICAgICBlYWNoKGNoYW5nZXMsIGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VFeHByID0gY2hhbmdlLmV4cHI7XG5cbiAgICAgICAgICAgIGVhY2gobWUuYmluZHMsIGZ1bmN0aW9uIChiaW5kSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgc2V0RXhwciA9IGJpbmRJdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUV4cHIgPSBiaW5kSXRlbS5leHByO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0RhdGFDaGFuZ2VCeUVsZW1lbnQoY2hhbmdlLCBtZSwgc2V0RXhwcilcbiAgICAgICAgICAgICAgICAgICAgJiYgKHJlbGF0aW9uID0gY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlRXhwciwgdXBkYXRlRXhwciwgbWUuc2NvcGUpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpb24gPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFeHByID0gY3JlYXRlQWNjZXNzb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5TVFJJTkcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2V0RXhwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQoY2hhbmdlRXhwci5wYXRocy5zbGljZSh1cGRhdGVFeHByLnBhdGhzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRXhwciA9IGNoYW5nZUV4cHI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpb24gPj0gMiAmJiBjaGFuZ2UudHlwZSA9PT0gRGF0YUNoYW5nZVR5cGUuU1BMSUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5kYXRhLnNwbGljZShzZXRFeHByLCBbY2hhbmdlLmluZGV4LCBjaGFuZ2UuZGVsZXRlQ291bnRdLmNvbmNhdChjaGFuZ2UuaW5zZXJ0aW9ucyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1lLm93bmVyLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5kYXRhLnNldChzZXRFeHByLCBldmFsRXhwcih1cGRhdGVFeHByLCBtZS5zY29wZSwgbWUub3duZXIpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtZS5vd25lci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGVhY2gobWUuZ2l2ZW5OYW1lZFNsb3RCaW5kcywgZnVuY3Rpb24gKGJpbmRJdGVtKSB7XG4gICAgICAgICAgICAgICAgbmVlZFJlbG9hZEZvclNsb3QgPSBuZWVkUmVsb2FkRm9yU2xvdCB8fCBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VFeHByLCBiaW5kSXRlbS5leHByLCBtZS5zY29wZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuZWVkUmVsb2FkRm9yU2xvdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmVlZFJlbG9hZEZvclNsb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUdpdmVuU2xvdHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGFpbnRDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNsb3RDaGlsZHJlbkxlbiA9IHRoaXMuc2xvdENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChzbG90Q2hpbGRyZW5MZW4tLSkge1xuICAgICAgICAgICAgICAgIHZhciBzbG90Q2hpbGQgPSB0aGlzLnNsb3RDaGlsZHJlbltzbG90Q2hpbGRyZW5MZW5dO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNsb3RDaGlsZC5saWZlQ3ljbGUuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG90Q2hpbGRyZW4uc3BsaWNlKHNsb3RDaGlsZHJlbkxlbiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3RDaGlsZC5pc0luc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3RDaGlsZC5fdXBkYXRlKGNoYW5nZXMsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXRhQ2hhbmdlcyA9IHRoaXMuZGF0YUNoYW5nZXM7XG4gICAgaWYgKGRhdGFDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZXMgPSBudWxsO1xuICAgICAgICBlYWNoKHRoaXMuYU5vZGUuaG90c3BvdC5keW5hbWljUHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBlYWNoKGRhdGFDaGFuZ2VzLCBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZS5leHByLCBwcm9wLmV4cHIsIG1lLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHx8IHByb3AuaGludEV4cHIgJiYgY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlLmV4cHIsIHByb3AuaGludEV4cHIsIG1lLmRhdGEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVByb3AobWUsIGV2YWxFeHByKHByb3AuZXhwciwgbWUuZGF0YSwgbWUpLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbGVtZW50VXBkYXRlQ2hpbGRyZW4odGhpcywgZGF0YUNoYW5nZXMpO1xuICAgICAgICBpZiAobmVlZFJlbG9hZEZvclNsb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUdpdmVuU2xvdHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGFpbnRDaGlsZHJlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdG9QaGFzZSgndXBkYXRlZCcpO1xuXG4gICAgICAgIGlmICh0aGlzLm93bmVyKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCaW5keE93bmVyKGRhdGFDaGFuZ2VzKTtcbiAgICAgICAgICAgIHRoaXMub3duZXIuX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5TmVlZFJlbG9hZCA9IG51bGw7XG59O1xuXG5Db21wb25lbnQucHJvdG90eXBlLl91cGRhdGVCaW5keE93bmVyID0gZnVuY3Rpb24gKGRhdGFDaGFuZ2VzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGlmICh0aGlzLm93bmVyKSB7XG4gICAgICAgIGVhY2goZGF0YUNoYW5nZXMsIGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIGVhY2gobWUuYmluZHMsIGZ1bmN0aW9uIChiaW5kSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VFeHByID0gY2hhbmdlLmV4cHI7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRJdGVtLnhcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRGF0YUNoYW5nZUJ5RWxlbWVudChjaGFuZ2UsIG1lLm93bmVyKVxuICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VFeHByLCBwYXJzZUV4cHIoYmluZEl0ZW0ubmFtZSksIG1lLmRhdGEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVTY29wZUV4cHIgPSBiaW5kSXRlbS5leHByO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlRXhwci5wYXRocy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTY29wZUV4cHIgPSBjcmVhdGVBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kSXRlbS5leHByLnBhdGhzLmNvbmNhdChjaGFuZ2VFeHByLnBhdGhzLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1lLnNjb3BlLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNjb3BlRXhwcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxFeHByKGNoYW5nZUV4cHIsIG1lLmRhdGEsIG1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBiaW5kSXRlbS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOmHjeaWsOe7mOWItue7hOS7tueahOWGheWuuVxuICog5b2TIGR5bmFtaWMgc2xvdCBuYW1lIOWPkeeUn+WPmOabtOaIliBzbG90IOWMuemFjeWPkeeUn+WPmOWMluaXtu+8jOmHjeaWsOe7mOWItlxuICog5Zyo57uE5Lu257qn5Yir6YeN57uY5pyJ54K557KX5pq077yM5L2G5piv6IO95L+d6K+B6KeG5Zu+57uT5p6c5q2j56Gu5oCnXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuX3JlcGFpbnRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50RGlzcG9zZUNoaWxkcmVuKHRoaXMsIDAsIDEpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuX2NvbnRlbnRSZWFkeSA9IDA7XG4gICAgdGhpcy5zbG90Q2hpbGRyZW4gPSBbXTtcbiAgICBlbGVtZW50QXR0YWNoKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIOe7hOS7tuWGhemDqOebkeWQrOaVsOaNruWPmOWMlueahOWHveaVsFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlIOaVsOaNruWPmOWMluS/oeaBr1xuICovXG5Db21wb25lbnQucHJvdG90eXBlLl9kYXRhQ2hhbmdlciA9IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5saWZlQ3ljbGUuY3JlYXRlZCAmJiB0aGlzLl9hZnRlcmNyZWF0ZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFDaGFuZ2VzKSB7XG4gICAgICAgICAgICBuZXh0VGljayh0aGlzLl91cGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubGlmZUN5Y2xlLmluaXRlZCAmJiB0aGlzLm93bmVyKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJpbmR4T3duZXIoW2NoYW5nZV0pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiDnm5HlkKznu4Tku7bnmoTmlbDmja7lj5jljJZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YU5hbWUg5Y+Y5YyW55qE5pWw5o2u6aG5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciDnm5HlkKzlh73mlbBcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChkYXRhTmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgZGF0YUV4cHIgPSBwYXJzZUV4cHIoZGF0YU5hbWUpO1xuXG4gICAgdGhpcy5kYXRhLmxpc3RlbihiaW5kKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgaWYgKGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZS5leHByLCBkYXRhRXhwciwgdGhpcy5kYXRhKSkge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmFsRXhwcihkYXRhRXhwciwgdGhpcy5kYXRhLCB0aGlzKSwgY2hhbmdlKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICog57uE5Lu26ZSA5q+B55qE6KGM5Li6XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg6ZSA5q+B6KGM5Li655qE5Y+C5pWwXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGVsZW1lbnRPd25EaXNwb3NlO1xuXG5Db21wb25lbnQucHJvdG90eXBlLl9kb25lTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubGVhdmVEaXNwb3NlKSB7XG4gICAgICAgIGlmICghdGhpcy5saWZlQ3ljbGUuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIC8vIOi/memHjOS4jeeUqOaMqOS4quiwg+eUqCBkaXNwb3NlIOS6hu+8jOWboOS4uiBjaGlsZHJlbiDph4rmlL7pk77kvJrosIPnlKjnmoRcbiAgICAgICAgICAgIHRoaXMuc2xvdENoaWxkcmVuID0gbnVsbDtcblxuICAgICAgICAgICAgdGhpcy5kYXRhLnVubGlzdGVuKCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZXMgPSBudWxsO1xuXG4gICAgICAgICAgICBlbGVtZW50RGlzcG9zZShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZU5vRGV0YWNoLFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZU5vVHJhbnNpdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbDtcblxuICAgICAgICAgICAgdGhpcy5naXZlbkFOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2l2ZW5TbG90cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmdpdmVuTmFtZWRTbG90QmluZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubGlmZUN5Y2xlLmF0dGFjaGVkKSB7XG4gICAgICAgIHJlbW92ZUVsKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLl90b1BoYXNlKCdkZXRhY2hlZCcpO1xuICAgIH1cbn07XG5cbi8qKlxuICog5a6M5oiQ57uE5Lu2IGF0dGFjaGVkIOWQjueahOihjOS4ulxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IOWFg+e0oOiKgueCuVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLl9hdHRhY2hlZCA9IGVsZW1lbnRPd25BdHRhY2hlZDtcblxuQ29tcG9uZW50LnByb3RvdHlwZS5hdHRhY2ggPSBlbGVtZW50T3duQXR0YWNoO1xuQ29tcG9uZW50LnByb3RvdHlwZS5kZXRhY2ggPSBlbGVtZW50T3duRGV0YWNoO1xuQ29tcG9uZW50LnByb3RvdHlwZS5fY3JlYXRlID0gZWxlbWVudE93bkNyZWF0ZTtcbkNvbXBvbmVudC5wcm90b3R5cGUuX29uRWwgPSBlbGVtZW50T3duT25FbDtcblxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQ7XG5cblxuLyoqXG4gKiBAZmlsZSDliJvlu7rnu4Tku7bnsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudCcpO1xuLy8gdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xuXG4vKipcbiAqIOWIm+W7uue7hOS7tuexu1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byDnu4Tku7bnsbvnmoTmlrnms5XooahcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQocHJvdG8pIHtcbiAgICAvLyDlpoLmnpzkvKDlhaXkuIDkuKrkuI3mmK8gc2FuIGNvbXBvbmVudCDnmoQgY29uc3RydWN0b3LvvIznm7TmjqXov5Tlm57kuI3mmK/nu4Tku7bmnoTpgKDlh73mlbBcbiAgICAvLyDov5nnp43lnLrmma/lr7zoh7TnmoTplJnor68gc2FuIOS4jeS6iOiAg+iZkVxuICAgIGlmICh0eXBlb2YgcHJvdG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgIH1cblxuICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgaWYgKHR5cGVvZiBwcm90byAhPT0gJ29iamVjdCcpIHtcbi8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEZBVEFMXSBwYXJhbSBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LicpO1xuLy8gICAgIH1cbiAgICAvLyAjW2VuZF1cblxuICAgIGZ1bmN0aW9uIENvbXBvbmVudENsYXNzKG9wdGlvbikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgfVxuXG4gICAgQ29tcG9uZW50Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XG4gICAgaW5oZXJpdHMoQ29tcG9uZW50Q2xhc3MsIENvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gQ29tcG9uZW50Q2xhc3M7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluZUNvbXBvbmVudDtcblxuXG4vKipcbiAqIEBmaWxlIOe8luivkee7hOS7tuexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgY3JlYXRlQU5vZGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvY3JlYXRlLWEtbm9kZScpO1xuLy8gdmFyIHBhcnNlVGVtcGxhdGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvcGFyc2UtdGVtcGxhdGUnKTtcbi8vIHZhciBwYXJzZVRleHQgPSByZXF1aXJlKCcuLi9wYXJzZXIvcGFyc2UtdGV4dCcpO1xuLy8gdmFyIGRlZmluZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vZGVmaW5lLWNvbXBvbmVudCcpO1xuXG5cbi8qKlxuICog57yW6K+R57uE5Lu257G744CC6aKE6Kej5p6QdGVtcGxhdGXlkoxjb21wb25lbnRzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDb21wb25lbnQoQ29tcG9uZW50Q2xhc3MpIHtcbiAgICB2YXIgcHJvdG8gPSBDb21wb25lbnRDbGFzcy5wcm90b3R5cGU7XG5cbiAgICAvLyBwcmUgZGVmaW5lIGNvbXBvbmVudHMgY2xhc3NcbiAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdfY21wdFJlYWR5JykpIHtcbiAgICAgICAgcHJvdG8uY29tcG9uZW50cyA9IENvbXBvbmVudENsYXNzLmNvbXBvbmVudHMgfHwgcHJvdG8uY29tcG9uZW50cyB8fCB7fTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBwcm90by5jb21wb25lbnRzO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wb25lbnRzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudHNba2V5XTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2tleV0gPSBkZWZpbmVDb21wb25lbnQoY29tcG9uZW50Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Q2xhc3MgPT09ICdzZWxmJykge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNba2V5XSA9IENvbXBvbmVudENsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8uX2NtcHRSZWFkeSA9IDE7XG4gICAgfVxuXG5cbiAgICAvLyBwcmUgY29tcGlsZSB0ZW1wbGF0ZVxuICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ2FOb2RlJykpIHtcbiAgICAgICAgcHJvdG8uYU5vZGUgPSBjcmVhdGVBTm9kZSgpO1xuXG4gICAgICAgIHZhciB0cGwgPSBDb21wb25lbnRDbGFzcy50ZW1wbGF0ZSB8fCBwcm90by50ZW1wbGF0ZTtcbiAgICAgICAgaWYgKHRwbCkge1xuICAgICAgICAgICAgdmFyIGFOb2RlID0gcGFyc2VUZW1wbGF0ZSh0cGwsIHtcbiAgICAgICAgICAgICAgICB0cmltV2hpdGVzcGFjZTogcHJvdG8udHJpbVdoaXRlc3BhY2UgfHwgQ29tcG9uZW50Q2xhc3MudHJpbVdoaXRlc3BhY2UsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyczogcHJvdG8uZGVsaW1pdGVycyB8fCBDb21wb25lbnRDbGFzcy5kZWxpbWl0ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBmaXJzdENoaWxkID0gYU5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4vLyAgICAgICAgICAgICBpZiAoYU5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGZpcnN0Q2hpbGQudGV4dEV4cHIpIHtcbi8vICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRkFUQUxdIHRlbXBsYXRlIG11c3QgaGF2ZSBhIHJvb3QgZWxlbWVudC4nKTtcbi8vICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgICAgICBwcm90by5hTm9kZSA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGlsZC50YWdOYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDaGlsZC50YWdOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFByb3BFeHRyYSA9IHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB7bmFtZTogJ2NsYXNzJywgZXhwcjogcGFyc2VUZXh0KCd7e2NsYXNzIHwgX2NsYXNzIHwgX3NlcChcIiBcIil9fScpfSxcbiAgICAgICAgICAgICAgICAnc3R5bGUnOiB7bmFtZTogJ3N0eWxlJywgZXhwcjogcGFyc2VUZXh0KCd7e3N0eWxlIHwgX3N0eWxlIHwgX3NlcChcIjtcIil9fScpfSxcbiAgICAgICAgICAgICAgICAnaWQnOiB7bmFtZTogJ2lkJywgZXhwcjogcGFyc2VUZXh0KCd7e2lkfX0nKX1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBmaXJzdENoaWxkLnByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZmlyc3RDaGlsZC5wcm9wc1tsZW5dO1xuICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IGNvbXBvbmVudFByb3BFeHRyYVtwcm9wLm5hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGQucHJvcHMuc3BsaWNlKGxlbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BFeHRyYVtwcm9wLm5hbWVdID0gcHJvcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5uYW1lICE9PSAnaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLmV4cHIuc2Vncy5wdXNoKGV4dHJhLmV4cHIuc2Vnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLmV4cHIudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdENoaWxkLnByb3BzLnB1c2goXG4gICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcEV4dHJhWydjbGFzcyddLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BFeHRyYS5zdHlsZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9wRXh0cmEuaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVDb21wb25lbnQ7XG5cblxuLyoqXG4gKiBAZmlsZSDnu4Tku7bpooTng61cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9leHByLXR5cGUnKTtcbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG4vLyB2YXIgY3JlYXRlRWwgPSByZXF1aXJlKCcuLi9icm93c2VyL2NyZWF0ZS1lbCcpO1xuLy8gdmFyIGdldFByb3BIYW5kbGVyID0gcmVxdWlyZSgnLi9nZXQtcHJvcC1oYW5kbGVyJyk7XG4vLyB2YXIgZ2V0QU5vZGVQcm9wID0gcmVxdWlyZSgnLi9nZXQtYS1ub2RlLXByb3AnKTtcbi8vIHZhciBpc0Jyb3dzZXIgPSByZXF1aXJlKCcuLi9icm93c2VyL2lzLWJyb3dzZXInKTtcblxuLyoqXG4gKiDnu4Tku7bpooTng63vvIzliIbmnpDnu4Tku7ZhTm9kZeeahOaVsOaNruW8leeUqOetieS/oeaBr1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudENsYXNzIOe7hOS7tuexu1xuICovXG5mdW5jdGlvbiBjb21wb25lbnRQcmVoZWF0KENvbXBvbmVudENsYXNzKSB7XG4gICAgdmFyIHN0YWNrID0gW107XG5cbiAgICBmdW5jdGlvbiByZWNvcmRIb3RzcG90RGF0YShyZWZzLCBub3RDb250ZW50RGF0YSkge1xuICAgICAgICB2YXIgbGVuID0gc3RhY2subGVuZ3RoO1xuICAgICAgICBlYWNoKHN0YWNrLCBmdW5jdGlvbiAoYU5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIW5vdENvbnRlbnREYXRhIHx8IGluZGV4ICE9PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgZWFjaChyZWZzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGFOb2RlLmhvdHNwb3QuZGF0YVtyZWZdID0gMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhbmFseXNlQU5vZGVIb3RzcG90KGFOb2RlKSB7XG4gICAgICAgIGlmICghYU5vZGUuaG90c3BvdCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChhTm9kZSk7XG5cblxuICAgICAgICAgICAgaWYgKGFOb2RlLnRleHRFeHByKSB7XG4gICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdCA9IHtkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgcmVjb3JkSG90c3BvdERhdGEoYW5hbHlzZUV4cHJEYXRhSG90c3BvdChhTm9kZS50ZXh0RXhwcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzQnJvd3NlciAmJiBhTm9kZS50YWdOYW1lICYmICEvXih0ZW1wbGF0ZXxzbG90fHNlbGVjdHxpbnB1dHxvcHRpb24pJC9pLnRlc3QoYU5vZGUudGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZSA9IGNyZWF0ZUVsKGFOb2RlLnRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFOb2RlLmhvdHNwb3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB4UHJvcHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vZGU6IHNvdXJjZU5vZGVcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICAvLyA9PT0gYW5hbHlzZSBob3RzcG90IGRhdGE6IHN0YXJ0XG4gICAgICAgICAgICAgICAgZWFjaChhTm9kZS52YXJzLCBmdW5jdGlvbiAodmFySXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRIb3RzcG90RGF0YShhbmFseXNlRXhwckRhdGFIb3RzcG90KHZhckl0ZW0uZXhwcikpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWFjaChhTm9kZS5wcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkSG90c3BvdERhdGEoYW5hbHlzZUV4cHJEYXRhSG90c3BvdChwcm9wLmV4cHIpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhTm9kZS5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSBhTm9kZS5kaXJlY3RpdmVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZEhvdHNwb3REYXRhKGFuYWx5c2VFeHByRGF0YUhvdHNwb3QoZGlyZWN0aXZlLnZhbHVlKSwgIS9eKGh0bWx8YmluZCkkLy50ZXN0KGtleSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXQgdHJhY2tCeSBnZXRLZXkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2ZvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFja0J5ID0gZGlyZWN0aXZlLnRyYWNrQnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tCeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRyYWNrQnkudHlwZSA9PT0gRXhwclR5cGUuQUNDRVNTT1JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0cmFja0J5LnBhdGhzWzBdLnZhbHVlID09PSBkaXJlY3RpdmUuaXRlbS5yYXdcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOb2RlLmhvdHNwb3QuZ2V0Rm9yS2V5ID0gbmV3IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuaXRlbS5yYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm4gJyArIHRyYWNrQnkucmF3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuXG4gICAgICAgICAgICAgICAgZWFjaChhTm9kZS5lbHNlcywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuYWx5c2VBTm9kZUhvdHNwb3QoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWFjaChhTm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuYWx5c2VBTm9kZUhvdHNwb3QoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vID09PSBhbmFseXNlIGhvdHNwb3QgZGF0YTogZW5kXG5cblxuICAgICAgICAgICAgICAgIC8vID09PSBhbmFseXNlIGhvdHNwb3QgcHJvcHM6IHN0YXJ0XG4gICAgICAgICAgICAgICAgZWFjaChhTm9kZS5wcm9wcywgZnVuY3Rpb24gKHByb3AsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFOb2RlLmhvdHNwb3QucHJvcHNbcHJvcC5uYW1lXSA9IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AuaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC5pZFByb3AgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC5keW5hbWljUHJvcHMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wLmV4cHIudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQcm9wSGFuZGxlcihhTm9kZS50YWdOYW1lLCBwcm9wLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKHNvdXJjZU5vZGUsIHByb3AuZXhwci52YWx1ZSwgcHJvcC5uYW1lLCBhTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC54UHJvcHMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFOb2RlLmhvdHNwb3QuZHluYW1pY1Byb3BzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGllIOS4i++8jOWmguaenCBvcHRpb24g5rKh5pyJIHZhbHVlIOWxnuaAp++8jHNlbGVjdC52YWx1ZSA9IHh4IOaTjeS9nOS4jeS8mumAieS4rSBvcHRpb25cbiAgICAgICAgICAgICAgICAvLyDmiYDku6XmsqHmnInorr7nva4gdmFsdWUg5pe277yM6buY6K6k5oqKIG9wdGlvbiDnmoTlhoXlrrnkvZzkuLogdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoYU5vZGUudGFnTmFtZSA9PT0gJ29wdGlvbidcbiAgICAgICAgICAgICAgICAgICAgJiYgIWdldEFOb2RlUHJvcChhTm9kZSwgJ3ZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgJiYgYU5vZGUuY2hpbGRyZW5bMF1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlUHJvcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByOiBhTm9kZS5jaGlsZHJlblswXS50ZXh0RXhwclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhTm9kZS5wcm9wcy5wdXNoKHZhbHVlUHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGFOb2RlLmhvdHNwb3QuZHluYW1pY1Byb3BzLnB1c2godmFsdWVQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC5wcm9wcy52YWx1ZSA9IGFOb2RlLnByb3BzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vID09PSBhbmFseXNlIGhvdHNwb3QgcHJvcHM6IGVuZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFuYWx5c2VBTm9kZUhvdHNwb3QoQ29tcG9uZW50Q2xhc3MucHJvdG90eXBlLmFOb2RlKTtcbn1cblxuLyoqXG4gKiDliIbmnpDooajovr7lvI/nmoTmlbDmja7lvJXnlKhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwciDopoHliIbmnpDnmoTooajovr7lvI9cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBhbmFseXNlRXhwckRhdGFIb3RzcG90KGV4cHIpIHtcbiAgICB2YXIgcmVmcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYW5hbHlzZUV4cHJzKGV4cHJzKSB7XG4gICAgICAgIGVhY2goZXhwcnMsIGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICByZWZzID0gcmVmcy5jb25jYXQoYW5hbHlzZUV4cHJEYXRhSG90c3BvdChleHByKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgIGNhc2UgRXhwclR5cGUuQUNDRVNTT1I6XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBleHByLnBhdGhzO1xuICAgICAgICAgICAgcmVmcy5wdXNoKHBhdGhzWzBdLnZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2gocGF0aHNbMF0udmFsdWUgKyAnLicgKyAocGF0aHNbMV0udmFsdWUgfHwgJyonKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuYWx5c2VFeHBycyhwYXRocy5zbGljZSgxKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEV4cHJUeXBlLlVOQVJZOlxuICAgICAgICAgICAgcmV0dXJuIGFuYWx5c2VFeHByRGF0YUhvdHNwb3QoZXhwci5leHByKTtcblxuICAgICAgICBjYXNlIEV4cHJUeXBlLlRFWFQ6XG4gICAgICAgIGNhc2UgRXhwclR5cGUuQklOQVJZOlxuICAgICAgICBjYXNlIEV4cHJUeXBlLlRFUlRJQVJZOlxuICAgICAgICAgICAgYW5hbHlzZUV4cHJzKGV4cHIuc2Vncyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEV4cHJUeXBlLklOVEVSUDpcbiAgICAgICAgICAgIHJlZnMgPSBhbmFseXNlRXhwckRhdGFIb3RzcG90KGV4cHIuZXhwcik7XG5cbiAgICAgICAgICAgIGVhY2goZXhwci5maWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgYW5hbHlzZUV4cHJzKGZpbHRlci5uYW1lLnBhdGhzKTtcbiAgICAgICAgICAgICAgICBhbmFseXNlRXhwcnMoZmlsdGVyLmFyZ3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudFByZWhlYXQ7XG5cblxuLyoqXG4gKiBAZmlsZSDlsIYgYmluZHMg55qEIG5hbWUg5LuOIGtlYmFiY2FzZSDovazmjaLmiJAgY2FtZWxjYXNlXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIga2ViYWIyY2FtZWwgPSByZXF1aXJlKCcuLi91dGlsL2tlYmFiMmNhbWVsJyk7XG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuXG4vKipcbiAqIOWwhiBiaW5kcyDnmoQgbmFtZSDku44ga2ViYWJjYXNlIOi9rOaNouaIkCBjYW1lbGNhc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBiaW5kcyBiaW5kc+mbhuWQiFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsQ29tcG9uZW50QmluZHMoYmluZHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZWFjaChiaW5kcywgZnVuY3Rpb24gKGJpbmQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2ViYWIyY2FtZWwoYmluZC5uYW1lKSxcbiAgICAgICAgICAgIGV4cHI6IGJpbmQuZXhwcixcbiAgICAgICAgICAgIHg6IGJpbmQueCxcbiAgICAgICAgICAgIHJhdzogYmluZC5yYXdcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjYW1lbENvbXBvbmVudEJpbmRzO1xuXG5cbi8qKlxuICogQGZpbGUg57yW6K+R5rqQ56CB55qEIGhlbHBlciDmlrnms5Xpm4blkIhcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvZXhwci10eXBlJyk7XG5cbi8vICNbYmVnaW5dIHNzclxuLy8gXG4vLyAvKipcbi8vICAqIOe8luivkea6kOeggeeahCBoZWxwZXIg5pa55rOV6ZuG5ZCI5a+56LGhXG4vLyAgKi9cbi8vIHZhciBjb21waWxlRXhwclNvdXJjZSA9IHtcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOWtl+espuS4suWtl+mdouWMllxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSDpnIDopoHlrZfpnaLljJbnmoTlrZfnrKbkuLJcbi8vICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IOWtl+espuS4suWtl+mdouWMlue7k+aenFxuLy8gICAgICAqL1xuLy8gICAgIHN0cmluZ0xpdGVyYWxpemU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbi8vICAgICAgICAgcmV0dXJuICdcIidcbi8vICAgICAgICAgICAgICsgc291cmNlXG4vLyAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xceDVDL2csICdcXFxcXFxcXCcpXG4vLyAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKVxuLy8gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHgwQS9nLCAnXFxcXG4nKVxuLy8gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHgwOS9nLCAnXFxcXHQnKVxuLy8gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHgwRC9nLCAnXFxcXHInKVxuLy8gICAgICAgICAgICAgICAgIC8vIC5yZXBsYWNlKCAvXFx4MDgvZywgJ1xcXFxiJyApXG4vLyAgICAgICAgICAgICAgICAgLy8gLnJlcGxhY2UoIC9cXHgwQy9nLCAnXFxcXGYnIClcbi8vICAgICAgICAgICAgICsgJ1wiJztcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog55Sf5oiQ5pWw5o2u6K6/6Zeu6KGo6L6+5byP5Luj56CBXG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge09iamVjdD99IGFjY2Vzc29yRXhwciBhY2Nlc3NvcuihqOi+vuW8j+WvueixoVxuLy8gICAgICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAgICAgKi9cbi8vICAgICBkYXRhQWNjZXNzOiBmdW5jdGlvbiAoYWNjZXNzb3JFeHByKSB7XG4vLyAgICAgICAgIHZhciBjb2RlID0gJ2NvbXBvbmVudEN0eC5kYXRhJztcbi8vICAgICAgICAgaWYgKGFjY2Vzc29yRXhwcikge1xuLy8gICAgICAgICAgICAgZWFjaChhY2Nlc3NvckV4cHIucGF0aHMsIGZ1bmN0aW9uIChwYXRoKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKHBhdGgudHlwZSA9PT0gRXhwclR5cGUuQUNDRVNTT1IpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgY29kZSArPSAnWycgKyBjb21waWxlRXhwclNvdXJjZS5kYXRhQWNjZXNzKHBhdGgpICsgJ10nO1xuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgcGF0aC52YWx1ZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29kZSArPSAnLicgKyBwYXRoLnZhbHVlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gJ1snICsgcGF0aC52YWx1ZSArICddJztcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIGNvZGU7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOeUn+aIkOaPkuWAvOS7o+eggVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtPYmplY3R9IGludGVycEV4cHIg5o+S5YC86KGo6L6+5byP5a+56LGhXG4vLyAgICAgICogQHJldHVybiB7c3RyaW5nfVxuLy8gICAgICAqL1xuLy8gICAgIGludGVycDogZnVuY3Rpb24gKGludGVycEV4cHIpIHtcbi8vICAgICAgICAgdmFyIGNvZGUgPSBjb21waWxlRXhwclNvdXJjZS5leHByKGludGVycEV4cHIuZXhwcik7XG4vLyBcbi8vIFxuLy8gICAgICAgICBlYWNoKGludGVycEV4cHIuZmlsdGVycywgZnVuY3Rpb24gKGZpbHRlcikge1xuLy8gICAgICAgICAgICAgY29kZSA9ICdjb21wb25lbnRDdHguY2FsbEZpbHRlcihcIicgKyBmaWx0ZXIubmFtZS5wYXRoc1swXS52YWx1ZSArICdcIiwgWycgKyBjb2RlO1xuLy8gICAgICAgICAgICAgZWFjaChmaWx0ZXIuYXJncywgZnVuY3Rpb24gKGFyZykge1xuLy8gICAgICAgICAgICAgICAgIGNvZGUgKz0gJywgJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoYXJnKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgY29kZSArPSAnXSknO1xuLy8gICAgICAgICB9KTtcbi8vIFxuLy8gICAgICAgICBpZiAoIWludGVycEV4cHIub3JpZ2luYWwpIHtcbi8vICAgICAgICAgICAgIHJldHVybiAnZXNjYXBlSFRNTCgnICsgY29kZSArICcpJztcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHJldHVybiBjb2RlO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnlJ/miJDmlofmnKzniYfmrrXku6PnoIFcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0RXhwciDmlofmnKzniYfmrrXooajovr7lvI/lr7nosaFcbi8vICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4vLyAgICAgICovXG4vLyAgICAgdGV4dDogZnVuY3Rpb24gKHRleHRFeHByKSB7XG4vLyAgICAgICAgIGlmICh0ZXh0RXhwci5zZWdzLmxlbmd0aCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuICdcIlwiJztcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHZhciBjb2RlID0gJyc7XG4vLyBcbi8vICAgICAgICAgZWFjaCh0ZXh0RXhwci5zZWdzLCBmdW5jdGlvbiAoc2VnKSB7XG4vLyAgICAgICAgICAgICB2YXIgc2VnQ29kZSA9IGNvbXBpbGVFeHByU291cmNlLmV4cHIoc2VnKTtcbi8vICAgICAgICAgICAgIGNvZGUgKz0gY29kZSA/ICcgKyAnICsgc2VnQ29kZSA6IHNlZ0NvZGU7XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHJldHVybiBjb2RlO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnlJ/miJDmlbDnu4TlrZfpnaLph4/ku6PnoIFcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUV4cHIg5pWw57uE5a2X6Z2i6YeP6KGo6L6+5byP5a+56LGhXG4vLyAgICAgICogQHJldHVybiB7c3RyaW5nfVxuLy8gICAgICAqL1xuLy8gICAgIGFycmF5OiBmdW5jdGlvbiAoYXJyYXlFeHByKSB7XG4vLyAgICAgICAgIHZhciBjb2RlID0gW107XG4vLyBcbi8vICAgICAgICAgZWFjaChhcnJheUV4cHIuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4vLyAgICAgICAgICAgICBjb2RlLnB1c2goKGl0ZW0uc3ByZWFkID8gJy4uLicgOiAnJykgKyBjb21waWxlRXhwclNvdXJjZS5leHByKGl0ZW0uZXhwcikpO1xuLy8gICAgICAgICB9KTtcbi8vIFxuLy8gICAgICAgICByZXR1cm4gJ1tcXG4nICsgY29kZS5qb2luKCcsXFxuJykgKyAnXFxuXSc7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOeUn+aIkOWvueixoeWtl+mdoumHj+S7o+eggVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iakV4cHIg5a+56LGh5a2X6Z2i6YeP6KGo6L6+5byP5a+56LGhXG4vLyAgICAgICogQHJldHVybiB7c3RyaW5nfVxuLy8gICAgICAqL1xuLy8gICAgIG9iamVjdDogZnVuY3Rpb24gKG9iakV4cHIpIHtcbi8vICAgICAgICAgdmFyIGNvZGUgPSBbXTtcbi8vIFxuLy8gICAgICAgICBlYWNoKG9iakV4cHIuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4vLyAgICAgICAgICAgICBpZiAoaXRlbS5zcHJlYWQpIHtcbi8vICAgICAgICAgICAgICAgICBjb2RlLnB1c2goJy4uLicgKyBjb21waWxlRXhwclNvdXJjZS5leHByKGl0ZW0uZXhwcikpO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGNvbXBpbGVFeHByU291cmNlLmV4cHIoaXRlbS5uYW1lKSArICc6JyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoaXRlbS5leHByKSk7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHJldHVybiAne1xcbicgKyBjb2RlLmpvaW4oJyxcXG4nKSArICdcXG59Jztcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog5LqM5YWD6KGo6L6+5byP5pON5L2c56ym5pig5bCE6KGoXG4vLyAgICAgICpcbi8vICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuLy8gICAgICAqL1xuLy8gICAgIGJpbmFyeU9wOiB7XG4vLyAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4vLyAgICAgICAgIDQzOiAnKycsXG4vLyAgICAgICAgIDQ1OiAnLScsXG4vLyAgICAgICAgIDQyOiAnKicsXG4vLyAgICAgICAgIDQ3OiAnLycsXG4vLyAgICAgICAgIDYwOiAnPCcsXG4vLyAgICAgICAgIDYyOiAnPicsXG4vLyAgICAgICAgIDc2OiAnJiYnLFxuLy8gICAgICAgICA5NDogJyE9Jyxcbi8vICAgICAgICAgMTIxOiAnPD0nLFxuLy8gICAgICAgICAxMjI6ICc9PScsXG4vLyAgICAgICAgIDEyMzogJz49Jyxcbi8vICAgICAgICAgMTU1OiAnIT09Jyxcbi8vICAgICAgICAgMTgzOiAnPT09Jyxcbi8vICAgICAgICAgMjQ4OiAnfHwnXG4vLyAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog55Sf5oiQ6KGo6L6+5byP5Luj56CBXG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciDooajovr7lvI/lr7nosaFcbi8vICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4vLyAgICAgICovXG4vLyAgICAgZXhwcjogZnVuY3Rpb24gKGV4cHIpIHtcbi8vICAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuVU5BUlk6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuICchJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoZXhwci5leHByKTtcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5CSU5BUlk6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVFeHByU291cmNlLmV4cHIoZXhwci5zZWdzWzBdKVxuLy8gICAgICAgICAgICAgICAgICAgICArIGNvbXBpbGVFeHByU291cmNlLmJpbmFyeU9wW2V4cHIub3BlcmF0b3JdXG4vLyAgICAgICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihleHByLnNlZ3NbMV0pO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlIEV4cHJUeXBlLlRFUlRJQVJZOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5leHByKGV4cHIuc2Vnc1swXSlcbi8vICAgICAgICAgICAgICAgICAgICAgKyAnPycgKyBjb21waWxlRXhwclNvdXJjZS5leHByKGV4cHIuc2Vnc1sxXSlcbi8vICAgICAgICAgICAgICAgICAgICAgKyAnOicgKyBjb21waWxlRXhwclNvdXJjZS5leHByKGV4cHIuc2Vnc1syXSk7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuU1RSSU5HOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5zdHJpbmdMaXRlcmFsaXplKGV4cHIubGl0ZXJhbCB8fCBleHByLnZhbHVlKTtcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5OVU1CRVI6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWU7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuQk9PTDpcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuQUNDRVNTT1I6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVFeHByU291cmNlLmRhdGFBY2Nlc3MoZXhwcik7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuSU5URVJQOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5pbnRlcnAoZXhwcik7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuVEVYVDpcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZUV4cHJTb3VyY2UudGV4dChleHByKTtcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5BUlJBWTpcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZUV4cHJTb3VyY2UuYXJyYXkoZXhwcik7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuT0JKRUNUOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5vYmplY3QoZXhwcik7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9O1xuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVFeHByU291cmNlO1xuXG5cbi8qKlxuICogQGZpbGUg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVy57G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGNvbXBpbGVFeHByU291cmNlID0gcmVxdWlyZSgnLi9jb21waWxlLWV4cHItc291cmNlJyk7XG5cblxuLy8gI1tiZWdpbl0gc3NyXG4vLyAvKipcbi8vICAqIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlcuexu1xuLy8gICpcbi8vICAqIEBjbGFzc1xuLy8gICovXG4vLyBmdW5jdGlvbiBDb21waWxlU291cmNlQnVmZmVyKCkge1xuLy8gICAgIHRoaXMuc2VncyA9IFtdO1xuLy8gfVxuLy8gXG4vLyAvKipcbi8vICAqIOa3u+WKoOWOn+Wni+S7o+egge+8jOWwhuWOn+WwgeS4jeWKqOi+k+WHulxuLy8gICpcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIOWOn+Wni+S7o+eggVxuLy8gICovXG4vLyBDb21waWxlU291cmNlQnVmZmVyLnByb3RvdHlwZS5hZGRSYXcgPSBmdW5jdGlvbiAoY29kZSkge1xuLy8gICAgIHRoaXMuc2Vncy5wdXNoKHtcbi8vICAgICAgICAgdHlwZTogJ1JBVycsXG4vLyAgICAgICAgIGNvZGU6IGNvZGVcbi8vICAgICB9KTtcbi8vIH07XG4vLyBcbi8vIC8qKlxuLy8gICog5re75Yqg6KKr5ou85o6l5Li6aHRtbOeahOWOn+Wni+S7o+eggVxuLy8gICpcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIOWOn+Wni+S7o+eggVxuLy8gICovXG4vLyBDb21waWxlU291cmNlQnVmZmVyLnByb3RvdHlwZS5qb2luUmF3ID0gZnVuY3Rpb24gKGNvZGUpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIHR5cGU6ICdKT0lOX1JBVycsXG4vLyAgICAgICAgIGNvZGU6IGNvZGVcbi8vICAgICB9KTtcbi8vIH07XG4vLyBcbi8vIC8qKlxuLy8gICog5re75YqgcmVuZGVyZXLmlrnms5XnmoTotbflp4vmupDnoIFcbi8vICAqL1xuLy8gQ29tcGlsZVNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYWRkUmVuZGVyZXJTdGFydCA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICB0aGlzLmFkZFJhdygnZnVuY3Rpb24gKGRhdGEsIHBhcmVudEN0eCwgZ2l2ZW5TbG90cykgeycpO1xuLy8gICAgIHRoaXMuYWRkUmF3KCd2YXIgaHRtbCA9IFwiXCI7Jyk7XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOa3u+WKoHJlbmRlcmVy5pa55rOV55qE57uT5p2f5rqQ56CBXG4vLyAgKi9cbi8vIENvbXBpbGVTb3VyY2VCdWZmZXIucHJvdG90eXBlLmFkZFJlbmRlcmVyRW5kID0gZnVuY3Rpb24gKCkge1xuLy8gICAgIHRoaXMuYWRkUmF3KCdyZXR1cm4gaHRtbDsnKTtcbi8vICAgICB0aGlzLmFkZFJhdygnfScpO1xuLy8gfTtcbi8vIFxuLy8gLyoqXG4vLyAgKiDmt7vliqDooqvmi7zmjqXkuLpodG1s55qE6Z2Z5oCB5a2X56ym5LiyXG4vLyAgKlxuLy8gICogQHBhcmFtIHtzdHJpbmd9IHN0ciDooqvmi7zmjqXnmoTlrZfnrKbkuLJcbi8vICAqL1xuLy8gQ29tcGlsZVNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuam9pblN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIHN0cjogc3RyLFxuLy8gICAgICAgICB0eXBlOiAnSk9JTl9TVFJJTkcnXG4vLyAgICAgfSk7XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOa3u+WKoOiiq+aLvOaOpeS4umh0bWznmoTmlbDmja7orr/pl65cbi8vICAqXG4vLyAgKiBAcGFyYW0ge09iamVjdD99IGFjY2Vzc29yIOaVsOaNruiuv+mXruihqOi+vuW8j+WvueixoVxuLy8gICovXG4vLyBDb21waWxlU291cmNlQnVmZmVyLnByb3RvdHlwZS5qb2luRGF0YVN0cmluZ2lmeSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIHR5cGU6ICdKT0lOX0RBVEFfU1RSSU5HSUZZJ1xuLy8gICAgIH0pO1xuLy8gfTtcbi8vIFxuLy8gLyoqXG4vLyAgKiDmt7vliqDooqvmi7zmjqXkuLpodG1s55qE6KGo6L6+5byPXG4vLyAgKlxuLy8gICogQHBhcmFtIHtPYmplY3R9IGV4cHIg6KGo6L6+5byP5a+56LGhXG4vLyAgKi9cbi8vIENvbXBpbGVTb3VyY2VCdWZmZXIucHJvdG90eXBlLmpvaW5FeHByID0gZnVuY3Rpb24gKGV4cHIpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIGV4cHI6IGV4cHIsXG4vLyAgICAgICAgIHR5cGU6ICdKT0lOX0VYUFInXG4vLyAgICAgfSk7XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkOe8luivkeWQjuS7o+eggVxuLy8gICpcbi8vICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAqL1xuLy8gQ29tcGlsZVNvdXJjZUJ1ZmZlci5wcm90b3R5cGUudG9Db2RlID0gZnVuY3Rpb24gKCkge1xuLy8gICAgIHZhciBjb2RlID0gW107XG4vLyAgICAgdmFyIHRlbXAgPSAnJztcbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGdlblN0ckxpdGVyYWwoKSB7XG4vLyAgICAgICAgIGlmICh0ZW1wKSB7XG4vLyAgICAgICAgICAgICBjb2RlLnB1c2goJ2h0bWwgKz0gJyArIGNvbXBpbGVFeHByU291cmNlLnN0cmluZ0xpdGVyYWxpemUodGVtcCkgKyAnOycpO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdGVtcCA9ICcnO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGVhY2godGhpcy5zZWdzLCBmdW5jdGlvbiAoc2VnKSB7XG4vLyAgICAgICAgIGlmIChzZWcudHlwZSA9PT0gJ0pPSU5fU1RSSU5HJykge1xuLy8gICAgICAgICAgICAgdGVtcCArPSBzZWcuc3RyO1xuLy8gICAgICAgICAgICAgcmV0dXJuO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgZ2VuU3RyTGl0ZXJhbCgpO1xuLy8gICAgICAgICBzd2l0Y2ggKHNlZy50eXBlKSB7XG4vLyAgICAgICAgICAgICBjYXNlICdKT0lOX0RBVEFfU1RSSU5HSUZZJzpcbi8vICAgICAgICAgICAgICAgICBjb2RlLnB1c2goJ2h0bWwgKz0gc3RyaW5naWZpZXIuYW55KCcgKyBjb21waWxlRXhwclNvdXJjZS5kYXRhQWNjZXNzKCkgKyAnKTsnKTtcbi8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSAnSk9JTl9FWFBSJzpcbi8vICAgICAgICAgICAgICAgICBjb2RlLnB1c2goJ2h0bWwgKz0gJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoc2VnLmV4cHIpICsgJzsnKTtcbi8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSAnSk9JTl9SQVcnOlxuLy8gICAgICAgICAgICAgICAgIGNvZGUucHVzaCgnaHRtbCArPSAnICsgc2VnLmNvZGUgKyAnOycpO1xuLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlICdSQVcnOlxuLy8gICAgICAgICAgICAgICAgIGNvZGUucHVzaChzZWcuY29kZSk7XG4vLyAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyBcbi8vICAgICAgICAgfVxuLy8gICAgIH0pO1xuLy8gXG4vLyAgICAgZ2VuU3RyTGl0ZXJhbCgpO1xuLy8gXG4vLyAgICAgcmV0dXJuIGNvZGUuam9pbignXFxuJyk7XG4vLyB9O1xuLy8gXG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29tcGlsZVNvdXJjZUJ1ZmZlcjtcblxuXG4vKipcbiAqIEBmaWxlIOWwhue7hOS7tue8luivkeaIkCByZW5kZXIg5pa55rOV55qEIGpzIOa6kOeggVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGd1aWQgPSByZXF1aXJlKCcuLi91dGlsL2d1aWQnKTtcbi8vIHZhciBwYXJzZUV4cHIgPSByZXF1aXJlKCcuLi9wYXJzZXIvcGFyc2UtZXhwcicpO1xuLy8gdmFyIGNyZWF0ZUFOb2RlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2NyZWF0ZS1hLW5vZGUnKTtcbi8vIHZhciBjbG9uZURpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9wYXJzZXIvY2xvbmUtZGlyZWN0aXZlcycpO1xuLy8gdmFyIGF1dG9DbG9zZVRhZ3MgPSByZXF1aXJlKCcuLi9icm93c2VyL2F1dG8tY2xvc2UtdGFncycpO1xuLy8gdmFyIENvbXBpbGVTb3VyY2VCdWZmZXIgPSByZXF1aXJlKCcuL2NvbXBpbGUtc291cmNlLWJ1ZmZlcicpO1xuLy8gdmFyIGNvbXBpbGVFeHByU291cmNlID0gcmVxdWlyZSgnLi9jb21waWxlLWV4cHItc291cmNlJyk7XG4vLyB2YXIgcmluc2VDb25kQU5vZGUgPSByZXF1aXJlKCcuL3JpbnNlLWNvbmQtYW5vZGUnKTtcbi8vIHZhciBnZXRBTm9kZVByb3AgPSByZXF1aXJlKCcuL2dldC1hLW5vZGUtcHJvcCcpO1xuXG4vLyAjW2JlZ2luXSBzc3Jcbi8vIFxuLy8gLyoqXG4vLyAgKiDnlJ/miJDluo/liJfljJbml7botbflp4vmoannmoRodG1sXG4vLyAgKlxuLy8gICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5qGp57G75Z6L5qCH6K+GXG4vLyAgKiBAcGFyYW0ge3N0cmluZz99IGNvbnRlbnQg5qGp5YaF55qE5YaF5a65XG4vLyAgKiBAcmV0dXJuIHtzdHJpbmd9XG4vLyAgKi9cbi8vIGZ1bmN0aW9uIHNlcmlhbGl6ZVN0dW1wKHR5cGUsIGNvbnRlbnQpIHtcbi8vICAgICByZXR1cm4gJzwhLS1zLScgKyB0eXBlICsgKGNvbnRlbnQgPyAnOicgKyBjb250ZW50IDogJycpICsgJy0tPic7XG4vLyB9XG4vLyBcbi8vIC8qKlxuLy8gICog55Sf5oiQ5bqP5YiX5YyW5pe257uT5p2f5qGp55qEaHRtbFxuLy8gICpcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOahqeexu+Wei+agh+ivhlxuLy8gICogQHJldHVybiB7c3RyaW5nfVxuLy8gICovXG4vLyBmdW5jdGlvbiBzZXJpYWxpemVTdHVtcEVuZCh0eXBlKSB7XG4vLyAgICAgcmV0dXJuICc8IS0tL3MtJyArIHR5cGUgKyAnLS0+Jztcbi8vIH1cbi8vIFxuLy8gLyoqXG4vLyAgKiBlbGVtZW50IOeahOe8luivkeaWueazlembhuWQiOWvueixoVxuLy8gICpcbi8vICAqIEBpbm5lclxuLy8gICovXG4vLyB2YXIgZWxlbWVudFNvdXJjZUNvbXBpbGVyID0ge1xuLy8gXG4vLyAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LXBhcmFtcyAqL1xuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkeWFg+e0oOagh+etvuWktFxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUg5qCH562+5ZCNXG4vLyAgICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMg5bGe5oCn5YiX6KGoXG4vLyAgICAgICogQHBhcmFtIHtzdHJpbmc/fSBleHRyYVByb3Ag6aKd5aSW55qE5bGe5oCn5LiyXG4vLyAgICAgICovXG4vLyAgICAgdGFnU3RhcnQ6IGZ1bmN0aW9uIChzb3VyY2VCdWZmZXIsIHRhZ05hbWUsIHByb3BzLCBleHRyYVByb3AsIGJpbmREaXJlY3RpdmUpIHtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoJzwnICsgdGFnTmFtZSk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKGV4dHJhUHJvcCB8fCAnJyk7XG4vLyBcbi8vICAgICAgICAgLy8gaW5kZXggbGlzdFxuLy8gICAgICAgICB2YXIgcHJvcHNJbmRleCA9IHt9O1xuLy8gICAgICAgICBlYWNoKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuLy8gICAgICAgICAgICAgcHJvcHNJbmRleFtwcm9wLm5hbWVdID0gcHJvcDtcbi8vICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgZWFjaChwcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcbi8vICAgICAgICAgICAgIGlmIChwcm9wLm5hbWUgPT09ICdzbG90Jykge1xuLy8gICAgICAgICAgICAgICAgIHJldHVybjtcbi8vICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgaWYgKHByb3AubmFtZSA9PT0gJ3ZhbHVlJykge1xuLy8gICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnTmFtZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0Jzpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyRzZWxlY3RWYWx1ZSA9ICdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGNvbXBpbGVFeHByU291cmNlLmV4cHIocHJvcC5leHByKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJyB8fCBcIlwiOydcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9uJzpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyRvcHRpb25WYWx1ZSA9ICdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGNvbXBpbGVFeHByU291cmNlLmV4cHIocHJvcC5leHByKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJzsnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2lmICgkb3B0aW9uVmFsdWUgIT0gbnVsbCkgeycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5SYXcoJ1wiIHZhbHVlPVxcXFxcIlwiICsgJG9wdGlvblZhbHVlICsgXCJcXFxcXCJcIicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RlZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnaWYgKCRvcHRpb25WYWx1ZSA9PT0gJHNlbGVjdFZhbHVlKSB7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnIHNlbGVjdGVkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICBzd2l0Y2ggKHByb3AubmFtZSkge1xuLy8gICAgICAgICAgICAgICAgIGNhc2UgJ3JlYWRvbmx5Jzpcbi8vICAgICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlZCc6XG4vLyAgICAgICAgICAgICAgICAgY2FzZSAnbXVsdGlwbGUnOlxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5yYXcgPT09ICcnKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnICcgKyBwcm9wLm5hbWUpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5SYXcoJ2Jvb2xBdHRyRmlsdGVyKFwiJyArIHByb3AubmFtZSArICdcIiwgJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihwcm9wLmV4cHIpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnKSdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVByb3AgPSBwcm9wc0luZGV4LnZhbHVlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlQ29kZSA9IGNvbXBpbGVFeHByU291cmNlLmV4cHIodmFsdWVQcm9wLmV4cHIpO1xuLy8gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVQcm9wKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wc0luZGV4LnR5cGUucmF3KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94Jzpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2lmIChjb250YWlucygnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjb21waWxlRXhwclNvdXJjZS5leHByKHByb3AuZXhwcilcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcsICdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHZhbHVlQ29kZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJykpIHsnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoJyBjaGVja2VkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdpZiAoJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihwcm9wLmV4cHIpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnID09PSAnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyB2YWx1ZUNvZGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcpIHsnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoJyBjaGVja2VkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5hdHRyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnICcgKyBwcm9wLmF0dHIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5SYXcoJ2F0dHJGaWx0ZXIoXCInICsgcHJvcC5uYW1lICsgJ1wiLCAnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAocHJvcC54ID8gJ2VzY2FwZUhUTUwoJyA6ICcnKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihwcm9wLmV4cHIpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAocHJvcC54ID8gJyknIDogJycpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnKSdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIGlmIChiaW5kRGlyZWN0aXZlKSB7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KFxuLy8gICAgICAgICAgICAgICAgICcoZnVuY3Rpb24gKCRiaW5kT2JqKSB7Zm9yICh2YXIgJGtleSBpbiAkYmluZE9iaikgeydcbi8vICAgICAgICAgICAgICAgICArICd2YXIgJHZhbHVlID0gJGJpbmRPYmpbJGtleV07J1xuLy8gICAgICAgICAgICAgKTtcbi8vIFxuLy8gICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICd0ZXh0YXJlYScpIHtcbi8vICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KFxuLy8gICAgICAgICAgICAgICAgICAgICAnaWYgKCRrZXkgPT09IFwidmFsdWVcIikgeydcbi8vICAgICAgICAgICAgICAgICAgICAgKyAnY29udGludWU7J1xuLy8gICAgICAgICAgICAgICAgICAgICArICd9J1xuLy8gICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ3N3aXRjaCAoJGtleSkge1xcbidcbi8vICAgICAgICAgICAgICAgICArICdjYXNlIFwicmVhZG9ubHlcIjpcXG4nXG4vLyAgICAgICAgICAgICAgICAgKyAnY2FzZSBcImRpc2FibGVkXCI6XFxuJ1xuLy8gICAgICAgICAgICAgICAgICsgJ2Nhc2UgXCJtdWx0aXBsZVwiOlxcbidcbi8vICAgICAgICAgICAgICAgICArICdjYXNlIFwibXVsdGlwbGVcIjpcXG4nXG4vLyAgICAgICAgICAgICAgICAgKyAnaHRtbCArPSBib29sQXR0ckZpbHRlcigka2V5LCBlc2NhcGVIVE1MKCR2YWx1ZSkpO1xcbidcbi8vICAgICAgICAgICAgICAgICArICdicmVhaztcXG4nXG4vLyAgICAgICAgICAgICAgICAgKyAnZGVmYXVsdDpcXG4nXG4vLyAgICAgICAgICAgICAgICAgKyAnaHRtbCArPSBhdHRyRmlsdGVyKCRrZXksIGVzY2FwZUhUTUwoJHZhbHVlKSk7J1xuLy8gICAgICAgICAgICAgICAgICsgJ30nXG4vLyAgICAgICAgICAgICApO1xuLy8gXG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KFxuLy8gICAgICAgICAgICAgICAgICd9fSkoJ1xuLy8gICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihiaW5kRGlyZWN0aXZlLnZhbHVlKVxuLy8gICAgICAgICAgICAgICAgICsgJyk7J1xuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKCc+Jyk7XG4vLyAgICAgfSxcbi8vICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1wYXJhbXMgKi9cbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkeWFg+e0oOmXreWQiFxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUg5qCH562+5ZCNXG4vLyAgICAgICovXG4vLyAgICAgdGFnRW5kOiBmdW5jdGlvbiAoc291cmNlQnVmZmVyLCB0YWdOYW1lKSB7XG4vLyAgICAgICAgIGlmICghYXV0b0Nsb3NlVGFnc1t0YWdOYW1lXSkge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoJzwvJyArIHRhZ05hbWUgKyAnPicpO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdzZWxlY3QnKSB7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCckc2VsZWN0VmFsdWUgPSBudWxsOycpO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCckb3B0aW9uVmFsdWUgPSBudWxsOycpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkeWFg+e0oOWGheWuuVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg5YWD57Sg55qE5oq96LGh6IqC54K55L+h5oGvXG4vLyAgICAgICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tuWunuS+i+eOr+Wig1xuLy8gICAgICAqL1xuLy8gICAgIGlubmVyOiBmdW5jdGlvbiAoc291cmNlQnVmZmVyLCBhTm9kZSwgb3duZXIpIHtcbi8vICAgICAgICAgLy8gaW5uZXIgY29udGVudFxuLy8gICAgICAgICBpZiAoYU5vZGUudGFnTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuLy8gICAgICAgICAgICAgdmFyIHZhbHVlUHJvcCA9IGdldEFOb2RlUHJvcChhTm9kZSwgJ3ZhbHVlJyk7XG4vLyAgICAgICAgICAgICBpZiAodmFsdWVQcm9wKSB7XG4vLyAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5SYXcoJ2VzY2FwZUhUTUwoJ1xuLy8gICAgICAgICAgICAgICAgICAgICArIGNvbXBpbGVFeHByU291cmNlLmV4cHIodmFsdWVQcm9wLmV4cHIpXG4vLyAgICAgICAgICAgICAgICAgICAgICsgJyknXG4vLyAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgcmV0dXJuO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdmFyIGh0bWxEaXJlY3RpdmUgPSBhTm9kZS5kaXJlY3RpdmVzLmh0bWw7XG4vLyAgICAgICAgIGlmIChodG1sRGlyZWN0aXZlKSB7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pbkV4cHIoaHRtbERpcmVjdGl2ZS52YWx1ZSk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuLy8gICAgICAgICAgICAgZWFjaChhTm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGFOb2RlQ2hpbGQpIHtcbi8vICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KGFOb2RlQ29tcGlsZXIuY29tcGlsZShhTm9kZUNoaWxkLCBzb3VyY2VCdWZmZXIsIG93bmVyKSk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vIH07XG4vLyBcbi8vIC8qKlxuLy8gICogQU5vZGUg55qE57yW6K+R5pa55rOV6ZuG5ZCI5a+56LGhXG4vLyAgKlxuLy8gICogQGlubmVyXG4vLyAgKi9cbi8vIHZhciBhTm9kZUNvbXBpbGVyID0ge1xuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog57yW6K+R6IqC54K5XG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDmir3osaHoioLngrlcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTb3VyY2VCdWZmZXJ9IHNvdXJjZUJ1ZmZlciDnvJbor5HmupDnoIHnmoTkuK3pl7RidWZmZXJcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu25a6e5L6L546v5aKDXG4vLyAgICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIOe8luivkeaJgOmcgOeahOS4gOS6m+mineWkluS/oeaBr1xuLy8gICAgICAqL1xuLy8gICAgIGNvbXBpbGU6IGZ1bmN0aW9uIChhTm9kZSwgc291cmNlQnVmZmVyLCBvd25lciwgZXh0cmEpIHtcbi8vICAgICAgICAgZXh0cmEgPSBleHRyYSB8fCB7fTtcbi8vICAgICAgICAgdmFyIGNvbXBpbGVNZXRob2QgPSAnY29tcGlsZUVsZW1lbnQnO1xuLy8gXG4vLyAgICAgICAgIGlmIChhTm9kZS50ZXh0RXhwcikge1xuLy8gICAgICAgICAgICAgY29tcGlsZU1ldGhvZCA9ICdjb21waWxlVGV4dCc7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgZWxzZSBpZiAoYU5vZGUuZGlyZWN0aXZlc1snaWYnXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuLy8gICAgICAgICAgICAgY29tcGlsZU1ldGhvZCA9ICdjb21waWxlSWYnO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2UgaWYgKGFOb2RlLmRpcmVjdGl2ZXNbJ2ZvciddKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4vLyAgICAgICAgICAgICBjb21waWxlTWV0aG9kID0gJ2NvbXBpbGVGb3InO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2UgaWYgKGFOb2RlLnRhZ05hbWUgPT09ICdzbG90Jykge1xuLy8gICAgICAgICAgICAgY29tcGlsZU1ldGhvZCA9ICdjb21waWxlU2xvdCc7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgZWxzZSBpZiAoYU5vZGUudGFnTmFtZSA9PT0gJ3RlbXBsYXRlJykge1xuLy8gICAgICAgICAgICAgY29tcGlsZU1ldGhvZCA9ICdjb21waWxlVGVtcGxhdGUnO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgdmFyIENvbXBvbmVudFR5cGUgPSBvd25lci5nZXRDb21wb25lbnRUeXBlXG4vLyAgICAgICAgICAgICAgICAgPyBvd25lci5nZXRDb21wb25lbnRUeXBlKGFOb2RlKVxuLy8gICAgICAgICAgICAgICAgIDogb3duZXIuY29tcG9uZW50c1thTm9kZS50YWdOYW1lXTtcbi8vICAgICAgICAgICAgIGlmIChDb21wb25lbnRUeXBlKSB7XG4vLyAgICAgICAgICAgICAgICAgY29tcGlsZU1ldGhvZCA9ICdjb21waWxlQ29tcG9uZW50Jztcbi8vICAgICAgICAgICAgICAgICBleHRyYS5Db21wb25lbnRDbGFzcyA9IENvbXBvbmVudFR5cGU7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICBhTm9kZUNvbXBpbGVyW2NvbXBpbGVNZXRob2RdKGFOb2RlLCBzb3VyY2VCdWZmZXIsIG93bmVyLCBleHRyYSk7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkeaWh+acrOiKgueCuVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg6IqC54K55a+56LGhXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICovXG4vLyAgICAgY29tcGlsZVRleHQ6IGZ1bmN0aW9uIChhTm9kZSwgc291cmNlQnVmZmVyKSB7XG4vLyAgICAgICAgIGlmIChhTm9kZS50ZXh0RXhwci5vcmlnaW5hbCkge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoc2VyaWFsaXplU3R1bXAoJ3RleHQnKSk7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuam9pbkV4cHIoYU5vZGUudGV4dEV4cHIpO1xuLy8gXG4vLyAgICAgICAgIGlmIChhTm9kZS50ZXh0RXhwci5vcmlnaW5hbCkge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoc2VyaWFsaXplU3R1bXBFbmQoJ3RleHQnKSk7XG4vLyAgICAgICAgIH1cbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog57yW6K+RdGVtcGxhdGXoioLngrlcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOiKgueCueWvueixoVxuLy8gICAgICAqIEBwYXJhbSB7Q29tcGlsZVNvdXJjZUJ1ZmZlcn0gc291cmNlQnVmZmVyIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlclxuLy8gICAgICAqIEBwYXJhbSB7Q29tcG9uZW50fSBvd25lciDmiYDlsZ7nu4Tku7blrp7kvovnjq/looNcbi8vICAgICAgKi9cbi8vICAgICBjb21waWxlVGVtcGxhdGU6IGZ1bmN0aW9uIChhTm9kZSwgc291cmNlQnVmZmVyLCBvd25lcikge1xuLy8gICAgICAgICBlbGVtZW50U291cmNlQ29tcGlsZXIuaW5uZXIoc291cmNlQnVmZmVyLCBhTm9kZSwgb3duZXIpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnvJbor5EgaWYg6IqC54K5XG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDoioLngrnlr7nosaFcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTb3VyY2VCdWZmZXJ9IHNvdXJjZUJ1ZmZlciDnvJbor5HmupDnoIHnmoTkuK3pl7RidWZmZXJcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu25a6e5L6L546v5aKDXG4vLyAgICAgICovXG4vLyAgICAgY29tcGlsZUlmOiBmdW5jdGlvbiAoYU5vZGUsIHNvdXJjZUJ1ZmZlciwgb3duZXIpIHtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnKGZ1bmN0aW9uICgpIHsnKTtcbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd2YXIgaWZJbmRleCA9IG51bGw7Jyk7XG4vLyBcbi8vICAgICAgICAgLy8gb3V0cHV0IG1haW4gaWZcbi8vICAgICAgICAgdmFyIGlmRGlyZWN0aXZlID0gYU5vZGUuZGlyZWN0aXZlc1snaWYnXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnaWYgKCcgKyBjb21waWxlRXhwclNvdXJjZS5leHByKGlmRGlyZWN0aXZlLnZhbHVlKSArICcpIHsnKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdyhcbi8vICAgICAgICAgICAgIGFOb2RlQ29tcGlsZXIuY29tcGlsZShcbi8vICAgICAgICAgICAgICAgICByaW5zZUNvbmRBTm9kZShhTm9kZSksXG4vLyAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLFxuLy8gICAgICAgICAgICAgICAgIG93bmVyXG4vLyAgICAgICAgICAgICApXG4vLyAgICAgICAgICk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30nKTtcbi8vIFxuLy8gICAgICAgICAvLyBvdXRwdXQgZWxpZiBhbmQgZWxzZVxuLy8gICAgICAgICBlYWNoKGFOb2RlLmVsc2VzLCBmdW5jdGlvbiAoZWxzZUFOb2RlLCBpbmRleCkge1xuLy8gICAgICAgICAgICAgdmFyIGVsaWZEaXJlY3RpdmUgPSBlbHNlQU5vZGUuZGlyZWN0aXZlcy5lbGlmO1xuLy8gICAgICAgICAgICAgaWYgKGVsaWZEaXJlY3RpdmUpIHtcbi8vICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdlbHNlIGlmICgnICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihlbGlmRGlyZWN0aXZlLnZhbHVlKSArICcpIHsnKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2Vsc2UgeycpO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KFxuLy8gICAgICAgICAgICAgICAgIGFOb2RlQ29tcGlsZXIuY29tcGlsZShcbi8vICAgICAgICAgICAgICAgICAgICAgcmluc2VDb25kQU5vZGUoZWxzZUFOb2RlKSxcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLFxuLy8gICAgICAgICAgICAgICAgICAgICBvd25lclxuLy8gICAgICAgICAgICAgICAgIClcbi8vICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30pKCk7Jyk7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkSBmb3Ig6IqC54K5XG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDoioLngrnlr7nosaFcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTb3VyY2VCdWZmZXJ9IHNvdXJjZUJ1ZmZlciDnvJbor5HmupDnoIHnmoTkuK3pl7RidWZmZXJcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu25a6e5L6L546v5aKDXG4vLyAgICAgICovXG4vLyAgICAgY29tcGlsZUZvcjogZnVuY3Rpb24gKGFOb2RlLCBzb3VyY2VCdWZmZXIsIG93bmVyKSB7XG4vLyAgICAgICAgIHZhciBmb3JFbGVtZW50QU5vZGUgPSBjcmVhdGVBTm9kZSh7XG4vLyAgICAgICAgICAgICBjaGlsZHJlbjogYU5vZGUuY2hpbGRyZW4sXG4vLyAgICAgICAgICAgICBwcm9wczogYU5vZGUucHJvcHMsXG4vLyAgICAgICAgICAgICBldmVudHM6IGFOb2RlLmV2ZW50cyxcbi8vICAgICAgICAgICAgIHRhZ05hbWU6IGFOb2RlLnRhZ05hbWUsXG4vLyAgICAgICAgICAgICBkaXJlY3RpdmVzOiBjbG9uZURpcmVjdGl2ZXMoYU5vZGUuZGlyZWN0aXZlcywge1xuLy8gICAgICAgICAgICAgICAgICdmb3InOiAxXG4vLyAgICAgICAgICAgICB9KSxcbi8vICAgICAgICAgICAgIGhvdHNwb3Q6IGFOb2RlLmhvdHNwb3Rcbi8vICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgdmFyIGZvckRpcmVjdGl2ZSA9IGFOb2RlLmRpcmVjdGl2ZXNbJ2ZvciddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuLy8gICAgICAgICB2YXIgaXRlbU5hbWUgPSBmb3JEaXJlY3RpdmUuaXRlbS5yYXc7XG4vLyAgICAgICAgIHZhciBpbmRleE5hbWUgPSBmb3JEaXJlY3RpdmUuaW5kZXgucmF3O1xuLy8gICAgICAgICB2YXIgbGlzdE5hbWUgPSBndWlkKCk7XG4vLyBcbi8vICAgICAgICAgaWYgKGluZGV4TmFtZSA9PT0gJyRpbmRleCcpIHtcbi8vICAgICAgICAgICAgIGluZGV4TmFtZSA9IGd1aWQoKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ3ZhciAnICsgbGlzdE5hbWUgKyAnID0gJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoZm9yRGlyZWN0aXZlLnZhbHVlKSArICc7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2ZvciAoJ1xuLy8gICAgICAgICAgICAgKyAndmFyICcgKyBpbmRleE5hbWUgKyAnID0gMDsgJ1xuLy8gICAgICAgICAgICAgKyBpbmRleE5hbWUgKyAnIDwgJyArIGxpc3ROYW1lICsgJy5sZW5ndGg7ICdcbi8vICAgICAgICAgICAgICsgaW5kZXhOYW1lICsgJysrKSB7J1xuLy8gICAgICAgICApO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdjb21wb25lbnRDdHguZGF0YS4nICsgaW5kZXhOYW1lICsgJz0nICsgaW5kZXhOYW1lICsgJzsnKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnY29tcG9uZW50Q3R4LmRhdGEuJyArIGl0ZW1OYW1lICsgJz0gJyArIGxpc3ROYW1lICsgJ1snICsgaW5kZXhOYW1lICsgJ107Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoXG4vLyAgICAgICAgICAgICBhTm9kZUNvbXBpbGVyLmNvbXBpbGUoXG4vLyAgICAgICAgICAgICAgICAgZm9yRWxlbWVudEFOb2RlLFxuLy8gICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlcixcbi8vICAgICAgICAgICAgICAgICBvd25lclxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICApO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkSBzbG90IOiKgueCuVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg6IqC54K55a+56LGhXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tuWunuS+i+eOr+Wig1xuLy8gICAgICAqL1xuLy8gICAgIGNvbXBpbGVTbG90OiBmdW5jdGlvbiAoYU5vZGUsIHNvdXJjZUJ1ZmZlciwgb3duZXIpIHtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnKGZ1bmN0aW9uICgpIHsnKTtcbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdmdW5jdGlvbiAkZGVmYXVsdFNsb3RSZW5kZXIoY29tcG9uZW50Q3R4KSB7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgdmFyIGh0bWwgPSBcIlwiOycpO1xuLy8gICAgICAgICBlYWNoKGFOb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoYU5vZGVDaGlsZCkge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdyhhTm9kZUNvbXBpbGVyLmNvbXBpbGUoYU5vZGVDaGlsZCwgc291cmNlQnVmZmVyLCBvd25lcikpO1xuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICByZXR1cm4gaHRtbDsnKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgdmFyICRnaXZlblNsb3QgPSBbXTsnKTtcbi8vIFxuLy8gICAgICAgICB2YXIgbmFtZVByb3AgPSBnZXRBTm9kZVByb3AoYU5vZGUsICduYW1lJyk7XG4vLyAgICAgICAgIGlmIChuYW1lUHJvcCkge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygndmFyICRzbG90TmFtZSA9ICcgKyBjb21waWxlRXhwclNvdXJjZS5leHByKG5hbWVQcm9wLmV4cHIpICsgJzsnKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ3ZhciAkc2xvdE5hbWUgPSBudWxsOycpO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygndmFyICRjdHhHaXZlblNsb3RzID0gY29tcG9uZW50Q3R4LmdpdmVuU2xvdHM7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2ZvciAodmFyICRpID0gMDsgJGkgPCAkY3R4R2l2ZW5TbG90cy5sZW5ndGg7ICRpKyspIHsnKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICBpZiAoJGN0eEdpdmVuU2xvdHNbJGldWzFdID09ICRzbG90TmFtZSkgeycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCcgICAgJGdpdmVuU2xvdC5wdXNoKCRjdHhHaXZlblNsb3RzWyRpXVswXSk7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgfScpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyBcbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd2YXIgJGlzSW5zZXJ0ZWQgPSAkZ2l2ZW5TbG90Lmxlbmd0aCA+IDA7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2lmICghJGlzSW5zZXJ0ZWQpIHsgJGdpdmVuU2xvdC5wdXNoKCRkZWZhdWx0U2xvdFJlbmRlcik7IH0nKTtcbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd2YXIgJHNsb3RDdHggPSAkaXNJbnNlcnRlZCA/IGNvbXBvbmVudEN0eC5vd25lciA6IGNvbXBvbmVudEN0eDsnKTtcbi8vIFxuLy8gICAgICAgICBpZiAoYU5vZGUudmFycyB8fCBhTm9kZS5kaXJlY3RpdmVzLmJpbmQpIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyRzbG90Q3R4ID0ge2RhdGE6IGV4dGVuZCh7fSwgJHNsb3RDdHguZGF0YSksIGZpbHRlcnM6ICRzbG90Q3R4LmZpbHRlcnMsIGNhbGxGaWx0ZXI6ICRzbG90Q3R4LmNhbGxGaWx0ZXJ9OycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyBcbi8vICAgICAgICAgICAgIGlmIChhTm9kZS5kaXJlY3RpdmVzLmJpbmQpIHtcbi8vICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdleHRlbmQoJHNsb3RDdHguZGF0YSwgJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoYU5vZGUuZGlyZWN0aXZlcy5iaW5kLnZhbHVlKSArICcpOycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgIGVhY2goYU5vZGUudmFycywgZnVuY3Rpb24gKHZhckl0ZW0pIHtcbi8vICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KFxuLy8gICAgICAgICAgICAgICAgICAgICAnJHNsb3RDdHguZGF0YVtcIicgKyB2YXJJdGVtLm5hbWUgKyAnXCJdID0gJ1xuLy8gICAgICAgICAgICAgICAgICAgICArIGNvbXBpbGVFeHByU291cmNlLmV4cHIodmFySXRlbS5leHByKVxuLy8gICAgICAgICAgICAgICAgICAgICArICc7J1xuLy8gICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2ZvciAodmFyICRyZW5kZXJJbmRleCA9IDA7ICRyZW5kZXJJbmRleCA8ICRnaXZlblNsb3QubGVuZ3RoOyAkcmVuZGVySW5kZXgrKykgeycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCcgIGh0bWwgKz0gJGdpdmVuU2xvdFskcmVuZGVySW5kZXhdKCRzbG90Q3R4KTsnKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30pKCk7Jyk7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkeaZrumAmuiKgueCuVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg6IqC54K55a+56LGhXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tuWunuS+i+eOr+Wig1xuLy8gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSDnvJbor5HmiYDpnIDnmoTkuIDkupvpop3lpJbkv6Hmga9cbi8vICAgICAgKi9cbi8vICAgICBjb21waWxlRWxlbWVudDogZnVuY3Rpb24gKGFOb2RlLCBzb3VyY2VCdWZmZXIsIG93bmVyLCBleHRyYSkge1xuLy8gICAgICAgICBleHRyYSA9IGV4dHJhIHx8IHt9O1xuLy8gICAgICAgICAvLyBpZiAoYU5vZGUudGFnTmFtZSA9PT0gJ29wdGlvbidcbi8vICAgICAgICAgLy8gICAgICYmICFnZXRBTm9kZVByb3AoYU5vZGUsICd2YWx1ZScpXG4vLyAgICAgICAgIC8vICAgICAmJiBhTm9kZS5jaGlsZHJlblswXVxuLy8gICAgICAgICAvLyApIHtcbi8vICAgICAgICAgLy8gICAgIGFOb2RlLnByb3BzLnB1c2goe1xuLy8gICAgICAgICAvLyAgICAgICAgIG5hbWU6ICd2YWx1ZScsXG4vLyAgICAgICAgIC8vICAgICAgICAgZXhwcjogYU5vZGUuY2hpbGRyZW5bMF0udGV4dEV4cHJcbi8vICAgICAgICAgLy8gICAgIH0pO1xuLy8gICAgICAgICAvLyB9XG4vLyBcbi8vICAgICAgICAgZWxlbWVudFNvdXJjZUNvbXBpbGVyLnRhZ1N0YXJ0KFxuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLFxuLy8gICAgICAgICAgICAgYU5vZGUudGFnTmFtZSxcbi8vICAgICAgICAgICAgIGFOb2RlLnByb3BzLFxuLy8gICAgICAgICAgICAgZXh0cmEucHJvcCxcbi8vICAgICAgICAgICAgIGFOb2RlLmRpcmVjdGl2ZXMuYmluZFxuLy8gICAgICAgICApO1xuLy8gXG4vLyAgICAgICAgIGVsZW1lbnRTb3VyY2VDb21waWxlci5pbm5lcihzb3VyY2VCdWZmZXIsIGFOb2RlLCBvd25lcik7XG4vLyAgICAgICAgIGVsZW1lbnRTb3VyY2VDb21waWxlci50YWdFbmQoc291cmNlQnVmZmVyLCBhTm9kZS50YWdOYW1lKTtcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog57yW6K+R57uE5Lu26IqC54K5XG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDoioLngrnlr7nosaFcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTb3VyY2VCdWZmZXJ9IHNvdXJjZUJ1ZmZlciDnvJbor5HmupDnoIHnmoTkuK3pl7RidWZmZXJcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu25a6e5L6L546v5aKDXG4vLyAgICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIOe8luivkeaJgOmcgOeahOS4gOS6m+mineWkluS/oeaBr1xuLy8gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV4dHJhLkNvbXBvbmVudENsYXNzIOWvueW6lOe7hOS7tuexu1xuLy8gICAgICAqL1xuLy8gICAgIGNvbXBpbGVDb21wb25lbnQ6IGZ1bmN0aW9uIChhTm9kZSwgc291cmNlQnVmZmVyLCBvd25lciwgZXh0cmEpIHtcbi8vICAgICAgICAgaWYgKGFOb2RlKSB7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd2YXIgJHNsb3ROYW1lID0gbnVsbDsnKTtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ3ZhciAkZ2l2ZW5TbG90cyA9IFtdOycpO1xuLy8gICAgICAgICAgICAgZWFjaChhTm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIHNsb3RCaW5kID0gIWNoaWxkLnRleHRFeHByICYmIGdldEFOb2RlUHJvcChjaGlsZCwgJ3Nsb3QnKTtcbi8vICAgICAgICAgICAgICAgICBpZiAoc2xvdEJpbmQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnJHNsb3ROYW1lID0gJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoc2xvdEJpbmQuZXhwcikgKyAnOycpO1xuLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCckZ2l2ZW5TbG90cy5wdXNoKFtmdW5jdGlvbiAoY29tcG9uZW50Q3R4KSB7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgdmFyIGh0bWwgPSBcIlwiOycpO1xuLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KGFOb2RlQ29tcGlsZXIuY29tcGlsZShjaGlsZCwgc291cmNlQnVmZmVyLCBvd25lcikpO1xuLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCcgIHJldHVybiBodG1sOycpO1xuLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9LCAkc2xvdE5hbWVdKTsnKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyRnaXZlblNsb3RzLnB1c2goW2Z1bmN0aW9uIChjb21wb25lbnRDdHgpIHsnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICB2YXIgaHRtbCA9IFwiXCI7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoYU5vZGVDb21waWxlci5jb21waWxlKGNoaWxkLCBzb3VyY2VCdWZmZXIsIG93bmVyKSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgcmV0dXJuIGh0bWw7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ31dKTsnKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHZhciBDb21wb25lbnRDbGFzcyA9IGV4dHJhLkNvbXBvbmVudENsYXNzO1xuLy8gICAgICAgICB2YXIgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKHtcbi8vICAgICAgICAgICAgIGFOb2RlOiBhTm9kZSxcbi8vICAgICAgICAgICAgIG93bmVyOiBvd25lcixcbi8vICAgICAgICAgICAgIHN1YlRhZzogYU5vZGUudGFnTmFtZVxuLy8gICAgICAgICB9KTtcbi8vIFxuLy8gICAgICAgICB2YXIgZ2l2ZW5EYXRhID0gW107XG4vLyBcbi8vICAgICAgICAgZWFjaChjb21wb25lbnQuYmluZHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4vLyAgICAgICAgICAgICBnaXZlbkRhdGEucHVzaChcbi8vICAgICAgICAgICAgICAgICBjb21waWxlRXhwclNvdXJjZS5zdHJpbmdMaXRlcmFsaXplKHByb3AubmFtZSlcbi8vICAgICAgICAgICAgICAgICArICc6J1xuLy8gICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihwcm9wLmV4cHIpXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICB9KTtcbi8vIFxuLy8gICAgICAgICB2YXIgZ2l2ZW5EYXRhSFRNTCA9ICd7JyArIGdpdmVuRGF0YS5qb2luKCcsXFxuJykgKyAnfSc7XG4vLyAgICAgICAgIGlmIChhTm9kZS5kaXJlY3RpdmVzLmJpbmQpe1xuLy8gICAgICAgICAgICAgZ2l2ZW5EYXRhSFRNTCA9ICdleHRlbmQoJ1xuLy8gICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihhTm9kZS5kaXJlY3RpdmVzLmJpbmQudmFsdWUpXG4vLyAgICAgICAgICAgICAgICAgICsgJywgJ1xuLy8gICAgICAgICAgICAgICAgICsgZ2l2ZW5EYXRhSFRNTFxuLy8gICAgICAgICAgICAgICAgICsgJyknO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnaHRtbCArPSAoJyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSZW5kZXJlclN0YXJ0KCk7XG4vLyAgICAgICAgIGNvbXBpbGVDb21wb25lbnRTb3VyY2Uoc291cmNlQnVmZmVyLCBjb21wb25lbnQsIGV4dHJhICYmIGV4dHJhLnByb3ApO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmVuZGVyZXJFbmQoKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnKSgnICsgZ2l2ZW5EYXRhSFRNTCArICcsIGNvbXBvbmVudEN0eCwgJGdpdmVuU2xvdHMpOycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCckZ2l2ZW5TbG90cyA9IG51bGw7Jyk7XG4vLyAgICAgfVxuLy8gfTtcbi8vIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkOe7hOS7tiByZW5kZXJlciDml7YgY3R4IOWvueixoeaehOW7uueahOS7o+eggVxuLy8gICpcbi8vICAqIEBpbm5lclxuLy8gICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IOe7hOS7tuWunuS+i1xuLy8gICogQHBhcmFtIHtzdHJpbmc/fSBleHRyYVByb3Ag6aKd5aSW55qE5bGe5oCn5LiyXG4vLyAgKi9cbi8vIGZ1bmN0aW9uIGNvbXBpbGVDb21wb25lbnRTb3VyY2Uoc291cmNlQnVmZmVyLCBjb21wb25lbnQsIGV4dHJhUHJvcCkge1xuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoZ2VuQ29tcG9uZW50Q29udGV4dENvZGUoY29tcG9uZW50KSk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnY29tcG9uZW50Q3R4Lm93bmVyID0gcGFyZW50Q3R4OycpO1xuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2NvbXBvbmVudEN0eC5naXZlblNsb3RzID0gZ2l2ZW5TbG90czsnKTtcbi8vIFxuLy8gXG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnZGF0YSA9IGV4dGVuZChjb21wb25lbnRDdHguZGF0YSwgZGF0YSk7Jyk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnZm9yICh2YXIgJGkgPSAwOyAkaSA8IGNvbXBvbmVudEN0eC5jb21wdXRlZE5hbWVzLmxlbmd0aDsgJGkrKykgeycpO1xuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgdmFyICRjb21wdXRlZE5hbWUgPSBjb21wb25lbnRDdHguY29tcHV0ZWROYW1lc1skaV07Jyk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICBkYXRhWyRjb21wdXRlZE5hbWVdID0gY29tcG9uZW50Q3R4LmNvbXB1dGVkWyRjb21wdXRlZE5hbWVdKCk7Jyk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gXG4vLyAgICAgZXh0cmFQcm9wID0gZXh0cmFQcm9wIHx8ICcnO1xuLy8gXG4vLyAgICAgdmFyIGV2ZW50RGVjbGFyYXRpb25zID0gW107XG4vLyAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudC5saXN0ZW5lcnMpIHtcbi8vICAgICAgICAgZWFjaChjb21wb25lbnQubGlzdGVuZXJzW2tleV0sIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuLy8gICAgICAgICAgICAgaWYgKGxpc3RlbmVyLmRlY2xhcmF0aW9uKSB7XG4vLyAgICAgICAgICAgICAgICAgZXZlbnREZWNsYXJhdGlvbnMucHVzaChsaXN0ZW5lci5kZWNsYXJhdGlvbik7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGVsZW1lbnRTb3VyY2VDb21waWxlci50YWdTdGFydChcbi8vICAgICAgICAgc291cmNlQnVmZmVyLFxuLy8gICAgICAgICBjb21wb25lbnQudGFnTmFtZSxcbi8vICAgICAgICAgY29tcG9uZW50LmFOb2RlLnByb3BzLFxuLy8gICAgICAgICBleHRyYVByb3AsXG4vLyAgICAgICAgIGNvbXBvbmVudC5hTm9kZS5kaXJlY3RpdmVzLmJpbmRcbi8vICAgICApO1xuLy8gXG4vLyAgICAgaWYgKCFjb21wb25lbnQub3duZXIpIHtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoJzwhLS1zLWRhdGE6Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luRGF0YVN0cmluZ2lmeSgpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnLS0+Jyk7XG4vLyAgICAgfVxuLy8gXG4vLyBcbi8vIFxuLy8gICAgIGVsZW1lbnRTb3VyY2VDb21waWxlci5pbm5lcihzb3VyY2VCdWZmZXIsIGNvbXBvbmVudC5hTm9kZSwgY29tcG9uZW50KTtcbi8vICAgICBlbGVtZW50U291cmNlQ29tcGlsZXIudGFnRW5kKHNvdXJjZUJ1ZmZlciwgY29tcG9uZW50LnRhZ05hbWUpO1xuLy8gfVxuLy8gXG4vLyB2YXIgc3RyaW5naWZpZXIgPSB7XG4vLyAgICAgb2JqOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgIHZhciBwcmVmaXhDb21tYTtcbi8vICAgICAgICAgdmFyIHJlc3VsdCA9ICd7Jztcbi8vIFxuLy8gICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4vLyAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtrZXldID09PSAndW5kZWZpbmVkJykge1xuLy8gICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICBpZiAocHJlZml4Q29tbWEpIHtcbi8vICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgcHJlZml4Q29tbWEgPSAxO1xuLy8gXG4vLyAgICAgICAgICAgICByZXN1bHQgKz0gY29tcGlsZUV4cHJTb3VyY2Uuc3RyaW5nTGl0ZXJhbGl6ZShrZXkpICsgJzonICsgc3RyaW5naWZpZXIuYW55KHNvdXJjZVtrZXldKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHJldHVybiByZXN1bHQgKyAnfSc7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIGFycjogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICB2YXIgcHJlZml4Q29tbWE7XG4vLyAgICAgICAgIHZhciByZXN1bHQgPSAnWyc7XG4vLyBcbi8vICAgICAgICAgZWFjaChzb3VyY2UsIGZ1bmN0aW9uICh2YWx1ZSkge1xuLy8gICAgICAgICAgICAgaWYgKHByZWZpeENvbW1hKSB7XG4vLyAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIHByZWZpeENvbW1hID0gMTtcbi8vIFxuLy8gICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmaWVyLmFueSh2YWx1ZSk7XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXSc7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIHN0cjogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICByZXR1cm4gY29tcGlsZUV4cHJTb3VyY2Uuc3RyaW5nTGl0ZXJhbGl6ZShzb3VyY2UpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICBkYXRlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgIHJldHVybiAnbmV3IERhdGUoJyArIHNvdXJjZS5nZXRUaW1lKCkgKyAnKSc7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIGFueTogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzb3VyY2UpIHtcbi8vICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVyLnN0cihzb3VyY2UpO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiAnJyArIHNvdXJjZTtcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4vLyAgICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllci5hcnIoc291cmNlKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRGF0ZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZXIuZGF0ZShzb3VyY2UpO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllci5vYmooc291cmNlKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IFN0cmluZ2lmeTonICsgc291cmNlKTtcbi8vICAgICB9XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkOe7hOS7tiByZW5kZXJlciDml7YgY3R4IOWvueixoeaehOW7uueahOS7o+eggVxuLy8gICpcbi8vICAqIEBpbm5lclxuLy8gICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCDnu4Tku7blrp7kvotcbi8vICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAqL1xuLy8gZnVuY3Rpb24gZ2VuQ29tcG9uZW50Q29udGV4dENvZGUoY29tcG9uZW50KSB7XG4vLyAgICAgdmFyIGNvZGUgPSBbJ3ZhciBjb21wb25lbnRDdHggPSB7J107XG4vLyBcbi8vICAgICAvLyBnaXZlbiBhbm9kZVxuLy8gICAgIGNvZGUucHVzaCgnZ2l2ZW5TbG90czogW10sJyk7XG4vLyBcbi8vICAgICAvLyBmaWx0ZXJzXG4vLyAgICAgY29kZS5wdXNoKCdmaWx0ZXJzOiB7Jyk7XG4vLyAgICAgdmFyIGZpbHRlckNvZGUgPSBbXTtcbi8vICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50LmZpbHRlcnMpIHtcbi8vICAgICAgICAgdmFyIGZpbHRlciA9IGNvbXBvbmVudC5maWx0ZXJzW2tleV07XG4vLyBcbi8vICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgICAgICAgIGZpbHRlckNvZGUucHVzaChrZXkgKyAnOiAnICsgZmlsdGVyLnRvU3RyaW5nKCkpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGNvZGUucHVzaChmaWx0ZXJDb2RlLmpvaW4oJywnKSk7XG4vLyAgICAgY29kZS5wdXNoKCd9LCcpO1xuLy8gXG4vLyAgICAgY29kZS5wdXNoKFxuLy8gICAgICAgICAnY2FsbEZpbHRlcjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHsnLFxuLy8gICAgICAgICAnICAgIHZhciBmaWx0ZXIgPSB0aGlzLmZpbHRlcnNbbmFtZV0gfHwgREVGQVVMVF9GSUxURVJTW25hbWVdOycsXG4vLyAgICAgICAgICcgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikgeycsXG4vLyAgICAgICAgICcgICAgICAgIHJldHVybiBmaWx0ZXIuYXBwbHkodGhpcywgYXJncyk7Jyxcbi8vICAgICAgICAgJyAgICB9Jyxcbi8vICAgICAgICAgJ30sJ1xuLy8gICAgICk7XG4vLyBcbi8vICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cbi8vICAgICAvLyBjb21wdXRlZCBvYmpcbi8vICAgICBjb2RlLnB1c2goJ2NvbXB1dGVkOiB7Jyk7XG4vLyAgICAgdmFyIGNvbXB1dGVkQ29kZSA9IFtdO1xuLy8gICAgIGZvciAodmFyIGtleSBpbiBjb21wb25lbnQuY29tcHV0ZWQpIHtcbi8vICAgICAgICAgdmFyIGNvbXB1dGVkID0gY29tcG9uZW50LmNvbXB1dGVkW2tleV07XG4vLyBcbi8vICAgICAgICAgaWYgKHR5cGVvZiBjb21wdXRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuLy8gICAgICAgICAgICAgY29tcHV0ZWRDb2RlLnB1c2goa2V5ICsgJzogJ1xuLy8gICAgICAgICAgICAgICAgICsgY29tcHV0ZWQudG9TdHJpbmcoKS5yZXBsYWNlKFxuLy8gICAgICAgICAgICAgICAgICAgICAvdGhpcy5kYXRhLmdldFxcKChbXlxcKV0rKVxcKS9nLFxuLy8gICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIGV4cHJMaXRlcmFsKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwclN0ciA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZXhwckxpdGVyYWwpKSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHIoZXhwclN0cik7XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5leHByKGV4cHIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KVxuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBjb2RlLnB1c2goY29tcHV0ZWRDb2RlLmpvaW4oJywnKSk7XG4vLyAgICAgY29kZS5wdXNoKCd9LCcpO1xuLy8gXG4vLyAgICAgLy8gY29tcHV0ZWQgbmFtZXNcbi8vICAgICBjb2RlLnB1c2goJ2NvbXB1dGVkTmFtZXM6IFsnKTtcbi8vICAgICBjb21wdXRlZENvZGUgPSBbXTtcbi8vICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50LmNvbXB1dGVkKSB7XG4vLyAgICAgICAgIHZhciBjb21wdXRlZCA9IGNvbXBvbmVudC5jb21wdXRlZFtrZXldO1xuLy8gXG4vLyAgICAgICAgIGlmICh0eXBlb2YgY29tcHV0ZWQgPT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgICAgICAgIGNvbXB1dGVkQ29kZS5wdXNoKCdcIicgKyBrZXkgKyAnXCInKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBjb2RlLnB1c2goY29tcHV0ZWRDb2RlLmpvaW4oJywnKSk7XG4vLyAgICAgY29kZS5wdXNoKCddLCcpO1xuLy8gICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG4vLyBcbi8vICAgICAvLyBkYXRhXG4vLyAgICAgY29kZS5wdXNoKCdkYXRhOiAnICsgc3RyaW5naWZpZXIuYW55KGNvbXBvbmVudC5kYXRhLmdldCgpKSArICcsJyk7XG4vLyBcbi8vICAgICAvLyB0YWdOYW1lXG4vLyAgICAgY29kZS5wdXNoKCd0YWdOYW1lOiBcIicgKyBjb21wb25lbnQudGFnTmFtZSArICdcIicpO1xuLy8gICAgIGNvZGUucHVzaCgnfTsnKTtcbi8vIFxuLy8gICAgIHJldHVybiBjb2RlLmpvaW4oJ1xcbicpO1xuLy8gfVxuLy8gXG4vLyAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuLy8gXG4vLyAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gLyogZXNsaW50LWRpc2FibGUgZmVjcy1jYW1lbGNhc2UgKi9cbi8vIFxuLy8gLyoqXG4vLyAgKiDnu4Tku7bnvJbor5HnmoTmqKHmnb/lh73mlbBcbi8vICAqXG4vLyAgKiBAaW5uZXJcbi8vICAqL1xuLy8gZnVuY3Rpb24gY29tcG9uZW50Q29tcGlsZVByZUNvZGUoKSB7XG4vLyAgICAgdmFyICR2ZXJzaW9uID0gJzMuNi4xJztcbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuLy8gICAgICAgICBpZiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuLy8gICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuLy8gICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICByZXR1cm4gdGFyZ2V0O1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGVhY2goYXJyYXksIGl0ZXJhdG9yKSB7XG4vLyAgICAgICAgIGlmIChhcnJheSAmJiBhcnJheS5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuLy8gICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvcihhcnJheVtpXSwgaSkgPT09IGZhbHNlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCB2YWx1ZSkge1xuLy8gICAgICAgICB2YXIgcmVzdWx0O1xuLy8gICAgICAgICBlYWNoKGFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuLy8gICAgICAgICAgICAgcmVzdWx0ID0gaXRlbSA9PT0gdmFsdWU7XG4vLyAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdDtcbi8vICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbi8vICAgICB9XG4vLyBcbi8vICAgICB2YXIgSFRNTF9FTlRJVFkgPSB7XG4vLyAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbi8vICAgICAgICAgJyYnOiAnJmFtcDsnLFxuLy8gICAgICAgICAnPCc6ICcmbHQ7Jyxcbi8vICAgICAgICAgJz4nOiAnJmd0OycsXG4vLyAgICAgICAgICdcIic6ICcmcXVvdDsnLFxuLy8gICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBxdW90ZXMgKi9cbi8vICAgICAgICAgXCInXCI6ICcmIzM5Oydcbi8vICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBxdW90ZXMgKi9cbi8vICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbi8vICAgICB9O1xuLy8gXG4vLyAgICAgZnVuY3Rpb24gaHRtbEZpbHRlclJlcGxhY2VyKGMpIHtcbi8vICAgICAgICAgcmV0dXJuIEhUTUxfRU5USVRZW2NdO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGVzY2FwZUhUTUwoc291cmNlKSB7XG4vLyAgICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuICcnO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIFN0cmluZyhzb3VyY2UpLnJlcGxhY2UoL1smPD5cIiddL2csIGh0bWxGaWx0ZXJSZXBsYWNlcik7XG4vLyAgICAgfVxuLy8gXG4vLyAgICAgdmFyIERFRkFVTFRfRklMVEVSUyA9IHtcbi8vICAgICAgICAgdXJsOiBlbmNvZGVVUklDb21wb25lbnQsXG4vLyAgICAgICAgIF9jbGFzczogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5qb2luKCcgJyk7XG4vLyAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIF9zdHlsZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuLy8gICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBrZXkgKyAnOicgKyBzb3VyY2Vba2V5XSArICc7Jztcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbi8vICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSB8fCAnJztcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAgX3NlcDogZnVuY3Rpb24gKHNvdXJjZSwgc2VwKSB7XG4vLyAgICAgICAgICAgICByZXR1cm4gc291cmNlID8gc2VwICsgc291cmNlIDogJyc7XG4vLyAgICAgICAgIH1cbi8vICAgICB9O1xuLy8gXG4vLyAgICAgZnVuY3Rpb24gYXR0ckZpbHRlcihuYW1lLCB2YWx1ZSkge1xuLy8gICAgICAgICBpZiAodmFsdWUpIHtcbi8vICAgICAgICAgICAgIHJldHVybiAnICcgKyBuYW1lICsgJz1cIicgKyB2YWx1ZSArICdcIic7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICByZXR1cm4gJyc7XG4vLyAgICAgfVxuLy8gXG4vLyAgICAgZnVuY3Rpb24gYm9vbEF0dHJGaWx0ZXIobmFtZSwgdmFsdWUpIHtcbi8vICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnZmFsc2UnICYmIHZhbHVlICE9PSAnMCcpIHtcbi8vICAgICAgICAgICAgIHJldHVybiAnICcgKyBuYW1lO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgcmV0dXJuICcnO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIHN0cmluZ0xpdGVyYWxpemUoc291cmNlKSB7XG4vLyAgICAgICAgIHJldHVybiAnXCInXG4vLyAgICAgICAgICAgICArIHNvdXJjZVxuLy8gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHg1Qy9nLCAnXFxcXFxcXFwnKVxuLy8gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx4MEEvZywgJ1xcXFxuJylcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx4MDkvZywgJ1xcXFx0Jylcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx4MEQvZywgJ1xcXFxyJylcbi8vICAgICAgICAgICAgICsgJ1wiJztcbi8vICAgICB9XG4vLyBcbi8vICAgICB2YXIgc3RyaW5naWZpZXIgPSB7XG4vLyAgICAgICAgIG9iajogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICAgICAgdmFyIHByZWZpeENvbW1hO1xuLy8gICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICd7Jztcbi8vIFxuLy8gICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtrZXldID09PSAndW5kZWZpbmVkJykge1xuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgaWYgKHByZWZpeENvbW1hKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIHByZWZpeENvbW1hID0gMTtcbi8vIFxuLy8gICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdMaXRlcmFsaXplKGtleSkgKyAnOicgKyBzdHJpbmdpZmllci5hbnkoc291cmNlW2tleV0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnfSc7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgYXJyOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICB2YXIgcHJlZml4Q29tbWE7XG4vLyAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1snO1xuLy8gXG4vLyAgICAgICAgICAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKHByZWZpeENvbW1hKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIHByZWZpeENvbW1hID0gMTtcbi8vIFxuLy8gICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdpZmllci5hbnkodmFsdWUpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXSc7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgc3RyOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbGl6ZShzb3VyY2UpO1xuLy8gICAgICAgICB9LFxuLy8gXG4vLyAgICAgICAgIGRhdGU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbi8vICAgICAgICAgICAgIHJldHVybiAnbmV3IERhdGUoJyArIHNvdXJjZS5nZXRUaW1lKCkgKyAnKSc7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgYW55OiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzb3VyY2UpIHtcbi8vICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZXIuc3RyKHNvdXJjZSk7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgKyBzb3VyY2U7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllci5hcnIoc291cmNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBEYXRlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZXIuZGF0ZShzb3VyY2UpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVyLm9iaihzb3VyY2UpO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBTdHJpbmdpZnk6JyArIHNvdXJjZSk7XG4vLyAgICAgICAgIH1cbi8vICAgICB9O1xuLy8gfVxuLy8gLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gLyogZXNsaW50LWVuYWJsZSBmZWNzLWNhbWVsY2FzZSAqL1xuLy8gXG4vLyAvKipcbi8vICAqIOWwhue7hOS7tue8luivkeaIkCByZW5kZXIg5pa55rOV55qEIGpzIOa6kOeggVxuLy8gICpcbi8vICAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudENsYXNzIOe7hOS7tuexu1xuLy8gICogQHJldHVybiB7c3RyaW5nfVxuLy8gICovXG4vLyBmdW5jdGlvbiBjb21waWxlSlNTb3VyY2UoQ29tcG9uZW50Q2xhc3MpIHtcbi8vICAgICB2YXIgc291cmNlQnVmZmVyID0gbmV3IENvbXBpbGVTb3VyY2VCdWZmZXIoKTtcbi8vIFxuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSZW5kZXJlclN0YXJ0KCk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdyhcbi8vICAgICAgICAgY29tcG9uZW50Q29tcGlsZVByZUNvZGUudG9TdHJpbmcoKVxuLy8gICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuLy8gICAgICAgICAgICAgLnNsaWNlKDEpXG4vLyAgICAgICAgICAgICAuam9pbignXFxuJylcbi8vICAgICAgICAgICAgIC5yZXBsYWNlKC9cXH1cXHMqJC8sICcnKVxuLy8gICAgICk7XG4vLyBcbi8vICAgICAvLyDlhYjliJ3lp4vljJbkuKrlrp7kvovvvIzorqnmqKHmnb/nvJbor5HmiJAgQU5vZGXvvIzlubbkuJTog73ojrflvpfliJ3lp4vljJbmlbDmja5cbi8vICAgICB2YXIgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKCk7XG4vLyBcbi8vICAgICBjb21waWxlQ29tcG9uZW50U291cmNlKHNvdXJjZUJ1ZmZlciwgY29tcG9uZW50KTtcbi8vICAgICBzb3VyY2VCdWZmZXIuYWRkUmVuZGVyZXJFbmQoKTtcbi8vICAgICByZXR1cm4gc291cmNlQnVmZmVyLnRvQ29kZSgpO1xuLy8gfVxuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVKU1NvdXJjZTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyAgICAgdmFyIG5leHRUaWNrID0gcmVxdWlyZSgnLi91dGlsL25leHQtdGljaycpO1xuLy8gICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4vdXRpbC9pbmhlcml0cycpO1xuLy8gICAgIHZhciBwYXJzZVRlbXBsYXRlID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2UtdGVtcGxhdGUnKTtcbi8vICAgICB2YXIgcGFyc2VFeHByID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2UtZXhwcicpO1xuLy8gICAgIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gICAgIHZhciBMaWZlQ3ljbGUgPSByZXF1aXJlKCcuL3ZpZXcvbGlmZS1jeWNsZScpO1xuLy8gICAgIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vdmlldy9ub2RlLXR5cGUnKTtcbi8vICAgICB2YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi92aWV3L2NvbXBvbmVudCcpO1xuLy8gICAgIHZhciBjb21waWxlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi92aWV3L2NvbXBpbGUtY29tcG9uZW50Jyk7XG4vLyAgICAgdmFyIGRlZmluZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vdmlldy9kZWZpbmUtY29tcG9uZW50Jyk7XG4vLyAgICAgdmFyIGVtaXREZXZ0b29sID0gcmVxdWlyZSgnLi91dGlsL2VtaXQtZGV2dG9vbCcpO1xuLy8gICAgIHZhciBjb21waWxlSlNTb3VyY2UgPSByZXF1aXJlKCcuL3ZpZXcvY29tcGlsZS1qcy1zb3VyY2UnKTtcbi8vICAgICB2YXIgRGF0YSA9IHJlcXVpcmUoJy4vcnVudGltZS9kYXRhJyk7XG4vLyAgICAgdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuLy8gICAgIHZhciBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL3V0aWwvZGF0YS10eXBlcycpO1xuXG5cbiAgICB2YXIgc2FuID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2Fu54mI5pys5Y+3XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2ZXJzaW9uOiAnMy42LjEnLFxuXG4gICAgICAgIC8vICNbYmVnaW5dIGRldnRvb2xcbi8vICAgICAgICAgLyoqXG4vLyAgICAgICAgICAqIOaYr+WQpuW8gOWQr+iwg+ivleOAguW8gOWQr+iwg+ivleaXtiBkZXZ0b29sIOS8muW3peS9nFxuLy8gICAgICAgICAgKlxuLy8gICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbi8vICAgICAgICAgICovXG4vLyAgICAgICAgIGRlYnVnOiB0cnVlLFxuICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAvLyAjW2JlZ2luXSBzc3Jcbi8vICAgICAgICAgLyoqXG4vLyAgICAgICAgICAqIOWwhue7hOS7tuexu+e8luivkeaIkCByZW5kZXJlciDmlrnms5Vcbi8vICAgICAgICAgICpcbi8vICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4vLyAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKE9iamVjdCk6c3RyaW5nfVxuLy8gICAgICAgICAgKi9cbi8vICAgICAgICAgY29tcGlsZVRvUmVuZGVyZXI6IGZ1bmN0aW9uIChDb21wb25lbnRDbGFzcykge1xuLy8gICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gQ29tcG9uZW50Q2xhc3MuX19zc3JSZW5kZXJlcjtcbi8vIFxuLy8gICAgICAgICAgICAgaWYgKCFyZW5kZXJlcikge1xuLy8gICAgICAgICAgICAgICAgIHZhciBjb2RlID0gY29tcGlsZUpTU291cmNlKENvbXBvbmVudENsYXNzKTtcbi8vICAgICAgICAgICAgICAgICByZW5kZXJlciA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgY29kZSkpKCk7XG4vLyAgICAgICAgICAgICAgICAgQ29tcG9uZW50Q2xhc3MuX19zc3JSZW5kZXJlciA9IHJlbmRlcmVyO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgLyoqXG4vLyAgICAgICAgICAqIOWwhue7hOS7tuexu+e8luivkeaIkCByZW5kZXJlciDmlrnms5XnmoTmupDmlofku7Zcbi8vICAgICAgICAgICpcbi8vICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4vLyAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAgICAgICAgICovXG4vLyAgICAgICAgIGNvbXBpbGVUb1NvdXJjZTogY29tcGlsZUpTU291cmNlLFxuICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAvKipcbiAgICAgICAgICog57uE5Lu25Z+657G7XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rnu4Tku7bnsbtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIOe7hOS7tuexu+eahOaWueazleihqFxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGRlZmluZUNvbXBvbmVudDogZGVmaW5lQ29tcG9uZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvJbor5Hnu4Tku7bnsbvjgILpooTop6PmnpB0ZW1wbGF0ZeWSjGNvbXBvbmVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4gICAgICAgICAqL1xuICAgICAgICBjb21waWxlQ29tcG9uZW50OiBjb21waWxlQ29tcG9uZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6PmnpAgdGVtcGxhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgdGVtcGxhdGUg5rqQ56CBXG4gICAgICAgICAqIEByZXR1cm4ge0FOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2VUZW1wbGF0ZTogcGFyc2VUZW1wbGF0ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6Kej5p6Q6KGo6L6+5byPXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug5rqQ56CBXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlRXhwcjogcGFyc2VFeHByLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajovr7lvI/nsbvlnovmnprkuL5cbiAgICAgICAgICpcbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBFeHByVHlwZTogRXhwclR5cGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUn+WRveWRqOacn1xuICAgICAgICAgKi9cbiAgICAgICAgTGlmZUN5Y2xlOiBMaWZlQ3ljbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiKgueCueexu+Wei1xuICAgICAgICAgKlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIE5vZGVUeXBlOiBOb2RlVHlwZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zyo5LiL5LiA5Liq5pu05paw5ZGo5pyf6L+Q6KGM5Ye95pWwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIOimgei/kOihjOeahOWHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dFRpY2s6IG5leHRUaWNrLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmlbDmja7nsbtcbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0P30gZGF0YSDliJ3lp4vmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtEYXRhP30gcGFyZW50IOeItue6p+aVsOaNruWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgRGF0YTogRGF0YSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6h566X6KGo6L6+5byP55qE5YC8XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIOihqOi+vuW8j+WvueixoVxuICAgICAgICAgKiBAcGFyYW0ge0RhdGF9IGRhdGEg5pWw5o2u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7Q29tcG9uZW50PX0gb3duZXIg57uE5Lu25a+56LGh77yM55So5LqO6KGo6L6+5byP5LitZmlsdGVy55qE5omn6KGMXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuICAgICAgICBldmFsRXhwcjogZXZhbEV4cHIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaehOW7uuexu+S5i+mXtOeahOe7p+aJv+WFs+ezu1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJDbGFzcyDlrZDnsbvlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDbGFzcyDniLbnsbvlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YVR5cGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVHlwZXM6IERhdGFUeXBlc1xuICAgIH07XG5cbiAgICAvLyBleHBvcnRcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIEZvciBDb21tb25KU1xuICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzYW47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBGb3IgQU1EXG4gICAgICAgIGRlZmluZSgnc2FuJywgW10sIHNhbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGb3IgPHNjcmlwdCBzcmM9XCIuLi5cIlxuICAgICAgICByb290LnNhbiA9IHNhbjtcbiAgICB9XG5cbiAgICAvLyAjW2JlZ2luXSBkZXZ0b29sXG4vLyAgICAgZW1pdERldnRvb2wuc3RhcnQoc2FuKTtcbiAgICAvLyAjW2VuZF1cbn0pKHRoaXMpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/_san@3.6.1@san/dist/san.js\n");

/***/ }),

/***/ "./node_modules/_setimmediate@1.0.5@setimmediate/setImmediate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_setimmediate@1.0.5@setimmediate/setImmediate.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.12.0@webpack/buildin/global.js */ \"./node_modules/_webpack@4.12.0@webpack/buildin/global.js\"), __webpack_require__(/*! ./../_process@0.11.10@process/browser.js */ \"./node_modules/_process@0.11.10@process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3NldGltbWVkaWF0ZUAxLjAuNUBzZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzP2RlOGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL19zZXRpbW1lZGlhdGVAMS4wLjVAc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_setimmediate@1.0.5@setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/_style-loader@0.21.0@style-loader/lib/addStyles.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_style-loader@0.21.0@style-loader/lib/addStyles.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/_style-loader@0.21.0@style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjIxLjBAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/NjFiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjIxLjBAc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_style-loader@0.21.0@style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/_style-loader@0.21.0@style-loader/lib/urls.js":
/*!********************************************************************!*\
  !*** ./node_modules/_style-loader@0.21.0@style-loader/lib/urls.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAwLjIxLjBAc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzPzU2OWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMjEuMEBzdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_style-loader@0.21.0@style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/_timers-browserify@2.0.10@timers-browserify/main.js":
/*!**************************************************************************!*\
  !*** ./node_modules/_timers-browserify@2.0.10@timers-browserify/main.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/_setimmediate@1.0.5@setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.12.0@webpack/buildin/global.js */ \"./node_modules/_webpack@4.12.0@webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3RpbWVycy1icm93c2VyaWZ5QDIuMC4xMEB0aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzRmNDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL190aW1lcnMtYnJvd3NlcmlmeUAyLjAuMTBAdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/_timers-browserify@2.0.10@timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/_webpack@4.12.0@webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuMTIuMEB3ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/_webpack@4.12.0@webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/App.san":
/*!*********************!*\
  !*** ./src/App.san ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __san_script__, __san_template__\nvar __san_styles__ = {}\n__san_script__ = __webpack_require__(/*! !!../node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=script&index=0!./App.san */ \"./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=script&index=0!./src/App.san\")\nif (__san_script__ &&\n    __san_script__.__esModule &&\n    Object.keys(__san_script__).length > 1) {\n  console.warn(\"[san-loader] src\\\\App.san: named exports in *.san files are ignored.\")}\n__san_template__ = __webpack_require__(/*! !html-loader?minimize=false!../node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=template&index=0!./App.san */ \"./node_modules/_html-loader@0.5.5@html-loader/index.js?minimize=false!./node_modules/_san-loader@0.0.7@san-loader/lib/selector.js?type=template&index=0!./src/App.san\")\nvar __san_proto__ = {}\nif (__san_script__) {\n  __san_proto__ = __san_script__.__esModule\n    ? __san_script__['default']\n    : __san_script__\n}\nif (__san_template__) {\n  __san_proto__.template = __san_template__\n}\nvar san = __webpack_require__(/*! san */ \"./node_modules/_san@3.6.1@san/dist/san.js\")\nvar __san_exports__ = san.defineComponent(__san_proto__)\nmodule.exports = __san_exports__\nif (module.exports.__esModule) module.exports = module.exports['default']\nif (!__san_exports__.computed) __san_exports__.computed = {}\nObject.keys(__san_styles__).forEach(function (key) {\nvar module = __san_styles__[key]\n__san_exports__.computed[key] = function () { return module }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnNhbj80ZmEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxDQUFDIiwiZmlsZSI6Ii4vc3JjL0FwcC5zYW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19zYW5fc2NyaXB0X18sIF9fc2FuX3RlbXBsYXRlX19cbnZhciBfX3Nhbl9zdHlsZXNfXyA9IHt9XG5fX3Nhbl9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhISEuLi9ub2RlX21vZHVsZXMvX3Nhbi1sb2FkZXJAMC4wLjdAc2FuLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC5zYW5cIilcbmlmIChfX3Nhbl9zY3JpcHRfXyAmJlxuICAgIF9fc2FuX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Nhbl9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbc2FuLWxvYWRlcl0gc3JjXFxcXEFwcC5zYW46IG5hbWVkIGV4cG9ydHMgaW4gKi5zYW4gZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX19zYW5fdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIWh0bWwtbG9hZGVyP21pbmltaXplPWZhbHNlIS4uL25vZGVfbW9kdWxlcy9fc2FuLWxvYWRlckAwLjAuN0BzYW4tbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9BcHAuc2FuXCIpXG52YXIgX19zYW5fcHJvdG9fXyA9IHt9XG5pZiAoX19zYW5fc2NyaXB0X18pIHtcbiAgX19zYW5fcHJvdG9fXyA9IF9fc2FuX3NjcmlwdF9fLl9fZXNNb2R1bGVcbiAgICA/IF9fc2FuX3NjcmlwdF9fWydkZWZhdWx0J11cbiAgICA6IF9fc2FuX3NjcmlwdF9fXG59XG5pZiAoX19zYW5fdGVtcGxhdGVfXykge1xuICBfX3Nhbl9wcm90b19fLnRlbXBsYXRlID0gX19zYW5fdGVtcGxhdGVfX1xufVxudmFyIHNhbiA9IHJlcXVpcmUoXCJzYW5cIilcbnZhciBfX3Nhbl9leHBvcnRzX18gPSBzYW4uZGVmaW5lQ29tcG9uZW50KF9fc2FuX3Byb3RvX18pXG5tb2R1bGUuZXhwb3J0cyA9IF9fc2FuX2V4cG9ydHNfX1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHNbJ2RlZmF1bHQnXVxuaWYgKCFfX3Nhbl9leHBvcnRzX18uY29tcHV0ZWQpIF9fc2FuX2V4cG9ydHNfXy5jb21wdXRlZCA9IHt9XG5PYmplY3Qua2V5cyhfX3Nhbl9zdHlsZXNfXykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG52YXIgbW9kdWxlID0gX19zYW5fc3R5bGVzX19ba2V5XVxuX19zYW5fZXhwb3J0c19fLmNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/App.san\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var san_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! san-router */ \"./node_modules/_san-router@1.2.0@san-router/dist/san-router.source.js\");\n/* harmony import */ var san_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(san_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _App_san__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.san */ \"./src/App.san\");\n/* harmony import */ var _App_san__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_App_san__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nsan_router__WEBPACK_IMPORTED_MODULE_0__[\"router\"].add({\r\n    rule: '/',\r\n    Component: _App_san__WEBPACK_IMPORTED_MODULE_1___default.a,\r\n    target: '#app'\r\n})\r\n\r\nsan_router__WEBPACK_IMPORTED_MODULE_0__[\"router\"].start();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByb3V0ZXIgfSBmcm9tICdzYW4tcm91dGVyJztcclxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcC5zYW4nO1xyXG5cclxucm91dGVyLmFkZCh7XHJcbiAgICBydWxlOiAnLycsXHJcbiAgICBDb21wb25lbnQ6IEFwcCxcclxuICAgIHRhcmdldDogJyNhcHAnXHJcbn0pXHJcblxyXG5yb3V0ZXIuc3RhcnQoKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/_css-loader@0.28.11@css-loader!./style.css */ \"./node_modules/_css-loader@0.28.11@css-loader/index.js!./src/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/_style-loader@0.21.0@style-loader/lib/addStyles.js */ \"./node_modules/_style-loader@0.21.0@style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUuY3NzPzdhZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJmaWxlIjoiLi9zcmMvc3R5bGUuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZS5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDAuMjEuMEBzdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGUuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/style.css\n");

/***/ })

/******/ });